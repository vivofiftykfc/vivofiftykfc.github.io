<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第三章 随机过程-谱分析</title>
    <link href="/2025/10/22/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B-%E8%B0%B1%E5%88%86%E6%9E%90/"/>
    <url>/2025/10/22/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B-%E8%B0%B1%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>好疲惫喵 QAQ 不想写了喵 QAQ</p><h1 id="随机过程的谱分析">1 随机过程的谱分析</h1><p>让我们像以往一样，在分析随机信号之前，先从确定信号说起，来建立起初步的感知。</p><h2 id="确定信号的频谱回顾">1.1 确定信号的频谱回顾</h2><h3 id="能量信号energy-signal">（1）能量信号（Energy Signal）</h3><p>较为简单的一个东西，比如一个duang的声音，播放完就没有了，能量有限可以直接算出。</p><p>信号在时间上可以很乱，但我们往往关心它“在哪些频率上有能量”。<br />于是，从时域走向频域，第一步是能量的定义：</p><p><span class="math display">\[E = \int_{-\infty}^{+\infty} |x(t)|^2 \, dt\]</span></p><p>若 <spanclass="math inline">\(E&lt;\infty\)</span>，称为能量信号（如有限时间非周期信号）。</p><p>其傅里叶变换为： <span class="math display">\[X(\omega) = \int_{-\infty}^{+\infty} x(t)e^{-j\omega t} dt\]</span></p><p>他的模平方就是能量在频率上的分布，称为能量谱密度：</p><p><span class="math display">\[|X(\omega)|^2\]</span></p><p><strong>Parseval 定理：</strong></p><p><span class="math display">\[\int_{-\infty}^{+\infty} |x(t)|^2 dt = \frac{1}{2\pi}\int_{-\infty}^{+\infty} |X(\omega)|^2 d\omega\]</span></p><p>能量谱密度反映了信号能量在频域中的分布。</p><p>从直觉上来看，就是这个时域的平方积分和频域的平方积分之间的转换，我们可以在不同的维度下求出能量。</p><hr /><h3 id="功率信号power-signal">（2）功率信号（Power Signal）</h3><p><span class="math inline">\(X(t)\)</span>通常不会结束，能量无穷大。</p><p>于是我们换一个视角，只看单位时间的平均能量（即功率）：</p><p><span class="math display">\[P = \lim_{T\to\infty} \frac{1}{2T} \int_{-T}^{T} |x(t)|^2 dt\]</span></p><p>功率有限的周期信号为功率信号。于是我们关心的变成了功率在频率上的分布，也就是功率谱密度（PSD）。</p><p>功率谱密度（PSD）定义为：</p><p><span class="math display">\[S_x(\omega) = \lim_{T\to\infty} \frac{E[|X_T(\omega)|^2]}{2T}\]</span></p><p>其中 <span class="math inline">\(X_T(\omega)\)</span> 为时间窗 <spanclass="math inline">\([-T, T]\)</span> 内的傅里叶变换。</p><p>所以这个PSD就是频率维度上的平均功率分布。</p><hr /><h2 id="随机信号的平均功率谱密度">1.2 随机信号的平均功率谱密度</h2><p>随机信号 <span class="math inline">\(X(t)\)</span> 的功率谱密度：</p><p>他的含义就是信号在某个频域附近的平均功率是多少。</p><p><span class="math display">\[S_X(\omega) = \lim_{T \to \infty} \frac{E[|X_T(\omega)|^2]}{2T}\]</span></p><p>特点：</p><blockquote><p>[!WARNING] 未经证实的特点，需要下一步勘误</p></blockquote><ol type="1"><li><p>样本信号一般为功率信号；</p></li><li><p>各样本信号的谱密度不同；</p></li><li><p><span class="math inline">\(S_X(\omega)\)</span>是随机函数，一般取<strong>数学期望</strong>；</p></li><li><p>随机信号功率 <span class="math inline">\(P_X =E[|X(t)|^2]\)</span> 是随机变量，通常只关心其均值。</p></li></ol><hr /><h2 id="功率谱密度与复频率面">1.3 功率谱密度与复频率面</h2><p>功率谱密度 <span class="math inline">\(S_X(\omega)\)</span>在复频率面 <span class="math inline">\(s=j\omega\)</span> 上定义： <spanclass="math display">\[S_X(s) = \int_{-\infty}^{+\infty} R_X(\tau)e^{-s\tau} d\tau\]</span> 若 <span class="math inline">\(S_X(\omega)\)</span>是有理谱，则可表示为： <span class="math display">\[S_X(s) = K \frac{\prod (s - \alpha_i)(s + \alpha_i)}{\prod (s -\beta_i)(s + \beta_i)}\]</span> 实信号满足： <span class="math display">\[S_X(s) = S_X^*(-s)\]</span></p><p>这个的具体求解要回去翻信号与系统，学一下拉普拉斯变换。</p><hr /><h1 id="随机过程功率谱密度的性质">2 随机过程功率谱密度的性质</h1><ol type="1"><li><p><strong>实偶性：</strong> <span class="math display">\[S_X(-\omega) = S_X(\omega)\]</span></p></li><li><p><strong>非负性：</strong> <span class="math display">\[S_X(\omega) \ge 0\]</span></p></li><li><p><strong>Parseval 关系：</strong> <span class="math display">\[R_X(0) = \frac{1}{2\pi} \int_{-\infty}^{+\infty} S_X(\omega)d\omega\]</span></p></li><li><p><strong>积分有限性：</strong> 对平稳过程，<spanclass="math inline">\(\int S_X(\omega)d\omega\)</span> 收敛。</p></li><li><p><strong>有理谱分解：</strong>若谱为有理函数，则其极点在左半平面，零点在虚轴或左半平面上。</p></li></ol><hr /><h1 id="功率谱密度与自相关函数的关系">3功率谱密度与自相关函数的关系</h1><h2id="维纳辛钦定理wienerkhinchin-theorem">维纳–辛钦定理（Wiener–KhinchinTheorem）</h2><p>若随机过程 <span class="math inline">\(X(t)\)</span>是宽平稳的（WSS），则： <span class="math display">\[S_X(\omega) = \int_{-\infty}^{+\infty} R_X(\tau)e^{-j\omega\tau} d\tau\]</span> <span class="math display">\[R_X(\tau) = \frac{1}{2\pi}\int_{-\infty}^{+\infty}S_X(\omega)e^{j\omega\tau} d\omega\]</span></p><p>平均功率： <span class="math display">\[E[X^2(t)] = R_X(0) = \frac{1}{2\pi}\int_{-\infty}^{+\infty}S_X(\omega)d\omega\]</span></p><p>信号越“平滑”，<span class="math inline">\(R_X(\tau)\)</span>衰减越慢，对应低频占主导；<br />信号变化越快，<span class="math inline">\(R_X(\tau)\)</span>快速衰减，对应高频成分强。</p><hr /><h1 id="离散时间随机过程的功率谱密度">4离散时间随机过程的功率谱密度</h1><p>如果这个 <span class="math inline">\(X(n)\)</span> 是 <spanclass="math inline">\(X(t)\)</span> 经过采样间隔 <spanclass="math inline">\(T\)</span>均匀采样之后得到的广义平稳随机序列：</p><p>若 <span class="math inline">\(X(n)\)</span> 为平稳离散随机序列：</p><p><span class="math display">\[R_X(m) = E[X(n)X(n+m)] = R_X(mT)\]</span></p><p>则其功率谱密度为：</p><p><span class="math display">\[S_X(\Omega) = \sum_{m=-\infty}^{+\infty} R_X(m)e^{-j\Omega m}\]</span></p><p>其逆变换：</p><p><span class="math display">\[R_X(m) = \frac{1}{2\pi}\int_{-\pi}^{\pi} S_X(\Omega)e^{j\Omega m}d\Omega\]</span></p><p>平均功率：</p><p><span class="math display">\[E[|X(n)|^2] = R_X(0) = \frac{1}{2\pi}\int_{-\pi}^{\pi}S_X(\Omega)d\Omega\]</span></p><p>采样间隔为 <span class="math inline">\(T\)</span> 时：</p><p><span class="math display">\[S_X(\omega) =\frac{1}{T} \sum_{k=-\infty}^{+\infty} S_c(\omega -k\omega_s)\]</span></p><p>这就是<strong>功率谱密度的采样定理</strong>。</p><p>其中 <span class="math inline">\(\omega_s =\frac{2\pi}{T}\)</span></p><blockquote><p>[!NOTE]采样定理讲的不细，这个还不是很理解，因为信号与系统没学好这个都没咋认真听。包括什么谱分解定理，更是不会。</p></blockquote><hr /><h1 id="联合平稳随机过程的互谱密度">5 联合平稳随机过程的互谱密度</h1><p>我说实在的，我已经看不懂她PPT上在推导什么了，下面的这些笔记全都是AI代劳的。</p><p>若 <span class="math inline">\(X(t)\)</span> 与 <spanclass="math inline">\(Y(t)\)</span> 为联合平稳过程，则定义互功率谱密度：<span class="math display">\[S_{XY}(\omega) = \int_{-\infty}^{+\infty} R_{XY}(\tau)e^{-j\omega\tau}d\tau\]</span></p><p>性质： 1. <span class="math inline">\(S_{XY}^*(\omega) =S_{YX}(\omega)\)</span>； 2. 对实过程有 <spanclass="math inline">\(S_{XY}(-\omega) = S_{YX}^*(\omega)\)</span>； 3.若 <span class="math inline">\(X,Y\)</span> 不相关，则 <spanclass="math inline">\(S_{XY}(\omega)=0\)</span>。</p><hr /><h1 id="白噪声white-noise">6 白噪声（White Noise）</h1><h2 id="定义">（1）定义</h2><ul><li><p>若功率谱密度为常数： <span class="math display">\[S_N(\omega) = \frac{N_0}{2}\]</span> 则称该噪声为<strong>白噪声</strong>。</p></li><li><p>自相关函数： <span class="math display">\[R_N(\tau) = \frac{N_0}{2}\delta(\tau)\]</span></p></li></ul><hr /><h2 id="理想白噪声">（2）理想白噪声</h2><p>特征： - 均值为零； - <spanclass="math inline">\(S_N(\omega)\)</span> 为常数； - 平均功率无穷大； -实际中不存在，只能近似。</p><hr /><h2 id="限带白噪声与色噪声">（3）限带白噪声与色噪声</h2><ul><li><p>若 <span class="math inline">\(S_N(\omega)\)</span> 在有限带宽<span class="math inline">\([-W, W]\)</span> 内为常数： <spanclass="math display">\[S_N(\omega) = N_0/2, \quad |\omega| \le W\]</span> 称为<strong>限带白噪声</strong>；</p></li><li><p>若谱密度随频率变化，则为<strong>色噪声（ColoredNoise）</strong>。</p></li></ul><hr /><h2 id="信噪比snr">（4）信噪比（SNR）</h2><p>定义： <span class="math display">\[\mathrm{SNR} = \frac{P_s}{P_n}, \quad \text{(dB)} =10\log_{10}\frac{P_s}{P_n}\]</span></p><p><strong>例：</strong> 已知 <spanclass="math inline">\(s(t)=4\cos(\omega_0 t)\)</span>，<spanclass="math inline">\(n(t)\)</span> 为带宽 <spanclass="math inline">\(2\)</span> kHz、功率谱密度 <spanclass="math inline">\(S_N(\omega)=2\)</span> 的低通白噪声：</p><p><span class="math display">\[P_s = \frac{A^2}{2} = 8, \quad P_n = 2W/\pi = 8000\]</span> <span class="math display">\[\mathrm{SNR} = 10\log_{10}\frac{8}{8000} \approx -30 \text{ dB}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>随机信号分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 随机过程-时域分析</title>
    <link href="/2025/10/21/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B-%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/"/>
    <url>/2025/10/21/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B-%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="随机过程的基本概念及其统计特性">1随机过程的基本概念及其统计特性</h1><h2 id="随机过程的基本概念">1.1 随机过程的基本概念</h2><p>随机过程 <span class="math inline">\(X(t,s)\)</span>可以从<strong>宏观</strong>和<strong>微观</strong>两个角度理解：</p><table><thead><tr><th style="text-align: center;">视角</th><th style="text-align: center;">描述</th><th style="text-align: center;">固定项</th><th style="text-align: center;">变量项</th><th style="text-align: center;">结果</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>宏观（时间函数族）</strong></td><td style="text-align: center;">样本空间到函数空间的映射</td><td style="text-align: center;">无固定</td><td style="text-align: center;"><span class="math inline">\(t\)</span>和 <span class="math inline">\(s\)</span> 都是变量</td><td style="text-align: center;">随机过程</td></tr><tr><td style="text-align: center;"><strong>样本函数</strong></td><td style="text-align: center;">随机过程的一次实现</td><td style="text-align: center;"><span class="math inline">\(s\)</span>固定</td><td style="text-align: center;"><span class="math inline">\(t\)</span>是变量</td><td style="text-align: center;">确知时间函数</td></tr><tr><tdstyle="text-align: center;"><strong>微观（时变随机变量）</strong></td><td style="text-align: center;">对于每个特定时间 <spanclass="math inline">\(t_i\)</span>，它都是随机变量</td><td style="text-align: center;"><span class="math inline">\(t\)</span>固定</td><td style="text-align: center;"><span class="math inline">\(s\)</span>是变量</td><td style="text-align: center;">随机变量</td></tr><tr><td style="text-align: center;"><strong>确定值</strong></td><td style="text-align: center;">样本点和时间都固定</td><td style="text-align: center;"><span class="math inline">\(t\)</span>和 <span class="math inline">\(s\)</span> 都固定</td><td style="text-align: center;">无变量</td><td style="text-align: center;">确定值</td></tr></tbody></table><p>**定义1（时间函数族/宏观）：</p><p>设随机实验的样本空间 <spanclass="math inline">\(S=\{s_i\}\)</span>，对于空间的每个样本 <spanclass="math inline">\(s_i \in S\)</span>，总有一个时间函数 <spanclass="math inline">\(X(t,s_i)\)</span> 与之对应 (<spanclass="math inline">\(t \in T\)</span>)，空间的所有样本 <spanclass="math inline">\(S=\{s_i\}\)</span> 对应一族时间函数 <spanclass="math inline">\(\{X(t,s_i), s_i \inS\}\)</span>，则样本空间到函数空间的映射称为随机过程。</p><p>**定义2（时变随机变量/微观）：</p><p>对于每个特定的时间 <span class="math inline">\(t_i\)</span>，<spanclass="math inline">\(X(t_i,s)\)</span> 都是随机变量，则称 <spanclass="math inline">\(X(t,s)\)</span> 为随机过程。</p><p>这个在通信原理实际上已经明白了，不再细讲。</p><h2 id="随机过程的分类">1.2 随机过程的分类</h2><h4id="一按时间和幅度状态连续离散">一、按时间和幅度（状态）连续/离散</h4><ul><li><strong>连续型随机过程：</strong> 时间连续，状态连续。</li><li><strong>离散型随机过程：</strong> 时间连续，状态离散。</li><li><strong>连续随机序列：</strong> 时间离散，状态连续。</li><li><strong>离散随机序列：</strong> 时间离散，状态离散。</li></ul><p>一堆废话，不用看。</p><h4 id="二按样本函数的性质">二、按样本函数的性质</h4><ul><li><p>**不确定（不可预测）随机过程</p></li><li><p><strong>确定（可预测）随机过程</strong>：如随机相位信号 <spanclass="math inline">\(A\sin(\omega t+\Phi), \Phi \simU(0,2\pi)\)</span>。</p></li></ul><h4 id="三按概率分布的特性">三、按概率分布的特性</h4><ul><li><strong>平稳随机过程：</strong>统计特性不随时间变化的，如热噪声。</li><li><strong>正态随机过程</strong></li><li><strong>马尔科夫随机过程</strong></li><li><strong>独立增量过程</strong></li><li><strong>独立随机过程</strong></li></ul><p>不用细看，只要有这样的分类就行，没啥用。</p><h2 id="随机过程的概率分布">1.3 随机过程的概率分布</h2><p>“随机”中的“确定”是指用统计平均值（矩、特征函数、概率分布/密度函数）来描述随机过程的整体特性。</p><h4 id="一一维概率分布">一、一维概率分布</h4><ul><li><p><strong>一维分布函数：</strong> <spanclass="math inline">\(F_X(x;t) = P\{X(t) \lex\}\)</span>（是确定函数）。</p></li><li><p><strong>一维概率密度：</strong> <spanclass="math inline">\(f_X(x;t) = \frac{\partial F_X(x;t)}{\partialx}\)</span>（可能是时变概率密度）。</p></li></ul><h4 id="二二维概率分布">二、二维概率分布</h4><ul><li><p><strong>二维分布函数：</strong> <spanclass="math inline">\(F_{X_1X_2}(x_1,x_2;t_1,t_2) = P\{X(t_1) \le x_1,X(t_2) \le x_2\}\)</span>。</p></li><li><p><strong>二维概率密度：</strong> <spanclass="math inline">\(f_{X_1X_2}(x_1,x_2;t_1,t_2) = \frac{\partial^2F_{X_1X_2}(x_1,x_2;t_1,t_2)}{\partial x_1 \partialx_2}\)</span>。</p></li></ul><h4id="三利用随机变量变换求概率密度函数">三、利用随机变量变换求概率密度函数</h4><ul><li><p><strong>单调可逆变换：</strong> <span class="math inline">\(Y =g(X), X = h(Y)\)</span></p><p><span class="math display">\[f_Y(y) = f_X[x=h(y)] \left|\frac{dh(y)}{dy} \right| = f_X(x) \left| \frac{dg(x)}{dx} \right|^{-1}\Big|_{x=h(y)}\]</span></p></li><li><p><strong>非单调可逆变换：</strong> <span class="math inline">\(Y =g(X)\)</span>，有多个根 <span class="math inline">\(X_k =h_k(Y)\)</span></p><p><span class="math display">\[f_Y(y) = \sum_{k} f_X[x=h_k(y)] \left|\frac{dh_k(y)}{dy} \right|\]</span></p></li><li><p><strong>二维变换（Jacobian行列式）：</strong> <spanclass="math inline">\(Y_1=g_1(X_1,X_2), Y_2=g_2(X_1,X_2)\)</span></p><p><span class="math display">\[f_{Y_1Y_2}(y_1,y_2) = \left|J_h(y_1,y_2) \right| f_{X_1X_2}[x_1=h_1(y_1,y_2),x_2=h_2(y_1,y_2)]\]</span></p><p>其中 <span class="math inline">\(|J_h|\)</span> 是 <spanclass="math inline">\(X_1, X_2\)</span> 对 <spanclass="math inline">\(Y_1, Y_2\)</span>的偏导数构成的行列式绝对值。</p></li></ul><p>第一章讲差不多了，这里不再细说。</p><h2 id="随机过程的数字特征">1.4 随机过程的数字特征</h2><ul><li><strong>均值函数</strong> <span class="math inline">\(m_X(t) =E[X(t)]\)</span></li></ul><p>注：也叫二阶原点矩</p><ul><li><strong>方差函数</strong> <span class="math inline">\(D_X(t) =E\{[X(t)-m_X(t)]^2\}\)</span></li></ul><p>注：也叫二阶中心矩</p><ul><li><p><strong>自相关函数</strong> <span class="math inline">\(R_X(t_1,t_2) = E[X(t_1)X(t_2)]\)</span></p></li><li><p><strong>协方差函数</strong> <span class="math inline">\(K_X(t_1,t_2) = R_X(t_1, t_2) - m_X(t_1)m_X(t_2)\)</span></p></li></ul><h1 id="随机过程的微分与积分">2 随机过程的微分与积分</h1><h2 id="基础概念均方极限">2.0 基础概念：均方极限</h2><ul><li><p><strong>二阶矩过程：</strong> 满足 <spanclass="math inline">\(\forall t \in T, E[X^2(t)] &lt; \infty\)</span>的随机过程。</p></li><li><p><strong>均方极限（l.i.m.）：</strong> 称随机变量序列 <spanclass="math inline">\(\{X_n\}\)</span> 均方收敛于 <spanclass="math inline">\(X\)</span>，记为 <spanclass="math inline">\(\underset{n\rightarrow\infty}{\mathrm{l.i.m.}} X_n= X\)</span>，此时：</p><p><span class="math display">\[\lim_{n\rightarrow\infty} E|X_n - X|^2 =0\]</span></p></li></ul><p>其中l.i.m是英文limit in mean square的缩写</p><p>之所以定义一个均方收敛，其意义和普通的收敛不同，强调是他的均方会收敛到一个值，而不是所有的样本点会收敛到一个值。</p><p>当然，在做题上来说，实际上还是用求微积分的那一套罢了。</p><h4 id="均方极限的性质">均方极限的性质</h4><p><span class="math display">\[\underset{n \to \infty}{\text{l.i.m}}c_n = \lim_{n \to \infty} c_n = c\]</span></p><p><span class="math display">\[\underset{n \to \infty}{\text{l.i.m}} Z= Z \]</span></p><p><span class="math display">\[\underset{n \to \infty}{\text{l.i.m}}c_n Z = cZ\]</span></p><ul><li><p><strong>运算性：</strong> 均方极限与加法、常数乘法、期望（<spanclass="math inline">\(E\)</span>）的次序可交换。</p><p><span class="math display">\[\underset{n \to \infty}{\text{l.i.m}}(aX_n + bY_n) = aX + bY\]</span></p><p><span class="math display">\[\lim_{n\rightarrow\infty} E X_n = E X =E \left[ \lim_{n\rightarrow\infty} X_n \right]\]</span></p></li><li><p><strong>均方收敛判定准则（Cauchy准则）：</strong> <spanclass="math inline">\(\{X_n\}\)</span> 均方收敛的充要条件是：</p><p><span class="math display">\[\lim_{n,m\rightarrow\infty} E|X_m -X_n|^2 = 0\]</span></p></li></ul><h2 id="随机连续性均方连续">2.1 随机连续性：均方连续</h2><ul><li><p><strong>定义：</strong> 称 <spanclass="math inline">\(X(t)\)</span> 在时刻 <spanclass="math inline">\(t_0\)</span> 均方连续，如果：</p><p><span class="math display">\[\lim_{\Delta t\rightarrow0}E\{[X(t_0+\Delta t)-X(t_0)]^2\} = 0\]</span></p></li><li><p><strong>均方连续准则（充要条件）：</strong></p><p>二阶矩过程 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t_0\)</span>处均方连续的充要条件为：<strong>相关函数 <spanclass="math inline">\(R(s,t)\)</span> 在 <spanclass="math inline">\((t_0, t_0)\)</span> 处连续</strong>。</p><p>（二阶矩过程的均方连续性可用它的相关函数的普通连续性来确定。）</p></li><li><p><strong>性质：</strong></p><ul><li><p>若 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t_0\)</span> 处均方连续，则其均值函数 <spanclass="math inline">\(m_X(t)\)</span> 和方差函数 <spanclass="math inline">\(D_X(t)\)</span> 也在 <spanclass="math inline">\(t_0\)</span> 处连续。</p></li><li><p><strong>“E” 和 “l.i.m.” 次序可换。</strong></p></li></ul></li></ul><h2 id="随机过程的微分均方可微">2.2 随机过程的微分（均方可微）</h2><ul><li><p><strong>均方可微准则（充要条件）：</strong></p><p>二阶矩过程 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t_0\)</span>处均方可微的充要条件为：<strong>相关函数 <spanclass="math inline">\(R(s,t)\)</span> 在 <spanclass="math inline">\((t_0, t_0)\)</span>处广义二阶可微</strong>。用人话来说就是相关函数在它的自变量相等时，存在二阶混合偏导数且连续。</p></li><li><p><strong>均方导数的性质：</strong></p><ul><li><p>若 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t\)</span> 处均方可微，则 <spanclass="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t\)</span> 处均方连续。</p></li><li><p><strong>“E” 和 “<spanclass="math inline">\(\frac{d(\cdot)}{dt}\)</span>”次序可交换。</strong> 即 <span class="math inline">\(E[\frac{d}{dt}X(t)]= \frac{d}{dt}E[X(t)]\)</span>。</p></li></ul></li></ul><h2 id="随机过程的积分均方可积">2.3 随机过程的积分（均方可积）</h2><ul><li><p><strong>均方可积充分条件：</strong></p><ul><li><p>对于二阶矩过程 <spanclass="math inline">\(X(t)\)</span>，若其相关函数 <spanclass="math inline">\(R(s,t)\)</span> 的二重积分存在且有限，则 <spanclass="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上均方可积。</p></li><li><p>若 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上均方连续，则 <spanclass="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上均方可积。</p></li></ul></li><li><p><strong>均方积分的性质：</strong></p><ul><li><strong>“E” 与均方积分次序可换。</strong> 即 <spanclass="math inline">\(E[\int_a^b X(t)dt] = \int_a^bE[X(t)]dt\)</span>。</li></ul></li></ul><h1 id="平稳随机过程和遍历性过程">3 平稳随机过程和遍历性过程</h1><h2 id="平稳随机过程">3.1 平稳随机过程</h2><ul><li><p><strong>平稳随机过程：</strong>统计特性不随时间的推移而变化的随机过程。</p></li><li><p>分为：<strong>严平稳（SSS）</strong> 和<strong>宽平稳（WSS）</strong>。</p></li></ul><h4id="一严平稳随机过程strict-sense-stationary-sss">一、严平稳随机过程（Strict-SenseStationary, SSS）</h4><ul><li><p><strong>定义：</strong> 随机过程 <spanclass="math inline">\(X(t)\)</span> 的<strong>任意 <spanclass="math inline">\(n\)</span> 维概率分布函数</strong> <spanclass="math inline">\(F_X(x_1,\dots,x_n; t_1,\dots,t_n)\)</span><strong>不随时间平移而变化</strong>，即与时间起点无关，只与时间差 <spanclass="math inline">\(\tau_k=t_k-t_1\)</span> 有关。</p><p><span class="math display">\[F_X(x_1,\dots,x_n; t_1,\dots,t_n) =F_X(x_1,\dots,x_n; t_1+\tau,\dots,t_n+\tau)\]</span></p></li><li><p><strong>低阶矩特性：</strong></p><ul><li><p>均值函数 <span class="math inline">\(m_X(t)\)</span> 与时间 <spanclass="math inline">\(t\)</span> 无关，为常数。</p></li><li><p>自相关函数 <span class="math inline">\(R_X(t_1, t_2)\)</span>只与时间差 <span class="math inline">\(\tau=t_2-t_1\)</span> 有关，即<span class="math inline">\(R_X(\tau)\)</span>。</p></li></ul></li></ul><p>但是很明显，这个条件过于的严苛，一般是到不了的，所以适用范围相对较窄，我们需要引入这个宽平稳来说事。</p><h4id="二宽平稳随机过程wide-sense-stationary-wss">二、宽平稳随机过程（Wide-SenseStationary, WSS）</h4><ul><li><p><strong>定义（辛钦Khinchine）：</strong> 随机过程 <spanclass="math inline">\(X(t)\)</span> 满足：</p><ol type="1"><li><p><strong>均值函数</strong> <spanclass="math inline">\(m_X(t)\)</span> 是一个与时间 <spanclass="math inline">\(t\)</span> 无关的常数 <spanclass="math inline">\(m_X\)</span>。</p></li><li><p><strong>自相关函数</strong> <span class="math inline">\(R_X(t_1,t_2)\)</span> 只与时间差 <spanclass="math inline">\(\tau=t_2-t_1\)</span> 有关，即 <spanclass="math inline">\(R_X(\tau)\)</span>。</p></li></ol></li><li><p><strong>关系：</strong></p><ul><li>严平稳 <span class="math inline">\(\implies\)</span>宽平稳（反之不成立，<strong>正态过程除外</strong>）。</li></ul></li><li><p><strong>性质：</strong></p></li></ul><p>这一部分说实在的没怎么看清楚看明白。</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510212240528.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510212240090.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510212240434.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510212240378.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>接着引入相关时间：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510212242286.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><span class="math inline">\(\tau_0\)</span> 越小意味着相关系数随着<span class="math inline">\(\tau\)</span>增加而衰落的更快，表明随机过程随着时间变化更剧烈。</p><h2 id="循环平稳随机过程">3.2 循环平稳随机过程</h2><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510212238228.png"alt="作为补充" /><figcaption aria-hidden="true">作为补充</figcaption></figure><h2 id="遍历性过程ergodicity">3.3 遍历性过程（Ergodicity）</h2><p><strong>就是将统计平均变为时间平均</strong>。</p><ul><li><p><strong>基本思想：</strong>统计平均（对样本族求平均）等于时间平均（对单个样本函数求时间平均）。</p><ul><li><strong>时间平均：</strong> 时间均值 <spanclass="math inline">\(\overline{X}\)</span>、时间相关函数 <spanclass="math inline">\(\mathfrak{R}_X(\tau)\)</span>。</li></ul></li><li><p><strong>宽遍历性过程的定义：</strong> 设随机过程 <spanclass="math inline">\(X(t)\)</span>为广义平稳，<strong>且同时满足均值和自相关函数的遍历性</strong>，则定义该随机过程为宽遍历性过程。</p><ol type="1"><li><p><strong>均值遍历性：</strong> 时间均值均方收敛于统计均值。</p><p><span class="math display">\[\overline{X} = \lim_{T\rightarrow\infty}\frac{1}{2T} \int_{-T}^{T} X(t)dt \xrightarrow{\mathrm{m.s.}}E[X(t)]\]</span></p></li><li><p><strong>自相关函数遍历性：</strong>时间自相关函数均方收敛于统计自相关函数。</p><p><span class="math display">\[\mathfrak{R}_X(\tau) =\lim_{T\rightarrow\infty} \frac{1}{2T} \int_{-T}^{T} X(t)X(t+\tau)dt\xrightarrow{\mathrm{m.s.}} R_X(\tau)\]</span></p></li></ol></li></ul><p>实际上就是直接看到平稳信号就直接用了，也不管他三七二十一，瞎几把用就得了。</p><h1 id="随机过程的联合概率分布和互相关函数">4随机过程的联合概率分布和互相关函数</h1><h2 id="两个随机过程的联合概率分布">4.1 两个随机过程的联合概率分布</h2><p>设有两个随机过程 <span class="math inline">\(X(t)\)</span> 和 <spanclass="math inline">\(Y(t)\)</span>。</p><ul><li><p><strong><span class="math inline">\((n+m)\)</span>维联合分布函数：</strong></p><p><spanclass="math display">\[F_{XY}(x_1,\dots,x_n;y_1,\dots,y_m;t_1,\dots,t_n;t_1&#39;,\dots,t_m&#39;)= P\{X(t_1) \le x_1,\dots, X(t_n) \le x_n; Y(t_1&#39;) \le y_1,\dots,Y(t_m&#39;) \le y_m\}\]</span></p></li><li><p><strong><span class="math inline">\((n+m)\)</span>维联合概率密度：</strong></p><p><span class="math display">\[f_{XY}(\dots) =\frac{\partial^{n+m}F_{XY}(\dots)}{\partial x_1 \dots \partial x_n\partial y_1 \dots \partial y_m}\]</span></p></li><li><p><strong>注意：</strong></p><ol type="1"><li><p>若两个过程的 <span class="math inline">\(n+m\)</span>维联合概率分布给定，则它们的全部统计特性也确定了。</p></li><li><p>可由高维联合分布求出它们的低维联合概率分布。</p></li></ol></li></ul><p>没啥好讲的，就单纯上面已知的推广。</p><h2 id="互相关函数">4.2 互相关函数</h2><ul><li><p><strong>互相关函数定义：</strong>描述两个随机过程在不同时刻状态之间的统计关联性。</p><p><span class="math display">\[R_{XY}(t_1, t_2) = E[X(t_1)Y(t_2)] =\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}xyf_{XY}(x,y;t_1,t_2)dxdy\]</span></p></li><li><p><strong>互协方差函数（中心化互相关函数）：</strong> <spanclass="math display">\[K_{XY}(t_1, t_2) =E\{[X(t_1)-m_X(t_1)][Y(t_2)-m_Y(t_2)]\}\]</span> <spanclass="math display">\[K_{XY}(t_1, t_2) = R_{XY}(t_1, t_2) -m_X(t_1)m_Y(t_2)\]</span></p></li></ul><h4 id="相互关系">相互关系</h4><table><thead><tr><th style="text-align: center;">关系</th><th style="text-align: center;">定义</th><th style="text-align: center;">互相关函数 <spanclass="math inline">\(R_{XY}(t_1, t_2)\)</span></th><th style="text-align: center;">互协方差函数 <spanclass="math inline">\(K_{XY}(t_1, t_2)\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><strong>统计独立</strong></td><td style="text-align: center;"><span class="math inline">\(f_{XY} = f_Xf_Y\)</span></td><td style="text-align: center;"><spanclass="math inline">\(m_X(t_1)m_Y(t_2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr><td style="text-align: center;"><strong>不相关</strong></td><td style="text-align: center;"><span class="math inline">\(K_{XY}(t_1,t_2)=0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(m_X(t_1)m_Y(t_2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr><td style="text-align: center;"><strong>正交</strong></td><td style="text-align: center;"><span class="math inline">\(R_{XY}(t_1,t_2)=0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(-m_X(t_1)m_Y(t_2)\)</span></td></tr></tbody></table><blockquote><p>[!WARNING] 这个写的有点问题； 另外，CXZ是我儿</p></blockquote><ul><li><p><strong>注意：</strong></p><ol type="1"><li><p>如果两个随机过程相互独立，且它们的二阶矩都存在，则必互不相关。</p></li><li><p><strong>正态随机过程的不相关与相互独立等价。</strong></p></li></ol></li></ul><p>不想学了听会歌 QAQ</p><p>&lt;iframe width="100%" height="468"src="https://player.bilibili.com/player.html?bvid=BV1JThqzwEGq&amp;p=1&amp;autoplay=0"scrolling="no" border="0" frameborder="no" framespacing="0"allowfullscreen="true" &amp;autoplay=0 &gt;</iframe></p><h4 id="联合平稳性">联合平稳性</h4><ul><li><p><strong>联合严平稳：</strong> <spanclass="math inline">\(X(t)\)</span> 和 <spanclass="math inline">\(Y(t)\)</span>的联合概率分布不随时间平移而变化。</p></li><li><p><strong>联合宽平稳（宽平稳相依）：</strong></p><ol type="1"><li><p><span class="math inline">\(X(t)\)</span> 和 <spanclass="math inline">\(Y(t)\)</span> 各自宽平稳。</p></li><li><p>互相关函数 <span class="math inline">\(R_{XY}(t,t+\tau)=R_{XY}(\tau)\)</span>（只与时间差 <spanclass="math inline">\(\tau\)</span> 有关）。</p></li></ol></li><li><p><strong>联合宽遍历：</strong></p><ol type="1"><li><p><span class="math inline">\(X(t)\)</span> 和 <spanclass="math inline">\(Y(t)\)</span> 联合宽平稳。</p></li><li><p>时间互相关函数均方收敛于统计互相关函数。</p><p><span class="math display">\[\mathfrak{R}_{XY}(\tau) =\underset{T\rightarrow\infty}{\mathrm{l.i.m.}}\frac{1}{2T}\int_{-T}^{T}X(t)Y(t+\tau)dt =R_{XY}(\tau)\]</span></p></li></ol></li></ul><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220029329.png" /></p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220029475.png" /></p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220029649.png" /></p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220030654.png" /></p><h1 id="复随机过程">5 复随机过程</h1><ul><li><strong>复随机信号：</strong> <span class="math inline">\(Z(t) =X_c(t) + jX_s(t)\)</span>。</li></ul><p>他的计算跟实随机过程的区别和复数与实数的区别一样的，这里不再赘述</p><ul><li><p><strong>宽平稳复随机过程：</strong></p><ol type="1"><li><p>均值函数 <span class="math inline">\(m_Z(t) = E[Z(t)]\)</span>是常数。</p></li><li><p>自相关函数 <span class="math inline">\(R_Z(t_1, t_2) =E[Z(t_1)Z^*(t_2)]\)</span> 只与时间差 <spanclass="math inline">\(\tau=t_2-t_1\)</span> 有关，即 <spanclass="math inline">\(R_Z(\tau)\)</span>。</p></li></ol></li><li><p><strong>联合宽平稳复随机过程：</strong></p><ol type="1"><li><p><span class="math inline">\(Z_1(t)\)</span> 和 <spanclass="math inline">\(Z_2(t)\)</span> 各自宽平稳。</p></li><li><p>互相关函数 <span class="math inline">\(R_{Z_1Z_2}(t, t+\tau) =E[Z_1(t)Z_2^*(t+\tau)]\)</span> 只与 <spanclass="math inline">\(\tau\)</span> 有关。</p></li></ol></li></ul><blockquote><p>[!NOTE]可以看出，这个区别跟实数与复数的区别一样的，不用太细致的看。</p></blockquote><h1 id="离散时间随机过程">6 离散时间随机过程</h1><ul><li><p><strong>表示：</strong> <spanclass="math inline">\(X(nT)\)</span> 或 <spanclass="math inline">\(X(n)\)</span>。</p></li><li><p><strong>分析方法：</strong>本质上与连续时间随机信号的分析一样。</p></li><li><p><strong>对应关系：</strong> 时间变量 <spanclass="math inline">\(t \rightarrow n\)</span>。</p></li></ul><blockquote><p>[!NOTE]可以看出，这个和连续时间的区别基本等于没有，不用太细致的看。</p></blockquote><h1 id="正态随机过程">7 正态随机过程</h1><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220054943.png"alt="高斯分布性质" /><figcaption aria-hidden="true">高斯分布性质</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220055991.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li><p><strong>主要性质：</strong></p><ol type="1"><li><p>正态随机过程的 <span class="math inline">\(n\)</span>维概率密度<strong>完全由它的均值集合和协方差函数集合所确定</strong>。</p></li><li><p><strong>正态过程的严平稳与宽平稳等价。</strong></p></li><li><p><strong>正态过程的不相关与相互独立等价。</strong></p></li><li><p>正态随机过程通过线性系统后的输出仍为正态过程。</p></li></ol></li></ul><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510220056953.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><blockquote><p>[!ERROR] 平稳正态随机过程在这里略掉了喵</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>随机信号分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 概率论基础</title>
    <link href="/2025/10/21/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/10/21/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>这是正文</p><h1 id="基本概念">1.1 基本概念</h1><ul><li><p><strong>随机试验 (RandomExperiment)</strong>：结果不可预知，但可重复。</p></li><li><p><strong>样本空间 <spanclass="math inline">\(\Omega\)</span></strong>：所有可能结果的集合。</p></li><li><p><strong>随机事件 <span class="math inline">\(A \subseteq\Omega\)</span></strong>：</p><ul><li><p>基本事件：仅含一个结果；</p></li><li><p>复合事件：多个结果；</p></li><li><p><span class="math inline">\(\Omega\)</span> 为必然事件，<spanclass="math inline">\(\varnothing\)</span> 为不可能事件。</p></li></ul></li><li><p><strong>概率（公理化定义）</strong></p><ol type="1"><li><p><span class="math inline">\(0 \le P(A) \le 1\)</span></p></li><li><p><span class="math inline">\(P(\Omega) = 1\)</span></p></li><li><p>若 <span class="math inline">\(A \cap B =\varnothing\)</span>，则 <span class="math inline">\(P(A \cup B) = P(A)+ P(B)\)</span></p></li></ol></li></ul><blockquote><p>注：古典概率 / 几何概率 / 频率概率 /公理化概率只是不同理解方式，本课程采用<strong>公理化定义 +密度函数形式化处理</strong>。</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510211315331.png"alt="一点小概念的复习" /><figcaption aria-hidden="true">一点小概念的复习</figcaption></figure><hr /><h1 id="一维随机变量">1.2 一维随机变量</h1><h2 id="定义">定义</h2><p>随机变量 <spanclass="math inline">\(X(\omega)\)</span>：是从样本空间映射到实数域的函数。</p><h2 id="分布函数">分布函数</h2><p><span class="math display">\[F_X(x) = P\{X \le x\}\]</span></p><p>性质：</p><ol type="1"><li><strong>单调非减</strong>；</li><li><strong>右连续</strong>；</li><li><span class="math inline">\(\lim_{x\to -\infty}F=0\)</span>，<spanclass="math inline">\(\lim_{x\to +\infty}F=1\)</span></li></ol><h2 id="离散型与连续型">离散型与连续型</h2><table><thead><tr><th>类型</th><th>描述</th><th>表征方式</th></tr></thead><tbody><tr><td>离散型</td><td><span class="math inline">\(P\{X=x_k\}=p_k\)</span></td><td>概率质量函数 (PMF)</td></tr><tr><td>连续型</td><td><span class="math inline">\(P\{x&lt;X&lt;x+dx\}=f(x)dx\)</span></td><td>概率密度函数 (PDF)</td></tr></tbody></table><p>离散型的 PDF 也可用 <strong>Dirac 函数统一</strong>：</p><p><span class="math display">\[f(x) = \sum_k p_k \delta(x -x_k)\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510211308646.png"alt="注意这三个东西，CDF、PDF、PMF的区别与联系" /><figcaptionaria-hidden="true">注意这三个东西，CDF、PDF、PMF的区别与联系</figcaption></figure><hr /><h2 id="随机变量函数变换">随机变量函数变换</h2><p>若 <span class="math inline">\(Y = g(X)\)</span>：</p><ul><li>单调可逆：</li></ul><p><span class="math display">\[f_Y(y) = f_X(x) \left| \frac{dx}{dy}\right|\]</span></p><p>具体推导方式就是：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510211327383.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>看这个图，如果要求这个y的分布的话，直接拿这个 <spanclass="math inline">\(\Delta y\)</span> 和 <spanclass="math inline">\(\Delta x\)</span> 的比值就是这个 y 和 x的比值来算</p><ul><li>非单调可逆：<strong>多个解累加</strong>。</li></ul><blockquote><p>常见例子：<span class="math inline">\(Y = \sin X\)</span>、<spanclass="math inline">\(Y = X^2\)</span> 等。</p></blockquote><p>这个题的话，等会看看作业里面有没有，ppt上的题不是很清楚。</p><hr /><h1 id="多维随机变量">1.3 多维随机变量</h1><h2 id="联合分布函数">联合分布函数</h2><p><span class="math display">\[F_{XY}(x,y) = P\{X \le x, Y \ley\}\]</span></p><h2 id="联合密度函数">联合密度函数</h2><p><span class="math display">\[f_{XY}(x,y) = \frac{\partial^2F_{XY}}{\partial x \partial y}\]</span></p><h2 id="边缘分布">边缘分布</h2><p>边缘分布的意思就是不考虑其中一个因素，只考虑另外一个因素。</p><p><span class="math display">\[f_X(x) = \int_{-\infty}^{+\infty}f_{XY}(x,y) \, dy\]</span></p><h2 id="条件密度">条件密度</h2><p><span class="math display">\[f_{Y|X}(y|x) =\frac{f_{XY}(x,y)}{f_X(x)}\]</span></p><blockquote><p>若 <span class="math inline">\(f_{XY}(x,y) =f_X(x)f_Y(y)\)</span>，则称 <strong>独立</strong>。</p></blockquote><hr /><h2 id="二维随机变量变换jacobian">二维随机变量变换（Jacobian）</h2><p>若</p><p><span class="math display">\[Y_1 = g_1(X_1,X_2), \quad Y_2 = g_2(X_1,X_2)\]</span></p><p>则</p><p><span class="math display">\[f_{Y_1Y_2}(y_1,y_2) = f_{X_1X_2}(x_1,x_2) \cdot \left| J_g^{-1} \right|\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510211343569.png"alt="例题1.4" /><figcaption aria-hidden="true">例题1.4</figcaption></figure><hr /><h1 id="数字特征">1.4 数字特征</h1><h2 id="一维">一维</h2><table><thead><tr><th>名称</th><th>离散</th><th>连续</th></tr></thead><tbody><tr><td>期望</td><td><span class="math inline">\(E[X]=\sum x_k p_k\)</span></td><td><span class="math inline">\(E[X]=\int xf(x)dx\)</span></td></tr><tr><td>方差</td><td><span class="math inline">\(D[X]=E[X^2]-E[X]^2\)</span></td><td>同左</td></tr></tbody></table><h2 id="二维">二维</h2><ul><li><strong>协方差</strong></li></ul><p><span class="math display">\[\mathrm{cov}(X,Y) = E[XY] -E[X]E[Y]\]</span></p><ul><li><strong>相关系数</strong></li></ul><p><span class="math display">\[\rho_{XY} =\frac{\mathrm{cov}(X,Y)}{\sqrt{D[X]D[Y]}}\]</span></p><ul><li><strong>性质</strong>：<span class="math inline">\(\rho \in[-1,1]\)</span>，<span class="math inline">\(|\rho|\)</span>越大，线性相关性越强。</li></ul><hr /><h1 id="特征函数">1.5 特征函数</h1><p><span class="math display">\[\phi_X(u) = E[e^{juX}]\]</span></p><ul><li>相当于 <span class="math inline">\(f_X(x)\)</span>的傅里叶变换；</li><li>可用于推导卷积、证明极限定理；</li><li>高斯分布的特征函数仍为高斯型。</li></ul><h1 id="随机变量的数字特征">1.4 随机变量的数字特征</h1><h2 id="一维随机变量-1">一维随机变量</h2><table><thead><tr><th>名称</th><th>离散型</th><th>连续型</th></tr></thead><tbody><tr><td>期望</td><td><span class="math inline">\(E[X]=\sum x_k p_k\)</span></td><td><span class="math inline">\(E[X]=\int xf(x)dx\)</span></td></tr><tr><td>方差</td><td><span class="math inline">\(D[X]=E[X^2]-E[X]^2\)</span></td><td>同左</td></tr><tr><td><strong>原点矩</strong></td><td><span class="math inline">\(\mu_k=E[X^k]\)</span></td><td>同左</td></tr><tr><td><strong>绝对矩</strong></td><td><span class="math inline">\(\lambda_k=E[\|X\|^k]\)</span></td><td>同左</td></tr><tr><td><strong>中心矩</strong></td><td><span class="math inline">\(v_k=E[(X-E[X])^k]\)</span></td><td>同左</td></tr><tr><td><strong>标准矩</strong></td><td><spanclass="math inline">\(\tilde{v}_k=E\left[\left(\frac{X-\mu_X}{\sigma_X}\right)^k\right]=\frac{v_k}{\sigma_X^k}\)</span></td><td>同左</td></tr></tbody></table><h3 id="数字特征性质">数字特征性质</h3><ol type="1"><li><p><strong>函数期望</strong>：<spanclass="math inline">\(E[g(\xi)]=\int g(x)f(x)dx\)</span></p><ul><li><p>线性：<spanclass="math inline">\(E[a\xi+b]=aE[\xi]+b\)</span></p></li><li><p>方差：<spanclass="math inline">\(D[a\xi+b]=a^2D[\xi]\)</span></p></li></ul></li><li><p><strong>中心矩与原点矩关系</strong>：</p></li></ol><p><spanclass="math display">\[v_n=\sum_{k=0}^n(-1)^{n-k}C_n^k\mu_1^{n-k}\mu_k\]</span></p><ol start="4" type="1"><li><strong>最小方差性</strong>：<spanclass="math inline">\(E[(\xi-E[\xi])^2]\leq E[(\xi-x)^2]\)</span></li></ol><h2 id="二维随机变量">二维随机变量</h2><table><thead><tr><th>名称</th><th>离散型</th><th>连续型</th></tr></thead><tbody><tr><td><strong>联合原点矩</strong></td><td><span class="math inline">\(E[X^jY^k]=\sum\sum x_m^j y_n^kp_{m,n}\)</span></td><td><span class="math inline">\(E[X^jY^k]=\iint x^j y^kf(x,y)dxdy\)</span></td></tr><tr><td><strong>联合中心矩</strong></td><td><span class="math inline">\(E[(X-E[X])^j(Y-E[Y])^k]\)</span></td><td>同左</td></tr><tr><td><strong>相关</strong></td><td><span class="math inline">\(R_{XY}=E[XY]\)</span></td><td>同左</td></tr><tr><td><strong>协方差</strong></td><td><span class="math inline">\(K_{XY}=E[XY]-E[X]E[Y]\)</span></td><td>同左</td></tr><tr><td><strong>相关系数</strong></td><td><spanclass="math inline">\(r_{XY}=\frac{K_{XY}}{\sigma_X\sigma_Y}\)</span></td><td>同左</td></tr></tbody></table><h3 id="重要概念">重要概念</h3><ul><li><strong>协方差矩阵</strong>：</li></ul><p><span class="math display">\[\Sigma=\begin{bmatrix}K_{XX} &amp;K_{XY}\\ K_{YX} &amp; K_{YY}\end{bmatrix}\]</span></p><ul><li><strong>不相关</strong>：<span class="math inline">\(r_{XY}=0\Leftrightarrow K_{XY}=0 \Leftrightarrow E[XY]=E[X]E[Y]\)</span></li></ul><p>相互独立则不相关，<strong>反之不相关不一定相互独立</strong>，因为相关性描述的只是两个随机变量的线性相关程度，比是否真正的独立无关。独立要比不相关要强一些。<strong>但对于联合正态分布</strong>，<strong>不相关与统计独立等价</strong>。</p><ul><li><strong>正交</strong>：<spanclass="math inline">\(E[XY]=0\)</span>，若XY有一方均值为0，则XY不相关与XY正交等价。</li></ul><h3 id="线性最小均方估计">线性最小均方估计</h3><ul><li><p>最优线性估计：<spanclass="math inline">\(\hat{Y}=E[Y]+\frac{K(X,Y)}{D(X)}(X-E[X])\)</span></p></li><li><p>最小均方误差：<span class="math inline">\(\mine=(1-r_{XY}^2)D(Y)\)</span></p></li></ul><h1 id="随机变量的特征函数">1.5 随机变量的特征函数</h1><h2 id="定义-1">定义</h2><p>实际上就是fourier变换。</p><p><spanclass="math display">\[C(u)=E[e^{juX}]=\int_{-\infty}^{\infty}e^{jux}f(x)dx\]</span></p><h2 id="性质">性质</h2><ol type="1"><li><p><strong>有界性</strong>：<span class="math inline">\(|C(u)|\leqC(0)=1\)</span></p></li><li><p><strong>共轭对称</strong>：<spanclass="math inline">\(C(-u)=\overline{C(u)}\)</span></p></li><li><p><strong>线性变换</strong>：若<spanclass="math inline">\(Y=aX+b\)</span>，则<spanclass="math inline">\(C_Y(u)=e^{jub}C_X(au)\)</span></p></li><li><p><strong>矩生成</strong>：<spanclass="math inline">\(E[X^k]=j^{-k}C^{(k)}(0)\)</span></p></li><li><p><strong>独立性</strong>：若<spanclass="math inline">\(X,Y\)</span>独立，则<spanclass="math inline">\(C_{X+Y}(u)=C_X(u)C_Y(u)\)</span></p></li></ol><h2 id="高斯分布特征函数">高斯分布特征函数</h2><ul><li><span class="math inline">\(X\simN(a,\sigma^2)\)</span>的特征函数：</li></ul><p><span class="math display">\[C_X(u)=\exp\left(jau-\frac{\sigma^2u^2}{2}\right)\]</span></p><ul><li><p>高斯随机变量的线性变换仍为高斯分布</p></li><li><p>多维情况：若<span class="math inline">\(X\simN(m_X,K_X)\)</span>，则<span class="math inline">\(Y=AX+b\simN(Am_X+b,AK_XA^T)\)</span></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>随机信号分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 模拟调制系统</title>
    <link href="/2025/10/20/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/10/20/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="调制modulation的定义与目的">调制(Modulation)的定义与目的</h2><p>把消息信号 <span class="math inline">\(m(t)\)</span>寄托在载波（<span class="math inline">\(\cos(\omega_ct)\)</span>）的某个参数上，形成已调信号。</p><h3 id="目的">目的</h3><ol type="1"><li><p>提高天线辐射效率：就是实现频谱的搬移。低频信号波长长，需要巨大天线；高频信号波长短，天线尺寸合理。</p></li><li><p>实现频谱资源共享：不同信号占据不同频段（频分复用FDM），实现多路通信。</p></li><li><p>提高系统抗干扰能力：非线性调制（如FM）可改善信噪比。</p></li></ol><h2 id="载波信号">载波信号</h2><p>本书中主要讲正弦波调制，脉冲调制暂时先不讲，后面可能有。</p><p>载波信号通常表示为：</p><p><span class="math display">\[c(t) = A_c \cos(\omega_c t + \phi_c)\]</span></p><p>其中 <span class="math inline">\(A_c\)</span> 为载波振幅，<spanclass="math inline">\(\omega_c\)</span> 为载波角频率，<spanclass="math inline">\(\phi_c\)</span> 为载波初始相位。调制即让 <spanclass="math inline">\(A_c\)</span>、<spanclass="math inline">\(\omega_c\)</span> 或 <spanclass="math inline">\(\phi_c\)</span> 随基带信号 <spanclass="math inline">\(m(t)\)</span> 变化。</p><h2 id="模拟调制分类">模拟调制分类</h2><ol type="1"><li><p><strong>幅度调制 (Amplitude Modulation, AM)</strong>：载波振幅随变化。即线性调制。</p><ul><li>DSB（双边带）</li><li>AM（普通调幅）</li><li>SSB（单边带）</li><li>VSB（残留边带）</li></ul></li><li><p><strong>角度调制 (Angle Modulation,PM/FM)</strong>：载波相位或频率随 <spanclass="math inline">\(m(t)\)</span> 变化。</p><ul><li>FM（频率调制）</li><li>PM（相位调制）</li></ul></li></ol><h1 id="线性调制系统幅度调制">线性调制系统（幅度调制）</h1><p>线性调制是将基带信号 <span class="math inline">\(m(t)\)</span>线性地作用于载波振幅。调制信号的时域表示为：</p><p><span class="math display">\[s_{AM}(t) = A(t) \cos(\omega_c t)\]</span></p><p>幅度调制器的一般模型为：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200008962.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>其分类就是根据这个 <span class="math inline">\(m(t)\)</span> <spanclass="math inline">\(h(t)\)</span> 不同来分的。</p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200010466.png"alt="image.png" /> ## 普通调幅 (AM)</p><h3 id="时域表达式">时域表达式</h3><p>AM 信号在 DSB 基础上增加了<strong>载波分量</strong>：</p><p><span class="math display">\[s_{AM}(t) = [A_0 + m(t)] \cos(\omega_c t)\]</span></p><p>其中 <span class="math inline">\(A_0\)</span> 为直流偏置，必须满足<span class="math inline">\(A_0 &gt; |m(t)|_{max}\)</span>，以保证 <spanclass="math inline">\([A_0 + m(t)] &gt; 0\)</span>（不发生过调幅）。</p><h3 id="调制指数-mu">调制指数 (<spanclass="math inline">\(\mu\)</span>)</h3><p><span class="math display">\[\mu = \frac{|m(t)|_{max}}{A_0} \le 1\]</span></p><p>大于一为过调制，会导致失真、信息丢失。</p><h3 id="功率和效率">功率和效率</h3><p>AM 信号的总功率 <span class="math inline">\(P_{AM} = P_c +P_{SB}\)</span>。边带功率 <span class="math inline">\(P_{SB}\)</span>承载信息，而载波功率 <span class="math inline">\(P_c\)</span>不承载信息。</p><ul><li><strong>效率</strong>：<span class="math inline">\(\eta =\frac{P_{SB}}{P_c + P_{SB}}\)</span>，AM的效率通常很低，毕竟要满足调制系数不能大于1，他的载波功率是要比边带功率大的。</li></ul><h3 id="解调方法">解调方法</h3><p>可直接非相干解调 (Non-coherent Demodulation)，使用<strong>包络检波器(EnvelopeDetector)</strong>，就一个二极管一个电容的事儿，电路简单，无需同步载波。</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200022754.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>相干解调也可以，相对复杂，但是载波给了，还比较容易相干解调，记得解调完还需要去掉直流</p><h2 id="双边带抑制载波-dsb-sc">双边带抑制载波 (DSB-SC)</h2><h3 id="时域表达式-1">时域表达式</h3><p>无载波分量</p><p><span class="math display">\[s_{DSB}(t) = m(t) \cos(\omega_c t)\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200028435.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>注意，这个载波和输入信号同时改变极性的时候会出现反向点。</p><h3 id="频域特性">频域特性</h3><p>DSB 信号的频谱是基带信号 <spanclass="math inline">\(M(\omega)\)</span> 频谱的左右平移：</p><p><span class="math display">\[S_{DSB}(\omega) = \frac{1}{2} [M(\omega - \omega_c) + M(\omega +\omega_c)]\]</span></p><ul><li><strong>带宽</strong>：<span class="math inline">\(B_{DSB} =2f_H\)</span> (其中 <span class="math inline">\(f_H\)</span>为基带信号的最高频率)。</li><li>无载波分量。</li><li>幅值变为一半。</li></ul><h3 id="解调方法-1">解调方法</h3><p>关于相关解调和非相关解调之间的区别：</p><p>(1)相干解调信噪比可低于0dB；</p><p>(2)非相干解调信噪比需大于10dB ；</p><p>(3)相干解调的信噪比性能优于非相干解调，而非相干解调对移动、大动态信噪比环境下的适应性更好。</p><p>首先介绍相干解调：</p><p>接收端需要一个与载波同频同相的本地载波 <spanclass="math inline">\(\cos(\omega_c t)\)</span>：</p><p>他传来的信号里面没有载波分量，就需要我们揪出来一个。什么时候才能出<strong>频域分量</strong>？非线性变化。于是引入相乘：</p><ol type="1"><li><strong>相乘</strong>：</li></ol><p><span class="math display">\[r(t) = s_{DSB}(t) \cdot 2\cos(\omega_ct) = m(t) \cos^2(\omega_c t) = m(t) [1 + \cos(2\omega_c t)]\]</span></p><p><span class="math display">\[r(t) = m(t) + m(t) \cos(2\omega_c t)\]</span></p><ol start="2" type="1"><li><strong>低通滤波 (LPF)</strong>：滤除高频项 <spanclass="math inline">\(m(t) \cos(2\omega_c t)\)</span>，得到 <spanclass="math inline">\(m(t)\)</span>。实际上就是再给相干的分量乘进去，再滤除掉这个高频部分。</li></ol><p>非相干上面讲过了，不再说。</p><h2 id="单边带调制-ssb">单边带调制 (SSB)</h2><h3 id="频谱特性">频谱特性</h3><p>SSB 只保留上边带 (USB) 或下边带 (LSB)中的一个，极大地节省了带宽，并提高了功率效率。</p><p>但是由于理想滤波器不存在，频域法（LPF）做SSB很复杂，效果也就那样，当然也可以用相位法来进行抵消，也很复杂。</p><p>普通调幅接收机不能接受SSB信号，因为普通的只能做包络检波，不能做相干。</p><ul><li><strong>带宽</strong>：<span class="math inline">\(B_{SSB} =f_H\)</span>。</li></ul><h3 id="时域表达式-2">时域表达式</h3><p><span class="math display">\[s_{SSB}(t) = m(t) \cos(\omega_c t) \mp \hat{m}(t) \sin(\omega_c t)\]</span></p><p>其中 <span class="math inline">\(\hat{m}(t)\)</span> 是 <spanclass="math inline">\(m(t)\)</span>的<strong>希尔伯特变换</strong>。希尔伯特变换就是正余弦相移一个二分之pi。－可以看作上边带信号，+为下边带信号。</p><h3 id="解调方法相干解调">解调方法：相干解调</h3><p>SSB 只能使用相干解调。（这个是为什么？）</p><h2 id="残留边带调制-vsb">残留边带调制 (VSB)</h2><h3 id="频谱特性-1">频谱特性</h3><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200048283.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>满足这个滤波器的截止特性在在载频处具有互补对称的条件就可以。</p><p>VSB保留了一个完整的边带，以及另一边带的<strong>部分</strong>（残留边带）。是介于DSB 和 SSB 之间的一种折中方案。</p><ul><li><strong>带宽</strong>：<span class="math inline">\(f_H &lt; B_{VSB}&lt; 2f_H\)</span>。 ### 优势</li></ul><p>VSB 解决了 SSB难以实现的滤波器问题，并保留了低频分量，适用于传输带有丰富低频分量（如直流分量）的信号，例如电视信号。</p><h3 id="解调方法相干解调-1">解调方法：相干解调</h3><h1 id="角度调制系统非线性调制">角度调制系统（非线性调制）</h1><p>这个我们不考，所以就只讲一点。基本上知道FMPM是啥，知道他们是非线性调制，出现了很多频域分量，带宽变大，出来的信号质量更好就行了。</p><p>角度调制是非线性调制，载波的<strong>瞬时相位</strong>或<strong>瞬时频率</strong>随基带信号<span class="math inline">\(m(t)\)</span> 变化。</p><h2 id="调频-frequency-modulation-fm">调频 (Frequency Modulation,FM)</h2><h3 id="瞬时频率">瞬时频率</h3><p>载波的瞬时频率 <span class="math inline">\(\omega_i(t)\)</span> 随<span class="math inline">\(m(t)\)</span> 线性变化： <spanclass="math display">\[\omega_i(t) = \omega_c + k_f m(t)\]</span> 其中 <span class="math inline">\(k_f\)</span>为<strong>调频系数</strong>，单位为 <spanclass="math inline">\(\text{rad/s/V}\)</span>。 ### 时域表达式 <spanclass="math display">\[s_{FM}(t) = A_c \cos[\omega_c t + \phi(t)]\]</span> 瞬时相位 <span class="math inline">\(\phi(t)\)</span>是瞬时频率对时间的积分： <span class="math display">\[\phi(t) = \int^t \omega_i(\tau) d\tau = \omega_c t + k_f \int^t m(\tau)d\tau\]</span> <strong>FM 信号</strong>： <span class="math display">\[s_{FM}(t) = A_c \cos[\omega_c t + k_f \int^t m(\tau) d\tau]\]</span></p><h3 id="调制指数-beta">调制指数 (<spanclass="math inline">\(\beta\)</span>)</h3><p>对于单音调制 <span class="math inline">\(m(t) = A_m \cos(\omega_mt)\)</span>，FM 信号的<strong>调制指数</strong>为： <spanclass="math display">\[\beta = \frac{\Delta \omega}{\omega_m} = \frac{k_f A_m}{\omega_m}\]</span> 其中 <span class="math inline">\(\Delta \omega = k_fA_m\)</span> 为<strong>最大角频偏</strong>。</p><h3 id="带宽卡森公式">带宽（卡森公式）</h3><p>FM 信号的频谱是无限宽的，但能量主要集中在有限带宽内。<strong>卡森(Carson) 公式</strong>用于估算有效带宽： <span class="math display">\[B_{FM} \approx 2(\Delta f + f_m) = 2(\beta + 1) f_m\]</span> 其中 <span class="math inline">\(\Delta f\)</span>为最大频偏（赫兹）。</p><h3 id="解调方法-2">解调方法</h3><p>FM 信号通常采用<strong>鉴频器 (Frequency Discriminator)</strong>来解调，它将频率变化转换为幅度变化，再进行包络检波或低通滤波。</p><h2 id="调相-phase-modulation-pm">调相 (Phase Modulation, PM)</h2><h3 id="瞬时相位">瞬时相位</h3><p>载波的瞬时相位 <span class="math inline">\(\theta_i(t)\)</span> 随<span class="math inline">\(m(t)\)</span> 线性变化： <spanclass="math display">\[\theta_i(t) = \omega_c t + k_p m(t)\]</span> 其中 <span class="math inline">\(k_p\)</span>为<strong>调相系数</strong>。 ### 时域表达式 <spanclass="math display">\[s_{PM}(t) = A_c \cos[\omega_c t + k_p m(t)]\]</span></p><h3 id="fm-与-pm-的关系">FM 与 PM 的关系</h3><ul><li>对 <span class="math inline">\(m(t)\)</span>进行<strong>积分</strong>后对载波进行 <strong>FM 调制</strong>，得到 PM信号。</li><li>对 <span class="math inline">\(m(t)\)</span>进行<strong>微分</strong>后对载波进行 <strong>PM 调制</strong>，得到 FM信号。</li></ul><h2 id="模拟调制系统的抗噪声性能">模拟调制系统的抗噪声性能</h2><p>通信系统的抗噪声性能通常由<strong>解调器</strong>的抗噪声性能来衡量。在信道加性高斯白噪声的背景下，研究各种调制系统的性能。</p><h3 id="性能分析模型与指标">性能分析模型与指标</h3><h3 id="接收机模型">接收机模型</h3><p>已调信号 <span class="math inline">\(s_m(t)\)</span>与信道加性高斯白噪声 <span class="math inline">\(n(t)\)</span>混合后，先经过带通滤波器 (BPF)滤除信号频带外的噪声，输入到解调器的信号为 <spanclass="math inline">\(s_m(t)\)</span>，噪声为 <spanclass="math inline">\(n_i(t)\)</span>。解调器输出的有用信号为 <spanclass="math inline">\(m_o(t)\)</span>，噪声为 <spanclass="math inline">\(n_o(t)\)</span>。</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200108778.png"alt="信号加上高斯白噪声之后，过带通滤波器后对解调器上输入信号分析" /><figcaptionaria-hidden="true">信号加上高斯白噪声之后，过带通滤波器后对解调器上输入信号分析</figcaption></figure><h3 id="输入端噪声特性">输入端噪声特性</h3><p>输入解调器的噪声 <span class="math inline">\(n_i(t)\)</span>是由平稳高斯白噪声 <span class="math inline">\(n(t)\)</span>经过带通滤波器得到的，可视为<strong>平稳窄带高斯噪声</strong>。</p><p>窄带高斯噪声可以表示为：</p><p><span class="math display">\[n_{i}(t)=n_{c}(t)\cos\omega_{c}t-n_{s}(t)\sin\omega_{c}t\]</span></p><p>其中 <span class="math inline">\(n_c(t)\)</span> 和 <spanclass="math inline">\(n_s(t)\)</span> 分别是同相分量和正交分量，均值都为<span class="math inline">\(0\)</span>，且具有相同的方差。</p><ul><li><p><strong>输入噪声功率</strong>：若白噪声单边功率谱密度为 <spanclass="math inline">\(N_0\)</span>，BPF 带宽为 <spanclass="math inline">\(B\)</span> (等于已调信号带宽 <spanclass="math inline">\(W\)</span>)：</p><p><span class="math display">\[  N_{i}=\overline{n_{i}^{2}(t)}=N_{0}B  \]</span></p></li></ul><h3 id="质量指标">质量指标</h3><ol type="1"><li><p><strong>输出信噪比 (OutputSNR)</strong>：衡量解调器输出的质量。</p><p><span class="math display">\[\frac{S_{o}}{N_{o}}=\frac{\overline{m_{o}^{2}(t)}}{\overline{n_{o}^{2}(t)}}\]</span></p></li><li><p><strong>输入信噪比 (Input SNR)</strong>：</p><p><span class="math display">\[\frac{S_{i}}{N_{i}}=\frac{\overline{s_{m}^{2}(t)}}{\overline{n_{i}^{2}(t)}}\]</span></p></li><li><p><strong>调制制度增益(Gain)</strong>：用于比较同类调制系统的性能。</p><p><span class="math display">\[G=\frac{S_{o}/N_{o}}{S_{i}/N_{i}}\]</span></p></li></ol><h2 id="线性调制系统性能推导">线性调制系统性能推导</h2><h3 id="dsb-sc-调制系统-相干解调">1. DSB-SC 调制系统 (相干解调)</h3><ul><li><p><strong>输入信号功率</strong>：<span class="math inline">\(S_{i}= \overline{s_{DSB}^{2}(t)} =\frac{1}{2}\overline{m^{2}(t)}\)</span>。</p></li><li><p><strong>输出信号</strong>：<spanclass="math inline">\(m_{o}(t)=\frac{1}{2}m(t)\)</span>。</p></li><li><p><strong>输出信号功率</strong>：<span class="math inline">\(S_{o}= \overline{m_{o}^{2}(t)} =\frac{1}{4}\overline{m^{2}(t)}\)</span>。</p></li><li><p><strong>输出噪声功率</strong>：<span class="math inline">\(N_{o}= \frac{1}{4}\overline{n_{i}^{2}(t)} =\frac{1}{4}N_{0}B\)</span>。</p></li><li><p><strong>调制制度增益</strong>：<spanclass="math inline">\(G_{DSB} = 2\)</span>。</p></li></ul><h3 id="ssb-sc-调制系统-相干解调">2. SSB-SC 调制系统 (相干解调)</h3><ul><li><p><strong>带宽</strong>：<span class="math inline">\(B=W\)</span>(基带信号带宽)。</p></li><li><p><strong>输出信号功率</strong>：<spanclass="math inline">\(S_{o}=\overline{m_{o}^{2}(t)}=\frac{1}{16}\overline{m^{2}(t)}\)</span>。</p></li><li><p><strong>输出噪声功率</strong>：<span class="math inline">\(N_{o}= \frac{1}{4}N_{0}W\)</span>。</p></li><li><p><strong>调制制度增益</strong>：<spanclass="math inline">\(G_{SSB} = 1\)</span>。</p></li></ul><h3 id="dsb-与-ssb-性能比较">3. DSB 与 SSB 性能比较</h3><p>虽然 <span class="math inline">\(G_{DSB}=2\)</span> 且 <spanclass="math inline">\(G_{SSB}=1\)</span>，但这并不直接说明 DSB性能更好。因为两者输入信号功率和带宽不同。</p><p><strong>结论</strong>：在相同的输入信号功率 <spanclass="math inline">\(S_i\)</span>、相同的噪声功率谱密度 <spanclass="math inline">\(N_0\)</span>、相同的基带信号带宽 <spanclass="math inline">\(W\)</span> 条件下，DSB 和 SSB的<strong>输出信噪比相等</strong>，表明两者的<strong>抗噪声性能是相同的</strong>。</p><h3 id="am-包络检波的性能">4. AM 包络检波的性能</h3><ul><li><p><strong>大信噪比情况</strong>：包络检波的性能与相干解调相同。</p></li><li><p><strong>小信噪比情况</strong>：出现<strong>门限效应</strong>。在小信噪比下，包络检波器会把有用信号扰乱成噪声，输出信噪比急剧恶化。</p></li></ul><h1 id="各种模拟调制系统的性能比较">各种模拟调制系统的性能比较</h1><table><thead><tr><th style="text-align: center;">调制方式</th><th style="text-align: center;">传输带宽</th><th style="text-align: center;">直流响应</th><th style="text-align: center;">设备复杂性</th><th style="text-align: center;">主要应用</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>DSB</strong></td><td style="text-align: center;"><spanclass="math inline">\(2f_H\)</span> (无)</td><td style="text-align: center;"><strong>无</strong></td><td style="text-align: center;">中等：要求相干解调</td><td style="text-align: center;">模拟数据传输</td></tr><tr><td style="text-align: center;"><strong>AM</strong></td><td style="text-align: center;"><spanclass="math inline">\(2f_H\)</span> (有)</td><td style="text-align: center;"><strong>有</strong></td><td style="text-align: center;">较小：调制与解调简单</td><td style="text-align: center;">无线电广播</td></tr><tr><td style="text-align: center;"><strong>SSB</strong></td><td style="text-align: center;"><span class="math inline">\(f_H\)</span>(无)</td><td style="text-align: center;"><strong>无</strong></td><td style="text-align: center;">较大：要求相干解调，调制器也较复杂</td><td style="text-align: center;">话音通信，话音频分多路通信</td></tr><tr><td style="text-align: center;"><strong>VSB</strong></td><td style="text-align: center;"><span class="math inline">\(f_H &lt; B&lt; 2f_H\)</span> (有)</td><td style="text-align: center;"><strong>有</strong></td><tdstyle="text-align: center;">较大：要求相干解调，调制器需要对称滤波</td><td style="text-align: center;">数据传输，宽带(电视)系统</td></tr><tr><td style="text-align: center;"><strong>FM</strong></td><td style="text-align: center;"><span class="math inline">\(2(\Delta f +f_m)\)</span> (有)</td><td style="text-align: center;"><strong>有</strong></td><td style="text-align: center;">中等：调制器有点复杂，解调器较简单</td><td style="text-align: center;">数据传输，无线电广播，微波中继</td></tr></tbody></table><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510200112067.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="主要结论">主要结论</h3><ol type="1"><li><p><strong>抗噪声性能</strong>：<strong>WBFM</strong> (宽带调频)<strong>最好</strong>；DSB、SSB、VSB 次之；<strong>AM最差</strong>。当输入信噪比较高时，FM 的调频指数 <spanclass="math inline">\(\beta\)</span> 越大，抗噪声性能越好。</p></li><li><p><strong>频带利用率</strong>：<strong>SSB的带宽最窄</strong>，<spanclass="math inline">\(B_{SSB}=f_H\)</span>，频带利用率最高。<strong>FM占用带宽最大</strong>，随调频指数 <spanclass="math inline">\(\beta\)</span>增大而增大，频带利用率最低。</p></li><li><p><strong>权衡</strong>：FM是以<strong>牺牲有效性</strong>（带宽）来换取<strong>可靠性</strong>（抗噪声性能）的典型代表。</p></li></ol><h1 id="频分复用-fdm">频分复用 (FDM)</h1><h2 id="概念与目的">概念与目的</h2><p><strong>复用(Multiplexing)</strong>：解决如何利用一条物理信道同时传输多路信号的技术。目的是为了充分利用信道的频带、时间、空间资源，提高信道的利用率。</p><p><strong>频分复用(FDM)</strong>：是一种<strong>按频率来划分信道</strong>的复用方式。</p><h2 id="fdm-原理与实现">FDM 原理与实现</h2><ol type="1"><li><p><strong>划分频段</strong>：将信道的总带宽划分为多个<strong>相互不重叠</strong>的频段（子通道），每路信号占据其中一个子通道。</p></li><li><p><strong>保护频带</strong>：各路信号之间留有未被使用的频带（<strong>保护频带</strong>）进行分隔，以防止信号重叠和路间干扰。</p></li><li><p><strong>发送端</strong>：每路基带信号 <spanclass="math inline">\(m_i(t)\)</span> 先经过低通滤波(LPF)，然后与不同的载波 <spanclass="math inline">\(\omega_{c_i}\)</span>相乘（调制），再经过边带滤波器 (<spanclass="math inline">\(\text{SBF}_i\)</span>)选出所需的边带，最后通过相加器将多路已调信号合路并送入信道。</p></li><li><p><strong>接收端</strong>：接收到的合路信号经过带通滤波器 (<spanclass="math inline">\(\text{BPF}_i\)</span>)分离出对应的子通道信号，再与同频载波 <spanclass="math inline">\(\omega_{c_i}\)</span> 相乘（解调），最后经过 LPF即可恢复出原始基带信号 <spanclass="math inline">\(m_i(t)\)</span>。</p></li></ol><h2 id="fdm-优缺点">FDM 优缺点</h2><p><strong>优点</strong>：</p><ol type="1"><li><p>信道复用率高。</p></li><li><p>允许复用的路数多。</p></li><li><p>分路（分频）方便。</p></li></ol><p><strong>缺点</strong>：</p><ol type="1"><li><p>设备生产较为复杂。</p></li><li><p>滤波器特性不理想和信道内存在非线性会产生<strong>路间干扰</strong>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 信道</title>
    <link href="/2025/10/19/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%BF%A1%E9%81%93/"/>
    <url>/2025/10/19/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%BF%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="信道定义">信道定义</h1><p>信道即信号的通道，在通信系统里面必不可少。</p><h2 id="狭义信道">狭义信道</h2><p>即指信号的传输媒质，在发送器和接收器之间的物理通路</p><ul><li>导向：光纤、双绞线、同轴电缆</li><li>非导向：无线电、红外线</li></ul><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192027955.png"alt="image.png" /> ## 广义信道</p><p>就是一些给通信系统其他的一些设备等效进去的信道：</p><ul><li>调制信道：从调制器输出端到解调器输入端，他涉及到的是已调信号</li><li>编码信号：从编码器输出端到译码器输入端，他涉及到的是数字序列</li></ul><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192029053.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="调制信道模型">调制信道模型</h3><p>传输已调信号，关心的是信号的失真情况及噪声对信号的影响。已调信号的瞬时值是连续变化的，故也称为连续信道，甚至称为信道</p><p>他的一些特性，我是感觉不是很重要，这个应该是放在常识认知里面，就不在这里讲述。</p><p>注意书上写绝大多数调制信道都是线性的，是目前阶段由于我们水平不够欧所做的近似罢了。</p><p>他的数学模型如下：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192043723.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="编码信道模型">编码信道模型</h3><p>也叫数字信道，他包含调制信道，依赖调制信道的性能，其干扰也体现在误码上，主要关系的是误码率。</p><p>根据前后码元的转移概率是否有依赖可以进一步氛围有记忆编码信道和无记忆编码信道。</p><h1 id="性能参数">性能参数</h1><p>影响通信系统可靠性主要有俩因素：噪声和信道传输特性的不理想。</p><h1 id="恒参信道特性">恒参信道特性</h1><h2 id="举例">举例</h2><h4 id="双绞线">双绞线</h4><p>既可用于模拟传输，也可用于数据传输，带宽依赖于线的粗细和传输距离</p><p>分无屏蔽双绞线(UTP)与屏蔽双绞线(STP): 以箔屏蔽来减少干扰</p><h4 id="同轴电缆">同轴电缆</h4><p>基带同轴电缆：50 <span class="math inline">\(\Omega\)</span>，为数据通信传输基带数字信号，局域网中广泛使用 10Mb/s, 1km</p><p>宽带同轴电缆：75 <span class="math inline">\(\Omega\)</span>，多用于CATV系统，传送频分复用的模拟信号 6MHz/300~400MHz，100km</p><h4 id="光纤">光纤</h4><p>双层通信圆柱体，依靠光波承载信息，传输速率高，带宽大，损耗小，抗干扰保密性好，轻便，但是需要前后有光调制器和光探测器，相对来说复杂一些，对接也比较麻烦，比较脆弱，踩一脚就没了。</p><p>常用的三个波长窗口：</p><p>0.85um：衰减（attenuation)大，传输速率和距离受限制，但价格便宜；</p><p>1.30um：衰减小，无色散（dispersion）补偿、功率放大情况下，最大传40km（最坏情况）；</p><p>1.55um：衰减小，无色散补偿、功率放大情况下，最大传80km（最坏情况）</p><h4 id="无线电视距中继">无线电视距中继</h4><p>两个地面站之间传送(点到点)</p><p>距离：50-100 km；频率：2G-40GHz</p><p>依赖于天气和频率</p><p>应用：长距离传输话音和电视信号；大厦之间LAN互连</p><h4 id="通信卫星中继信道">通信卫星中继信道</h4><p>真几把越来越离谱了，你跟我说这几把是恒参？骗鬼呢？</p><p>使用微波</p><p>使用转发器接收和转发</p><p>优点：传输距离远，覆盖地域广，传输稳定可靠，传输容量大</p><p>应用：传输电视信号、远距离话音传输、组建专用网</p><p>可支持点到多点传送</p><p>C波段 4/6 GHz</p><pre><code class="hljs">上行5.925 - 6.425 GHz下行3.7 - 4.2 GHz </code></pre><p>KU波段 12/14 GHz</p><pre><code class="hljs">上行14 - 14.5 GHz 下行11.7 - 12.2 GHz</code></pre><h2 id="特性">特性</h2><p>恒参信道就是信道特征不随时间变化，具体而言：</p><p><span class="math display">\[ h(t) \Leftrightarrow H(\omega) =|H(\omega)| e^{j\varphi(\omega)} \]</span></p><p>幅频特性 <span class="math inline">\(|H(\omega)|\)</span></p><p>相频特性 <span class="math inline">\(\varphi(\omega)\)</span></p><p>群时延特性 <span class="math inline">\(\tau(\omega) =-\frac{d\varphi(\omega)}{d\omega}\)</span></p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192108615.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="随参信道特性">随参信道特性</h1><h2 id="举例-1">举例</h2><h3 id="短波电离层反射信道">短波电离层反射信道</h3><p>哦吼这个确实比前面几个随参多了。</p><p>电离层：离地面高60~600km的大气层，从地面算起，从下而上可分为五层：对流层、平流层、中间层、电离层和散逸层。媒质的折射率随高度增加而减小，电波传播时轨道逐步弯曲，在某一高度产生全反射</p><p>短波：3<sub>30MHz(100</sub>10m)</p><p>传输无盲区，设备简单，灵活，例如南极科考，采用的通信手段就是他。不过，电离层反射的只是普通的无线电广播采用的波段，对于波长较短的无线电波则起不到反射作用。电视机采用的恰恰是波长较短的无线电波，这就是电视机为什么收看不到远处电视台节目的原因。</p><p>传输可靠性差，需经常更换工作频率</p><p>短波广播，应急通信，抗灾通信，军事通信</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192118898.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>短波通信之所以能吸引用户，最基本的原因是由于进行远距离通信时，仅需要不大的发射功率和适中的设备费用，它还具有不易"摧毁"的"中继系统"-电离层。实践证明，采用现代技术改造过的短波通信能为用户提供高质量、高可通率和价格适中的通信线路。当然，短波通信也存在一些不足，主要表现在以下两方面：</p><p>1．不能和高频媒体本身存在的弱点相匹配；</p><p>2．无法抵御窃听和各种有意的干扰。</p><p>他还可以进行多径传播：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192121670.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="对流层散射信道">对流层散射信道</h3><p>对流层：离地面10~12km以下的大气层</p><p>超短波和微波波段</p><p>抗毁性好，保密性强，机动性好，适应复杂地形能力强</p><p>点到点通信：军用，海岛与陆地之间，应急救灾通信等</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192123190.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="其他">其他</h3><p>短波电离层反射，超短波流星余迹散射，超短波及微波对流层散射，短波电离层散射、超短波超视距绕射</p><h2 id="特性-1">特性</h2><p>从对信号传输的影响来看，传输媒质的影响是主要的，而转换器的影响是次要的，甚至可忽略不计，因此，主要研究传输媒质的共性及其对信号传输的影响。</p><h4 id="随参信道特性-1">随参信道特性</h4><p>多径传输且每条路径的衰减及时延都是随机变化的，对信号的衰减随时间而变化，对传输的时延随时间而变化</p><p>用数学语言来描述：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192141047.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>我们可以发现，这个R(X)可视为窄带随机过程：多径使确定的单频载波信号变成包络和相位都受调制的窄带信号（衰落信号）。</p><p>从时域来看，多径时延扩散； 从频域来看，频率弥散/展宽。</p><h4 id="统计特性">统计特性</h4><p>当 <span class="math inline">\(n\)</span> 足够大时， <spanclass="math inline">\(X_c(t)\)</span>、<spanclass="math inline">\(X_s(t)\)</span> 是平稳高斯过程，故 <spanclass="math inline">\(R(t)\)</span> 是窄带高斯过程。</p><p><span class="math inline">\(V(t)\)</span>的一维分布服从<strong>瑞利分布</strong>（瑞利型衰落）：</p><p><span class="math display">\[f(V) =\frac{V}{\sigma^2}\exp\left(-\frac{V^2}{2\sigma^2}\right), \quad V \geq0, \sigma &gt; 0\]</span></p><p><span class="math inline">\(\varphi(t)\)</span>的一维分布服从<strong>均匀分布</strong>：</p><p><span class="math display">\[f(\varphi) = \frac{1}{2\pi}, \quad -\pi\leq \varphi \leq \pi \]</span></p><h4 id="频率选择性衰落"><strong>频率选择性衰落</strong></h4><p>这是一种信号频谱中某些分量的衰落现象，信号不同频率分量经多径到达后的相位不同。相位相同的分量矢量相加后增强；相位相反的分量相互抵消，导致接收信号不同频率分量幅度变化，类似通过衰减选择性网络，故称频率选择性衰落。</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510192149354.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h4 id="相关带宽与衰落类型">相关带宽与衰落类型</h4><p>多径传播的频率选择性衰落依赖<strong>相对时延差</strong>，用最大多径时延差<span class="math inline">\(\tau_m\)</span> 表征</p><p>定义相关带宽：</p><p><span class="math display">\[\Delta f =\frac{1}{\tau_m}  \]</span></p><p>当信号带宽 <span class="math inline">\(B &gt; \Delta f\)</span> 时，<span class="math inline">\(R(t)\)</span>波形有畸变，产生<strong>频率选择性衰落</strong>；</p><p>当信号带宽 <span class="math inline">\(B &lt;&lt; \Delta f\)</span>时， <span class="math inline">\(R(t)\)</span> 时强时弱（与 <spanclass="math inline">\(\tau\)</span>有关），属于<strong>平坦性衰落</strong>（一般性衰落）；</p><p>为避免明显频率选择性衰落， <span class="math inline">\(B\)</span>应小于 <span class="math inline">\(\Delta f\)</span>，且可采用分集接收等技术稳定信号。</p><p>（我说实在，这里还是有点看不太懂）</p><h2 id="改善">改善</h2><h3 id="分集">分集</h3><h4 id="概念">概念</h4><p>分集接收就是为了克服各种衰落，提高系统性能而发展起来的移动通信中的一项重要技术。</p><p>分集接收基本思路：将接收到的多径信号分离成不相关的(独立的)多路信号，然后将这些信号的能量按一定规则合并起来，使接收的有用信号能量最大</p><p>对数字系统而言，使接收端的误码率最小对模拟系统而言，提高接收端的信噪比</p><h4 id="分集方式">分集方式</h4><p>时间分集：采用时间交织与信道编码，在时间域内提供信号的副本</p><p>频率分集：在不同的载波频率上发送符号，在频率域内提供信号的副本</p><p>空间分集：利用多副天线实现</p><h3 id="合并">合并</h3><p>最佳选择式合并：选择信噪比最好的一路信号，当然，后期会趋近于一个值</p><p>等增益合并：各支路信号以相同的增益直接相加</p><p>最大比合并：各支路增益与本支路信噪比成正比</p>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 随机信号分析</title>
    <link href="/2025/10/19/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/"/>
    <url>/2025/10/19/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>随机信号分析实际上是我们另外的一门课，这里就简单讲一下相当于是，也就给了个大纲，老师也没指望我们听懂。</p><h1 id="随机过程概念">随机过程概念</h1><h2 id="什么是随机过程">什么是随机过程</h2><p>通信过程中的随机信号一点是不可预知的，具有随机性，是随机信号，但是有统计规律。因此我们需要把他用随机过程这一数学概念进行描述。她不是确定的。</p><p>随机过程就是不同随机试验结果的时间过程的集合。用另外一种方式理解就是他是一个时间函数，但是每片时间的取值都是都是不确定的，是随机变量。</p><p>样本函数就是随机过程的具体实现，样本空间则为所有实现构成的全体。所有样本函数及其统计特性构成了随机过程。</p><p>随机过程就是随机变量概念的延伸，加了个时间变量而已。</p><h2 id="随机过程的一般表述">随机过程的一般表述</h2><p>和其他的大多数处理方法一样，这个也是从一个片段到多个，从一处的特征出发到多处之间的联系。</p><h3 id="分布函数与概率密度">分布函数与概率密度</h3><h4 id="一维">一维</h4><p>随机过程可以用分布函数和概率密度来表征，具体的思想是：</p><p>随机过程在任意时刻上是一个随机变量，拿这个时刻的切片来看，把这个切片里的各种概率当成一个独立的分布，就能求出该时刻的一维分布函数与一维概率密度。</p><p>公式如下：</p><p><span class="math display">\[F_1(x_1, t_1) = P\left\{ \xi(t_1) \leqx_1 \right\}\]</span></p><p><span class="math display">\[f_1(x_1, t_1) = \frac{\partial F_1(x_1,t_1)}{\partial x_1}\]</span></p><p>注意这个里面的 <span class="math inline">\(t_1\)</span>是定值即可，在这个一维分布函数和概率密度里面。</p><h4 id="n维">n维</h4><p>一维分布函数或概率密度函数仅描述了随机过程在任一瞬间的统计特性，进而可以对任意固定的n个时刻进行概率分布与概率密度的描述。n越大，对随机过程统计特性的描述就越充分，也会更复杂。</p><p><span class="math display">\[F_1(x_1, x_2; t_1,t_2) = P\left\{\xi(t_1) \leq x_1,\xi(t_2) \leq x_2 \right\}\]</span></p><p>记得随机信号分析里面好像到二阶就可以了，一般来说我们这些做通信的就不需要这么精确，随机过程的数字特征就够用了。</p><h2 id="随机过程的数字特征">随机过程的数字特征</h2><h3 id="均值或者数学期望">均值或者数学期望</h3><p>随机过程中就是对每个时间片段中求一下这个均值，均值是时间的函数，注意这个是个确定函数。具体求法就不讲了。</p><h3 id="方差">方差</h3><p>略。</p><p>注意均值方差都只与一维概率密度函数有关系，他们反映了随机过程中各时刻的特征。</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191745064.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="相关函数">相关函数</h3><p>相关函数是随机过程中的内在联系，即随机过程中任意时刻上的两个随机变量之间的内在联系。</p><h4 id="自相关函数">自相关函数</h4><p><span class="math display">\[R(t_1, t_2) = E\left[ \xi(t_1)\xi(t_2)\right] = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} x_1 x_2f_2(x_1, x_2; t_1, t_2) dx_1 dx_2\]</span></p><p>反映不同时刻随机过程取值的相关性（很模棱两可的一句话），常用于时序信号的周期性或平稳性分析，下面是这个公式如何推导出来的一个思路：</p><p>我们来想，两个数据的集合相乘之后再相加，最终的结果可能是什么样的？</p><p>是不是如果两个集合都是符号随机的话，平均乘积就可以接近0；二者在符号上只要有关系，那么相乘相加的结果就会变成向0两边偏离。</p><p>于是我们就给这个相乘后相加的操作和我们的这个随机过程的分析对应出来，这个是不是就是均值相乘？这个就能反映出来不同时刻随机过程取值的相关性了。</p><h4 id="自协方差函数">自协方差函数</h4><p><span class="math display">\[B(t_1, t_2) = E\left\{ \left[ \xi(t_1) -a(t_1) \right] \left[ \xi(t_2) - a(t_2) \right] \right\} = R(t_1, t_2) -a(t_1)a(t_2)\]</span></p><p>同理的，这个自协方差函数的定义就是在这个自相关函数的基础上进行改进，防止偏移影响，给变成了中心化的形式。</p><h4 id="相关系数">相关系数</h4><p><span class="math display">\[  \rho(t_1, t_2) = \frac{B(t_1,t_2)}{\sigma(t_1)\sigma(t_2)}\]</span></p><p>若 <span class="math inline">\(\rho(t_1, t_2) = 0\)</span> ，称 <spanclass="math inline">\(\xi(t_1)\)</span> 和 <spanclass="math inline">\(\xi(t_2)\)</span> 不相关。</p><h3 id="联合分布函数与概率密度">联合分布函数与概率密度</h3><p>这个没咋看懂，放随机信号分析里面学吧，这里也不是重点，书上甚至都没。</p><h1 id="随机过程举例">随机过程举例</h1><h2 id="平稳随机过程">平稳随机过程</h2><h3 id="定义">定义</h3><p>若一个随机过程的统计特性与时间起点无关，随时都是符合一定的统计特性，就是严平稳。</p><p>换算一下就是任意有限维概率密度与时间起点无关。一维概率密度函数与时间t无关，二维分布函数只与时间间隔<span class="math inline">\(\tau\)</span> 有关，判定法：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191826558.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>严平稳的均值是常数，自相关函数仅与时间间隔有关。</p><p>当然，这个还是比较的严格，我们一般来说用不到这个，用的是宽平稳。</p><p>宽平稳只需要满足这个<strong>均值是常数，自相关函数仅与时间间隔有关</strong>即可。</p><h3 id="性质">性质</h3><h4 id="遍历性">遍历性</h4><p>随机过程随便揪住一个实现，他就能在时间上经历随机过程的所有可能。</p><p>换个形象法的描述就是，在某一不变环境下打开开关一直不关，产生的随机信号中蕴含全部的信息。</p><p>这个就很好，可以用时间的特性来代替统计特性，不需要再知道这个随机过程的分布函数了，求什么平均就可以用时间平均代替统计平均。</p><p>注意这个<strong>遍历过程一定是平稳的，但是平稳不一定就是遍历</strong>，这两个并非互为充要关系。</p><h3 id="后记">后记</h3><p>实平稳随机过程的自相关函数有一些性质，这里也不细讲了，做题的时候再说。</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191853908.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191857325.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>以及其有一些功率谱密度的计算：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191857387.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191857046.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191854100.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="高斯随机过程">高斯随机过程</h2><h3 id="定义-1">定义</h3><p>若随机过程的任意n维分布都是正态分布，则将其称为高斯随机过程或正态过程，</p><h3 id="重要性质">重要性质</h3><ul><li><p>高斯过程的n维分布完全由n个随机变量 <spanclass="math inline">\(x_1, x_2, \cdots, x_n\)</span>的数学期望、方差以及两两变量之间的归一化协方差函数决定；</p></li><li><p>广义平稳的高斯过程也狭义平稳；</p></li><li><p>高斯过程在不同时刻取值不相关，则它们也统计独立：</p></li></ul><p><span class="math display">\[f_n(x_1, x_2, \cdots, x_n; t_1, t_2,\cdots, t_n) = f(x_1, t_1) f(x_2, t_2) \cdots f(x_n, t_n) \]</span></p><ul><li><p>对于高斯变量来说，不相关和独立是等价的；</p></li><li><p>高斯过程经过线性变换（或线性系统）后仍为高斯过程，但数字特征发生改变；</p></li><li><p>若干个高斯过程的代数和仍为高斯过程，但数字特征发生改变：</p></li></ul><p>若</p><p><span class="math display">\[X_1 \sim N(\mu_1, \sigma_1^2) ， X_2\sim N(\mu_2, \sigma_2^2) \]</span></p><p>，则</p><p><span class="math display">\[aX_1 + bX_2 \sim N(a\mu_1 + b\mu_2,a^2\sigma_1^2 + b^2\sigma_2^2) \]</span></p><p>还有两页PPT的内容，在这里直接略。</p><h2 id="窄带随机过程">窄带随机过程</h2><p>随机过程通过以 <span class="math inline">\(f_c\)</span>为中心频率的窄带系统的输出，即是窄带过程。</p><p>所谓窄带系统，是指其通带宽度 <span class="math inline">\(\Deltaf&lt;&lt;f_c\)</span> ，且 <span class="math inline">\(f_c\)</span>远离零频率的系统。</p><p>实际中，大多数通信系统都是窄带型的，通过窄带系统的信号或噪声必是窄带的，如果这时的信号或噪声又是随机的，则称它们为窄带随机过程。</p><p>如用示波器观察一个实现的波形，则如图2—4所示，它是一个频率近似为 <spanclass="math inline">\(f_c\)</span>，包络和相位随机缓变的正弦波。（注意是缓慢变化，这样基带信号带宽才窄）</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510191936601.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="正弦波加窄带高斯过程">正弦波加窄带高斯过程</h2><p>这个属于上面几部分的一个应用：</p><p>有个常用调制方法，就是拿正弦波（最简单的波）作为载波，接收机就是接受正弦已调信号和窄带高斯噪声的混合波形。</p><h2 id="高斯白噪音和带限白噪音">高斯白噪音和带限白噪音</h2><h3 id="定义-2">定义</h3><p>功率谱密度在所有频率上均为常数的噪声，即</p><p>双边功率谱密度： <span class="math inline">\(P_n(f) = \frac{n_0}{2}(-\infty &lt; f &lt; +\infty )\)</span></p><p>单边功率谱密度： <span class="math inline">\(P_n(f) = n_0  (0 &lt; f&lt; +\infty)\)</span></p><p>式中 <span class="math inline">\(n_0\)</span> — 正常数</p><p><strong>白噪声的自相关函数</strong>：对双边功率谱密度取傅里叶反变换，得到相关函数：</p><p><span class="math display">\[  R(\tau) = \frac{n_0}{2}\delta(\tau)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-10-12-1+1</title>
    <link href="/2025/10/14/%E5%8F%8D%E6%80%9D/2025-10-12-1+1/"/>
    <url>/2025/10/14/%E5%8F%8D%E6%80%9D/2025-10-12-1+1/</url>
    
    <content type="html"><![CDATA[<h1 id="一">一</h1><p>人这一生，似乎总要离开原地，才能明白远方的存在，于是，在那个略显凉意的午夜，我到了机场。同行的是熟悉的同窗，真正与我为伴的，是那句在旅途初始时悄然浮现的问题——我为何要出发？</p><p>那一夜在候机厅的灯光下，看着窗外飞机的起与降，想着自己惯常的眠与醒。巨大的航站楼在灯光下显得空旷而无情。有人在栏杆旁抱着书本躲避着现实的林林总总，有人在座椅上里把孤独折叠成安静的姿态。倚在自动按摩椅上，任无意义的机械推动着僵硬的背部，忽的意识到：真正使人难以入眠的，从不是硬邦邦的座椅，而是“此刻无所归属”的漂泊感。既不在出发地，也未抵达目的地，像被悬挂在半空的钟摆，不知该向哪一端倾斜。</p><p>——我为何而出发？</p><p>抵达广州，这里有着一种低声的繁华。在城中行走，走在陈家祠的雕梁画栋前，细密的光影在墙壁上翻动，像一块被岁月揉皱的布。沙面岛的道旁插满红旗，仿佛诉说着往日起义时的峥嵘。穿过湿润的老巷，吃一份鲜香的牛肉，喝一碗清凉的糖水，看石墙上斑驳的青苔，登广州塔俯瞰脚下如星河般铺展的万家灯火。在那一刻，却分明感受到一种荒凉的真相：无论如何仰望，如何攀登，如何追寻，到头来，人终究渺如沧海之一粟。终其一生，或许只配点亮属于自己的那一盏烛火。</p><p>此时此景，上次见仍是自京城南下，坐在舷窗旁，只觉大地在我脚下，全城俯瞰无余，少年意气，鲜花怒马。但如今为何是此等心境？</p><p>或许，是时候追寻古仁人之心，不以物喜，不以己悲，即使穷其一生仅能换烛火一盏，光芒一寸，无法丈量寥廓无垠，无法驱散长夜如漆，但仅此即可，仅此用这一寸光，证明我们曾经站立过，曾经呼吸过。</p><p>日落日升，黄埔的旧址让人听见时间的肃穆。墙角的风像过去的回声，吹不起惊涛骇浪，只在耳际低低叹息。若是数年前至此，想必是意气风发，指点江山，激扬文字。此刻却是低下头默默的走，更多是在听：听历史如何在沉默中把自己讲成故事，听自我如何在回声中辨认出真诚与虚饰。行走其间，记忆与现实在脚下交错，发现许多被夸大的、被相信的期望与愿望，其实不过是一场长时间的自我蒙蔽，而真正重要的，往往只是当下的一个微小的行动，一次理性的思考，一场安静的回答。</p><p>——我为何而出发？</p><p>夜间至深圳，城市在夜色里如潮水般涌动。高楼不语，似无声的巨人，直升机在头顶划出冰凉的轨迹，人群涌来又散去。我站在人才公园的湖边接到来自家乡的消息，手机的震动在掌心里显得格外突兀。</p><p>那一刻，我突然生出一种奇异的疏离：我像这片灯光海洋中的一粒暗沙，任世界奔涌，也无法融入其中。越是喧嚣处，人反而越听得见自己内心的回声。</p><p>——三年前的我，是为了什么而出发？</p><p>自罗湖入香港，香港倒像是一座荒诞的城市，繁华与破败并存，包容与歧视交织。九龙城寨好像已经成为历史，却又隐约潜伏在街头的霓虹下，在狭窄的巷弄里，在粤语的粗粝冷呵声中。</p><p>走进艺术展，那些被拆解又重组的装置、反传统的宣言，在霓虹灯下反复闪烁着几个词：“你相信什么？”“你的立场在哪里？”我一时语塞。原本以为旅行是去看风景，没想到风景反过来开始审视我。</p><p>我沿着山路攀至太平山顶，每一步都在逼问：</p><p>——我究竟在追寻什么？我为何而行走？</p><p>我沉默。我不知道。</p><p>夜晚去看烟花，维多利亚港的夜风拂过，城市的轮廓被海面温柔地揉成模糊的诗行。那些烟火与光带来的，不只是短暂的绚烂，更多是让人在浩瀚与微小之间找到一种平衡感——世界仍旧广阔，而我仍能在其中呼吸。</p><p>但我仍不知我为什么而出发。</p><p>过港珠澳大桥，城市迅速变化。澳门像是一座躲在已褪色的黄金外壳下的空心之城。赌场灯火通明，人们在其中旋转、押注、欢呼，然后失落、离去。华丽被凝固成一种近乎荒谬的静止：越是金碧辉煌之处，人越显得渺小。我们举着筹码，以为在与命运对赌，殊不知消耗的筹码，却是自己的热望。</p><p>忽然明白：这趟旅行，并不是在寻找答案，而是在旅途中观察世间的林林总总，以人为鉴，不断剥落那些虚假的、幼稚的自我，直到只剩下一盏仍愿意燃烧的烛火。</p><p>我，向着起点出发。</p><p>归程在机场展开。飞机划过云层，将岭南的海面与灯火抛在身后。舷窗外是广袤的平原与山地，忽然感到一种奇异的平静。我并未在这趟旅途中找到答案，却在反复地疑问与疲惫中，确认了我仍在寻找。</p><p>而这，或许已经足够。</p><p>人来到这世间，并非为了赢得某种结局，而是为了在无垠黑夜中，仍愿意举起属于自己的那一支小小烛火。它也许微弱，也许随时会被风吹灭，但只要我愿意护着它，它便仍在燃烧。</p><p>我曾在南方的灯火之中驻足，而今我将它带回心底。它不照亮远方，却能照亮此刻的我。</p><p>——我还在路上。我还要出发。</p><h1 id="二">二</h1><p>做事之前，固然要权衡利害，但更重要的是明白，每一次举动，都是利益的流动。无论你觉得它轻如鸿毛还是重如山岳，终究会触碰他人的边界，牵动某根看不见的弦。</p><p>因此，不必畏惧得罪人。只要世界仍在运转，只要人与人之间仍有接触，哪怕是无声的眼神、轻描淡写的一句回应，其实都包含着一种流动：或是资源，或是情绪，或是立场。凡有流动，便有摩擦。所谓不得罪人，不过是自我欺哄罢了。</p><p>真正不会得罪人的情形，不过寥寥三种：</p><p>其一，对方自愿割肉，甚至还感恩戴德；</p><p>其二，奉献只止于自己，他人只需获得；</p><p>其三，你无足轻重，哪怕你呐喊，也无人在意。</p><p>既如此，做人只需问一句：此事我做得是否逻辑自洽？是否问心无愧？是否符合处事标准？若左脑不会去攻击右脑，三观不会在胸中打架，那便不必战战兢兢。立场若是清明，步伐便应坚定。</p><p>反之，若事事犹疑，遇人就退，不愿表明立场，那久而久之，你在众人眼中便不再是“温和”，而是透明。被理解是一种幸运，而被忽视，却是缓慢且无声的湮没。</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 绪论</title>
    <link href="/2025/10/09/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/"/>
    <url>/2025/10/09/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>实际上这本书是入门中的入门，给大家提供一个通信的背景，知道通信是什么，如何评判他的好坏，如何有效可靠的传递信息。</p><p>本章即为提供最初始的一个背景。</p><h2 id="通信的基本概念">1.通信的基本概念</h2><p>研究对象：信号、消息、信息。区别略。</p><p>组成模型：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510091958610.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>模拟里面用的是调制器和解调器，因为一般的拿自由空间来传输的电信号和信源频率不一样，需要调制器来调制变换。调制之后的信号叫<strong>已调信号</strong>，或者叫<strong>带通信号</strong>，因为他的频谱通常是是带通的。</p><p>数字通信里面用的是信源编码信道编码和相应的解调译码，他就不用像模拟信号一样调制了，他要的叫数字调制和解调，等于是搬频谱，同时更需要有效率的ad转换、抗干扰处理。</p><p>PS：</p><p>数字通信有一个不太好的点，就是需要的带宽比较大，因为他这个时域波形很方，有高频成分，频域就算近似的话也不能太窄，不然导致失真严重。</p><p>另外，在数字通信中常见的 调制方式（ASK、PSK、QAM 等）也是通过在频带上携带数字信息的。</p><p>调制阶数越高（例如16QAM、64QAM），在相同带宽内能传更多bit，这是我们常说的频谱效率提升。</p><p>其他的这些，什么分类啊，半双工全双工，不是现在死记硬背的，略过不讲，知道研究什么（研究对象的单元及其组成的模型）即可。</p><h2 id="信息的度量">2.信息的度量</h2><p>这个部分实际上信息论已经给我们讲过了一遍，用的啥？还是倒数取对，得<strong>信息量</strong>。</p><p><span class="math display">\[I=-log_aP(x)\]</span></p><p>因为这样能很好的符合：</p><ul><li><p>概率越小的事情信息量越大</p></li><li><p>若干独立事件构成的消息等于个独立事件信息量之和</p></li></ul><p>同时定义<strong>信息熵</strong> <spanclass="math inline">\(H\)</span> （离散）：</p><p><span class="math display">\[H(x) =  \sum P(x_i)I(x_i)\]</span></p><p>等于就是加权求和嘛，描述的是<strong>平均的信息量</strong>。</p><p>不过要注意的一点就是，这个权重是针对整体概率的，而非样本的，详情可见下面这个例题：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202510092040161.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="通信系统主要性能指标">3.通信系统主要性能指标</h2><p>首先介绍有效性，有效性用来描述这个系统是否能传输信号。具体而言就是拿传输速率指标来判断是否有效。</p><p>数字通信系统中频带利用率定义为单位带宽内传输速率，即</p><p><span class="math display">\[\eta = \frac{R_B}{B}(Baud/Hz)\]</span></p><p>或</p><p><span class="math display">\[\eta_t = \frac{R_b}{B} \quad (\text{b/(s·Hz)})\]</span></p><p><span class="math inline">\(R_B\)</span>为<strong>码元传输速率</strong>，简称<strong>传码率</strong>。它被定义为单位时间（每秒）传输码元的数目，单位为波特（Baud），因此又称为<strong>波特率</strong>。</p><p>设每个码元的长度为 <spanclass="math inline">\(T_B(s)\)</span>，则有</p><p><span class="math display">\[R_B = \frac{1}{T_B} \quad (\text{Baud})\]</span></p><p><span class="math inline">\(R_b\)</span>为<strong>信息传输速率</strong>，简称<strong>传信率</strong>，又称<strong>比特率</strong>。它定义为单位时间内传输的平均信息量，单位为比特/秒(b/s)。</p><p>因为一个 <span class="math inline">\(M\)</span> 进制码元携带 <spanclass="math inline">\(\log_2 M\)</span>比特的信息量，所以<strong>码元速率</strong>和<strong>信息速率</strong>有以下确定的关系，即</p><p><span class="math display">\[R_b = R_B \log_2 M \quad(\text{b/s})\]</span></p><p>或</p><p><span class="math display">\[R_B = \frac{R_b}{\log_2 M} \quad(\text{Baud})\]</span></p><p>例如，设码元速率为 1200 Baud，若采用八进制，则信息速率为 3600b/s。<br />若设每个二进制码元的持续时间为 T_b，则 T_B 与 T_b 有如下关系：</p><p><span class="math display">\[T_B = T_b \log_2 M\]</span></p><p>一个好的通信系统除了要能传输信息，同时也要保证传输是正确的，传输是可靠的。</p><p>在模拟通信系统中，可靠性通常用接收端输出信号与噪声功率比 (S/N)来度量，即<strong>信噪比</strong>，S/N与调制方式有关，这个之后再说。</p><p>在数字通信系统中，可靠性可用<strong>误码率</strong>表示。误码率反映传输过程中发生错误的概率，通常定义为传错码元数占传输总码元数的比例，更确切地说，误码率表示码元出错的概率的概念，即</p><p><span class="math display">\[P_e =\frac{\text{错误码元数}}{\text{传输总码元数}}\]</span></p><p>或</p><p><span class="math display">\[P_b =\frac{\text{错误比特数}}{\text{传输总比特数}}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习资源</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未知</title>
    <link href="/2025/09/24/%E5%8F%8D%E6%80%9D/2025-09-23-%E6%9C%AA%E7%9F%A5/"/>
    <url>/2025/09/24/%E5%8F%8D%E6%80%9D/2025-09-23-%E6%9C%AA%E7%9F%A5/</url>
    
    <content type="html"><![CDATA[<p>笔锋陡然一坠，轻触纸面，却不知运笔何向，只得在纸面泧开一片硕大的墨痕，好似一个待人答复的诘问。</p><p>我又为何提起笔，写下如此字句？</p><p>或许，正是这看似无用的书写，这无人见证的喃喃，反而更接近真正的有用。</p><p>哲人常言，万物皆可被赋予意义：鸟鸣是求偶的欢歌，花开是传粉的誓言，可若再追问一句：繁衍有何意义？物种终将灭绝，寰宇终将死寂，所谓”意义“，在纷繁广袤的寥廓面前，未免显得如此单薄。繁衍的尽头是寂灭，积聚的终局是散尽。以人类短暂的心智所构建的意义体系，去丈量宇宙无垠的虚无，何异于以萤火之光映照亘古长夜？一切坚固的阐释，在永恒的沉默面前，都如同沙砌的城堡，潮汐一来，便了无痕迹。</p><p>然而，怅寥廓无垠、光阴荏苒，并非意图将人引向虚无的深渊。恰恰正是在承认了人生虚无之后，再去观察那些曾被轻蔑地视为“虚度光阴”的片刻，反而能欣赏其焕发出的那种奇异的光泽。就好似纸上泧开的墨痕，正是肆意张扬向四处延伸的无用墨色枝桠，成就了他独一无二的形态。</p><p>既然意义的高塔终是空中楼阁，那么，在过程中全情沉浸的体验，感受与他人真切联结的温暖，是否反而成为一种更真实、更坚韧的“存在”？</p><p>或许，我提起笔，只为写下如此字句？</p><p>近二月来在广播台里的那些时光，何尝不是这样的真实的“存在”？在407，意义不再需要宏大的辩解。策划、宣传、组织，这些琐碎的事务因其“无目的”而纯粹。我并不是为了建造一座永恒的纪念碑，妄图多年后，广播台中还有人记得我；只是贪恋那一刻热腾腾的存在，只是为了证明我，此时此刻，还站着407中，我还在呼吸，心脏还在跳动。</p><p>我们总是按照利害关系，判断这事情是否要做。但是，有的事情不需要考虑功利，有的关系不需要思考利弊，就像此刻，你看着我的文字，我想着你的存在，我们虽未见面，却已在某种意义上彼此陪伴。这份温暖无需换算为铜臭，它本身便是最纯洁的慰藉。</p><p>这种对存在的渴望，或许也能解释为何我无需为保研加分努力时，仍愿付出多余的精力。那些做实验，写文稿的日夜，被剥去了功利的外衣后，都是对抗虚无的微小实践。仍记得那天那晚，专利稿件撰写完毕，随老师吃完饭，骑车从天街返校，夜色稍浓，风儿正盛，道旁树影婆娑。那一刻，像在无尽荒原上，终于擦亮了一豆烛火。虽然知道风随时可能将它吹灭，但那一瞬的光，照见了自己的手掌，也勉强照见了前路的一寸，证明在这如漆长夜，我还活着。</p><p>或许，我只是为了提起笔，才写下如此字句？</p><p>雁过而留痕，我也想在日趋饱和的目标检测方向留下些许爪印，尝试在某个不知名的小刊物上留下一行署名。然而，细粒度检测的研究如入迷雾中的森林，每一个假设都像歧路，越深入越是茫然，每一篇文章都在告诫，要付出多少精力，为数据集，为算力，为模型设计，为实验试错。</p><p>叩问，叩问，只换来空谷传响，余音久绝。</p><p>而更令我焦灼的，是内在的迟滞与疏离。雄心欲筑城，行动却如流沙；向往那个精进的幻影，却与真实背道而驰。</p><p>穷且益坚，不坠青云之志。</p><p>换个角度，这焦灼本身，何尝不是“存在”的证明？它源于未熄的渴望，而非死寂的沉沦，好似困兽的挣扎，而非如镜的死水。徘徊与撞击，或许并非徒劳，而是生命在寻找其真实的形态与力量前，必要的沉吟与积蓄。重要的，不是能否抵达某个预设的彼岸，而是在这沉吟中，我依然能感知到内心的烛火——它虽摇曳，却未熄灭。</p><p>夫天地者，万物之逆旅；光阴者，百代之过客。既然皆是行旅，那么，或疾或徐，或歌或泣，每一步便都是对虚无的回应。或许，真正的凯旋，不在于功成，而在于明知浮生若梦，却依然能珍视这良夜，秉烛前行。</p><p>曾几何时，我也是那个手持所谓“意义”粗糙标尺、试图丈量无垠苍穹的天真者；如今，我更愿做一名平凡的赶路人，在可以触摸的光阴里安驻。无论是广播台的话筒前，实验室的仪器旁，还是书页堆积的案头，重要的不再是丈量结果，而是行走本身。</p><p>而在这漫长的行旅中，有时也会遇见不期而然的风景。譬如，路旁悄然立着一株清雅的蒹葭，它的存在本身，便让周遭的荒芜显得不那么决绝。如同古人诗中的“伊人”，静立于水的彼岸，我无需，亦不愿溯洄从之，去打破那份完美的距离。只因这眺望本身，已是一种馈赠。它宛若一缕清风，拂过荒原，并不驱散长夜，却让烛火的摇曳有了伴奏。这无言的清莹，这遥远的映照，恰恰提醒我：世界尚有值得静默欣赏的美好，这本身，便是对“存在”最温柔的确认。</p><p>无可奈何花落去，似曾相识燕归来。所有的困顿、滞重与不可得，都如逝去的花期；而笔下的墨痕、音波里的笑语、实验室深夜的孤灯，乃至对那株蒹葭的遥远祝福，便是那归来的燕，带着生生不息的暖意。</p><p>或许，我写下这些字句，并非为了寻求答案。只是为了确认，我正真实地、矛盾地、热切地走过。我还活着。</p><p>不要温和地走进那个良夜——怒斥，怒斥光明的消逝。</p><p>我只是为了提起笔，只是写下了如此字句。</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模综述</title>
    <link href="/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%BB%BC%E8%BF%B0/"/>
    <url>/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>数学建模的整个知识体系可以被构建在一个由<strong>三大支柱</strong>和一个<strong>坚实地基</strong>组成的框架之上，该框架根据问题的核心目标来对所有方法进行归类。</p><ul><li><p><strong>第一大支柱是机理驱动建模(白箱方法)</strong>，其核心是回答“<strong>为什么</strong>”。它基于已知的科学原理（如物理、生物定律）来建立微分或差分方程，旨在从根本上解释和预测系统的动态行为，尤其适用于数据稀疏甚至不存在但内在规律清晰的场景。它抓住了事物发展的本质规律，而非表面的数据模式。是识别变量-&gt;分析规律-&gt;建立方程的一个过程</p></li><li><p><strong>第二大支柱是数据驱动建模(黑箱方法)</strong>，其核心是回答“<strong>是什么</strong>”。当系统内部机理复杂难明但拥有海量数据时，该方法通过统计学和机器学习技术，直接从数据中学习输入到输出的映射关系，以实现精准的预测、分类和模式识别。是收集准备数据-&gt;选择模型范式-&gt;训练与验证模型的一个过程。</p></li><li><p><strong>第三大支柱是决策驱动建模(优化方法)</strong>，其核心是回答“<strong>怎么办</strong>”。它旨在为现实世界中的资源分配、路径规划等问题，在各种约束条件下寻找使目标（如利润、效率）最优化的最佳解决方案，主要工具为数学规划和各类优化算法。是一个确定决策变量-&gt;建立目标函数-&gt;明确约束条件的过程</p></li><li><p><strong>坚实的地基则是通用工具与思想</strong>，支撑着所有建模活动。这主要包括作为数据与模型桥梁的<strong>数据插值与拟合方法</strong>，以及作为模型质量保证的<strong>模型评价体系</strong>。</p></li></ul><p>在实践中，这三大支柱并非相互独立，而是常常融合使用如在传染病模型建立过程中是使用机理建模+数据拟合求参数，很多销售问题是使用预测+决策，通过结合不同方法的优势来解决更为复杂的现实问题。理解此框架有助于在面对任何问题时，迅速定位其本质，并选择最恰当的建模路径。</p><h2 id="前言">前言</h2><p>作为数学建模系列博客的开篇，本文旨在对数学建模的核心思想、方法论以及常用技术分支进行一次全面的综述。本次学习和梳理将涵盖以下关键内容，力求讲明各类方法的中心思想，为后续深入探讨具体实现奠定基础：</p><ul><li><p><strong>数学建模方法论</strong></p></li><li><p><strong>最优化方法建模</strong></p></li><li><p><strong>统计学方法与数据挖掘</strong></p></li><li><p><strong>数据拟合与插值方法</strong></p></li><li><p><strong>微分/差分方程方法建模 (动态过程建模)</strong></p></li><li><p><strong>机器学习与集成方法</strong></p></li><li><p><strong>模型评价</strong></p></li></ul><h2 id="一-数学建模方法论">一、 数学建模方法论</h2><p>数学建模是将现实世界的问题转化为数学语言的过程。无论问题背景如何变化，其核心流程都遵循一套科学、系统的准则，这套准则可以概括为以下六个步骤：</p><ol type="1"><li><p><strong>问题理解 (BusinessUnderstanding)</strong>：首先要明确问题的要求和最终目的。在数学竞赛中，这意味着深入剖析题意，查找与问题相关的文献和研究现状，快速了解可选的方法、技术的可行性、预期的成效及其优缺点。</p></li><li><p><strong>数据理解 (DataUnderstanding)</strong>：检查可用数据的数量和质量，评估其完整性与正确性。通过计算描述性统计量、进行探索性数据分析（EDA），来发掘数据记录和变量的内在特征与规律。结合文献，判断哪些变量可能与目标相关，数据是否需要均衡处理，以及初步判断适合的建模方法。</p></li><li><p><strong>数据准备 (DataPreparation)</strong>：对原始数据进行清洗、转换和重构。这包括填补缺失值、处理异常值、选择与挖掘目标相关的变量。例如，在回归分析中，需要将名义变量（如性别、地区）转换为哑变量。有时，依据专业知识构造衍生变量（如利用身高、体重构造BMI指数）会更有利于模型构建。</p></li><li><p><strong>模型选择与建立(Modeling)</strong>：根据问题的性质和数据的特点选择合适的建模方法。参数确定可以手动调整，也可采用网格搜索、随机搜索等自动化方法。如果单一模型效果不佳或不确定哪种更好，可以训练多个模型，通过集成学习的策略得到一个性能更优、鲁棒性更强的集成模型。</p></li><li><p><strong>模型评估(Evaluation)</strong>：对模型的性能和成效进行客观评估。通常采用交叉验证等方法，以避免因训练集、测试集的划分不同而导致的模型准确率波动。核心是检验模型是否存在欠拟合或过拟合现象。</p></li><li><p><strong>结果呈现与部署(Deployment/Reporting)</strong>：以清晰、科学的方式总结并输出建模结果。可以参照科技期刊论文的结构和逻辑来组织成果，确保模型的科学性、创新性以及结论的可靠性。</p></li></ol><h2 id="二-核心建模方法">二、 核心建模方法</h2><h3 id="最优化方法-数学规划">2.1 最优化方法 (数学规划)</h3><p>最优化问题的本质是在一系列约束条件下，寻找决策变量的最优取值，以使目标函数达到极大值或极小值。</p><ul><li><p><strong>线性规划 (Linear Programming,LP)</strong>：目标函数和所有约束条件均为线性函数。这是最基础的优化模型，其最优解一定在可行域的顶点上取到。主要求解算法为单纯形法和内点法。</p></li><li><p><strong>整数规划 (Integer Programming,IP)</strong>：在线性规划的基础上，要求一个或多个决策变量必须取整数值。其中，变量仅能取0或1的<strong>0-1整数规划</strong>常用于“是/否”决策。求解难度远高于线性规划，常用算法为分支定界法和割平面法。</p></li><li><p><strong>非线性规划 (Nonlinear Programming,NLP)</strong>：目标函数或约束条件中至少有一个是非线性的。这是最普遍也最复杂的一类问题，其求解通常依赖于梯度下降法、牛顿法，或针对有约束问题的拉格朗日乘数法和KKT条件。</p></li><li><p><strong>组合优化 (CombinatorialOptimization)</strong>：决策变量是离散的，旨在众多可能性中“组合”出一个最佳方案，如旅行商问题(TSP)、选址问题等。这类问题大多是NP-hard问题，对于大规模实例，通常采用启发式算法（如遗传算法、模拟退火、蚁群算法）求解。</p></li></ul><h3 id="数据插值与拟合方法">2.2 数据插值与拟合方法</h3><p>当面对一系列离散数据点时，插值与拟合是将其转化为连续函数的两大路径，但它们基于完全不同的哲学假设。</p><ul><li><p><strong>插值 (Interpolation)</strong>：</p><ul><li><p><strong>核心思想</strong>：假设所有数据点都是<strong>绝对精确</strong>的，构造的函数曲线必须<strong>严格穿过</strong>每一个数据点。</p></li><li><p><strong>方法</strong>：经典的多项式插值（拉格朗日、牛顿）在处理高次问题时会遭遇<strong>龙格现象</strong>（边缘剧烈振荡）。为解决此问题，<strong>样条插值</strong>（尤其是三次样条）应运而生，它通过分段低次多项式并保证连接处的光滑性，完美平衡了精确性与光滑性，是当前最稳健的插值方法。</p></li></ul></li><li><p><strong>数据拟合 (Fitting)</strong>：</p><ul><li><p><strong>核心思想</strong>：假设数据包含<strong>随机误差或噪声</strong>，不强求曲线穿过任何点，而是寻找一条最能反映数据<strong>整体趋势</strong>的曲线。</p></li><li><p><strong>方法</strong>：基石是<strong>最小二乘法</strong>，即寻求一条曲线，使得所有数据点的真实值与函数预测值之差（残差）的平方和最小。根据函数形式，可分为线性拟合、多项式拟合和非线性拟合。对于非线性关系，常尝试通过变量变换将其<strong>线性化</strong>以便求解。</p></li></ul></li></ul><h3 id="统计与数据挖掘方法">2.3 统计与数据挖掘方法</h3><p>当问题的内在机理不清，但拥有充足数据时，统计与数据挖掘方法（“黑箱”方法）能从数据中发现规律和模式。</p><ul><li><p><strong>探索性数据分析(EDA)</strong>：通过计算描述性统计量（均值、方差等）和数据可视化（直方图、箱线图、散点图等），在建模前探索数据的内在结构、规律、异常值和变量间关系。</p></li><li><p><strong>假设检验</strong>：用于判断样本所反映的情况是否与某个假设（原假设）存在显著差异。核心思想是在假定原假设为真的前提下，计算出当前样本结果出现的概率（<strong>P值</strong>），若P值足够小（如小于0.05），则拒绝原假设。常用方法包括<strong>t检验</strong>（比较均值）、<strong>F检验</strong>（比较方差，用于方差分析ANOVA）、<strong>卡方检验</strong>（分析分类变量的关联性）等。</p></li><li><p><strong>相关与回归分析</strong>：</p><ul><li><p><strong>相关分析</strong>：度量<strong>两个连续变量</strong>之间线性关系的强度和方向（Pearson相关系数）或等级关系（Spearman相关系数）。</p></li><li><p><strong>回归分析</strong>：建立因变量与一个或多个自变量之间的定量关系模型，用于预测和解释。线性回归是基础，其核心假设包括线性、独立性、方差齐性和正态性。为解决多重共线性问题，发展出了<strong>岭回归</strong>和<strong>Lasso回归</strong>等正则化方法。</p></li></ul></li><li><p><strong>分类建模</strong>：当因变量为类别时使用。<strong>逻辑回归</strong>虽名为回归，实为二分类模型。其他常用模型包括<strong>决策树、支持向量机(SVC)、随机森林</strong>等。</p></li><li><p><strong>聚类分析</strong>：一种无监督学习方法，在没有预先定义类别的情况下，根据数据的相似性将样本自动“物以类聚”。最经典的算法是<strong>K-Means算法</strong>。</p></li></ul><h3 id="微分差分方程方法-动态过程建模">2.4 微分/差分方程方法(动态过程建模)</h3><p>当需要描述事物随时间或空间演变的规律，且其内在机理清晰时（“白箱”方法），微分和差分方程是首选工具。</p><ul><li><p><strong>差分方程</strong>：适用于描述<strong>离散、跳跃式</strong>的阶段性变化过程。例如，按“年”更新的人口模型。建模的核心是建立当前状态<span class="math inline">\(x_{n+1}\)</span> 与前一个或几个状态 <spanclass="math inline">\(x_n, x_{n-1},...\)</span>之间的关系。经典的<strong>Logistic模型</strong>就描述了在资源约束下种群数量的离散变化，甚至能展现混沌现象。</p></li><li><p><strong>微分方程</strong>：适用于描述<strong>光滑、连续</strong>的动态演变过程。建模的核心是找到事物的“变化率”与其“当前状态”之间的关系。例如，<spanclass="math inline">\(\frac{dx}{dt} = kx\)</span>描述了无约束下的指数增长或衰减。</p></li><li><p><strong>定性分析</strong>：无论是差分还是微分方程，求解解析解往往很困难。因此，分析模型的长期行为至关重要，这主要通过寻找系统的<strong>平衡点</strong>并判断其<strong>稳定性</strong>来完成。稳定性分析可以告诉我们，在受到微小扰动后，系统是会回归平衡还是会崩溃。</p></li><li><p><strong>偏微分方程(PDE)</strong>：当研究对象不仅随时间变化，还随<strong>空间位置</strong>变化时，就需要使用偏微分方程。例如，模拟污染物在湖水中的扩散过程。</p></li></ul><h3 id="机器学习与集成方法">2.5 机器学习与集成方法</h3><ul><li><p><strong>机器学习</strong>：作为统计学和计算机科学的交叉领域，提供了大量强大的建模工具，尤其擅长处理高维和复杂的非线性问题。上文提到的决策树、支持向量机、神经网络等均属此范畴。</p></li><li><p><strong>集成学习 (EnsembleLearning)</strong>：一种高级建模策略，它不依赖于单个模型，而是将多个“弱”学习器组合起来，形成一个性能更强的“专家委员会”，以提高整体的准确性和鲁棒性。</p><ul><li><p><strong>Bagging(装袋)</strong>：通过并行训练多个模型（如随机森林中的决策树），并对结果进行投票或平均来提升性能。</p></li><li><p><strong>Boosting(提升)</strong>：串行训练模型，后一个模型会重点关注前一个模型预测错误的样本，从而“纠正”错误。代表算法有AdaBoost、XGBoost。</p></li><li><p><strong>Stacking(堆叠)</strong>：将第一层多个模型的输出作为特征，来训练第二层的元模型，是一种更为复杂的集成方式。</p></li></ul></li></ul><h2 id="三-模型评价">三、 模型评价</h2><p>建立模型后，必须有客观标准来衡量其性能。评价指标根据模型类型（分类或预测）而有所不同。</p><ul><li><p><strong>分类模型评价指标</strong>：基于<strong>混淆矩阵</strong>计算。</p><ul><li><p><strong>准确率(Accuracy)</strong>：正确分类的样本占总样本的比例。在样本不均衡时具有误导性。</p></li><li><p><strong>查准率(Precision)</strong>：预测为正例的样本中，真正是正例的比例。当“误报”代价高时很重要。</p></li><li><p><strong>查全率(Recall)</strong>：所有真正的正例中，被成功找出的比例。当“漏报”代价高时很重要。</p></li><li><p><strong>F1分数(F1-Score)</strong>：查准率和查全率的调和平均数，是一个综合性指标。</p></li></ul></li><li><p><strong>回归模型评价指标</strong>：</p><ul><li><p><strong>均方根误差(RMSE)</strong>：预测值与真实值之差的平方和的平均值的平方根。量纲与原始数据相同，易于解释。</p></li><li><p><strong>平均绝对误差(MAE)</strong>：预测值与真实值之差的绝对值的平均值。对异常值不那么敏感。</p></li><li><p><strong>决定系数 (<spanclass="math inline">\(R^2\)</span>)</strong>：衡量模型能解释因变量变化的百分比，值越接近1越好。</p></li><li><p><strong>修正决定系数 (Adjusted <spanclass="math inline">\(R^2\)</span>)</strong>：在<spanclass="math inline">\(R^2\)</span>基础上考虑了自变量数量，用于比较不同复杂度的模型时更为公允。</p></li></ul></li></ul><h2 id="四-适用范围与工具总结">四、 适用范围与工具总结</h2><ul><li><p><strong>物理规律类问题</strong>：当问题背后有精确的物理或自然规律时，<strong>微分方程</strong>等“白箱”模型是首选，因为它们能从机理上描述系统。</p></li><li><p><strong>统计与金融类问题</strong>：当机理不清，但数据充足时，通常采用统计模型、数据挖掘和机器学习等“黑箱”方法来发现数据驱动的规律。金融数学中的衍生品定价（如BSM偏微分方程）则是一个特例。</p></li><li><p><strong>决策与规划类问题</strong>：涉及资源分配、路径选择、策略制定等问题，核心是<strong>最优化方法</strong>，需要建立目标函数和约束条件进行求解。</p></li></ul><p>无论面对何种问题，一个强大的数学建模“工具箱”应至少包括：</p><ul><li><p><strong>数据拟合与插值</strong>用于数据预处理和函数化</p></li><li><p><strong>最优化方法</strong>用于求解决策</p></li><li><p><strong>机器学习/统计模型</strong>用于从数据中学习和预测</p></li><li><p><strong>近似解法</strong>用于解出差分微分方程</p></li><li><p><strong>线性规划</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>综述概要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据拟合与插值综述</title>
    <link href="/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC%E7%BB%BC%E8%BF%B0/"/>
    <url>/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文旨在系统性地阐述将离散观测数据转化为连续函数模型的两大核心技术路径：数据插值与数据拟合。插值方法，以其严格穿过所有数据点的特性为基础，被定位于对高精度数据进行局部估计与精确重构。本文详细探讨了从经典的拉格朗日与牛顿多项式插值法，到其在高次应用中所面临的龙格振荡现象，最终引出通过分段策略演化而来的样条插值，特别是三次样条，作为实现全局光滑与局部保真度最佳平衡的黄金标准。</p><p>与插值相对，数据拟合则旨在刨除随机误差的影响，发现数据内在的宏观规律。本文以最小二乘法为理论基石，阐明了其通过最小化残差平方和来寻求最佳趋势函数的优化思想。内容覆盖了该原理在线性、多项式及可线性化的非线性模型中的具体应用，并强调了利用决定系数（R²）与修正决定系数等指标对模型优度进行客观评价的重要性。</p><p>综上，本概述通过对比分析，明确了插值与拟合在哲学假设、适用场景与技术实现上的本质区别，旨在为研究者在面对不同数据质量与分析目标时，能够做出恰当的方法论抉择，从而进行更为精确和有洞察力的定量分析。</p><h2 id="概述">1. 概述</h2><p>在科学研究与工程实践中，我们获取的原始数据往往是一系列离散的观测点<code>(x_i, y_i)</code>。然而，为了进行深入分析、预测未知或揭示其内在规律，我们必须构建一个能代表这些数据的连续函数<code>f(x)</code>。数据拟合与插值便是实现这一目标的两大核心技术路径，它们基于不同的哲学假设，服务于不同的分析目的。</p><ul><li><p><strong>插值(Interpolation)</strong>：其核心哲学是<strong>数据绝对精确</strong>。它要求所构造的函数曲线必须<strong>严格穿过每一个给定的数据点</strong>，即<code>f(x_i) = y_i</code> 必须对所有 <code>i</code>成立。插值的主要目的是在已知数据点之间进行精确的、局部的数值估计，其本质是在“填补空白”。</p></li><li><p><strong>拟合(Fitting/Approximation)</strong>：其核心哲学是<strong>数据包含噪声</strong>。它不强求函数曲线穿过任何一个数据点，而是寻求一条能够最佳反映数据<strong>整体趋势</strong>的光滑曲线。拟合的目标是剥离数据中的随机误差，捕捉变量间的根本关系，其本质是在“寻找规律”。</p></li></ul><h2 id="插值方法构建精确的路径"><strong>2.插值方法：构建精确的路径</strong></h2><h3 id="多项式插值"><strong>2.1 多项式插值</strong></h3><p>利用一个 <code>n-1</code> 次的多项式来精确穿过 <code>n</code>个数据点。</p><ul><li><strong>拉格朗日插值法 (Lagrange Interpolation)</strong>：<ul><li><p><strong>思想</strong>：这是一种构造性的方法。它为每个数据点<code>(x_i, y_i)</code> 精心设计一个基函数<code>L_i(x)</code>，该基函数在 <code>x_i</code>处取值为1，而在所有其他的 <code>x_j</code> (<code>j ≠ i</code>)处取值为0。最终的插值多项式便是这些基函数与其对应 <code>y_i</code>值的加权和。</p><p><span class="math display">\[ P(x) = \sum_{i=0}^{n-1} y_i L_i(x)\quad , \quad L_i(x) = \prod_{j=0, j \neq i}^{n-1} \frac{x - x_j}{x_i -x_j} \]</span></p></li><li><p><strong>评述</strong>：该方法理论上极为优雅，但计算上存在不足。每增加一个数据点，所有基函数都需重新计算，缺乏继承性。更严重的是，它无法规避高次多项式插值的固有风险。</p></li></ul></li><li><strong>牛顿插值法 (Newton Interpolation)</strong>：</li></ul><p><strong>思想</strong>：采用迭代的思路构建多项式。它引入了<strong>均差(Divided Differences)</strong>的概念，每增加一个数据点，只需在原有基础上追加一项，体现了良好的继承性和计算效率。</p><p><span class="math display">\[ P(x) = f(x_0) + f[x_0, x_1](x-x_0) +\dots + f[x_0, \dots, x_{n-1}]\prod_{i=0}^{n-2}(x-x_i) \]</span></p><p><strong>评述</strong>：计算上优于拉格朗日法，但同样面临下述问题。</p><ul><li><strong>龙格现象 (Runge's Phenomenon)</strong>：</li></ul><p>这是高次多项式插值中一个必须警惕的陷阱。当使用一个高次多项式对等距节点进行插值时，即使是在拟合一个光滑函数，也可能在区间的边缘出现剧烈的振荡，导致巨大的预测误差。这深刻地表明，盲目追求单一、高次的多项式来穿过所有点是一条危险的路径。</p><h3 id="分段插值与样条插值"><strong>2.2 分段插值与样条插值</strong></h3><p>为规避龙格现象，一种更稳健的策略是放弃全局统一，采用“分而治之”的分段插值。</p><ul><li><strong>分段线性插值</strong>：</li></ul><p><strong>思想</strong>：最简单的分段插值，即用直线依次连接相邻的数据点。</p><p><strong>评述</strong>：简单、快速且绝不会产生振荡。但其代价是在数据点处存在尖角，函数的一阶导数不连续，整体曲线不够光滑，不符合多数物理规律。</p><ul><li><strong>样条插值 (Spline Interpolation)</strong>：</li></ul><p><strong>思想</strong>：这是对分段插值的重大升级，旨在保证全局的光滑性。它采用分段的低次多项式（通常是三次）进行连接，并对连接点（称为“节点”）处的导数连续性提出要求。</p><p><strong>三次样条 (CubicSpline)</strong>：最为常用。它不仅保证函数本身连续，还保证其<strong>一阶导数和二阶导数在所有节点处连续</strong>。这意味着整条曲线不仅没有尖角，其曲率变化也是连续的，达到了视觉和数学上的高度光滑。</p><p><strong>评述</strong>：样条插值是当前科学计算中应用最广泛、效果最稳健的插值方法。它完美地平衡了精确性与光滑性，有效避免了龙格现象，是插值任务的黄金标准。</p><h2 id="拟合方法捕捉数据的灵魂"><strong>3.拟合方法：捕捉数据的灵魂</strong></h2><h3 id="最小二乘法-method-of-least-squares"><strong>3.1 最小二乘法(Method of Least Squares)</strong></h3><p>这是拟合的基石性方法，它为“最佳拟合”提供了一个可量化的标准。</p><p><strong>核心思想</strong>：定义数据点 <code>(x_i, y_i)</code>与拟合函数 <code>f(x)</code> 之间的<strong>残差 (Residual)</strong> 为<code>e_i = y_i - f(x_i)</code>。最佳的拟合函数，应该是使得<strong>残差平方和(Sum of Squared Residuals, SSR)</strong> 最小的那一个。</p><p><span class="math display">\[ SSR = \sum_{i=1}^{n} e_i^2 =\sum_{i=1}^{n} (y_i - f(x_i))^2 \rightarrow \min \]</span></p><p>选择平方作为度量，不仅因为其良好的数学性质（可导、凸性），也因为它对较大的误差（离群点）赋予了更高的“惩罚权重”。</p><h3 id="拟合模型的选择与实现"><strong>3.2拟合模型的选择与实现</strong></h3><ul><li><p><strong>线性拟合 (Linear Fitting)</strong>：</p><ul><li><p><strong>模型</strong>：假定函数形式为线性关系。</p></li><li><p><strong>求解</strong>：通过对SSR关于所有待定参数（a, b,...）求偏导并令其为零，可以推导出一组线性方程组（称为<strong>正规方程组,Normal Equations</strong>），解此方程组即可得到最佳的参数估计。</p></li></ul></li><li><p><strong>多项式拟合 (Polynomial Fitting)</strong>：</p><ul><li><p><strong>模型</strong>：假定函数形式为多项式，如<code>f(x) = a_nx^n + \dots + a_1x + a_0</code>。</p></li><li><p><strong>求解</strong>：其最小二乘解同样可以归结为求解一个正规方程组。</p></li></ul></li><li><p><strong>非线性拟合 (Nonlinear Fitting)</strong>：</p><ul><li><p><strong>模型</strong>：当变量间的关系基于理论推导呈现非线性时（如指数、对数、幂函数等），需要进行非线性拟合。</p></li><li><p><strong>策略</strong>：</p><ol type="1"><li><p><strong>线性化</strong>：通过变量替换，巧妙地将非线性关系转化为线性关系。例如，对<code>y = ae^&#123;bx&#125;</code> 两边取对数得到<code>ln(y) = ln(a) + bx</code>，即可对 <code>(x, ln(y))</code>进行线性拟合。这是一种常用且高效的技巧。</p></li><li><p><strong>迭代优化</strong>：对于无法线性化的复杂模型，则需采用数值优化算法（如梯度下降法、Levenberg-Marquardt算法）进行迭代搜索，逐步逼近使SSR最小的参数组合。</p></li></ol></li></ul></li></ul><h3 id="拟合优度评价"><strong>3.3 拟合优度评价</strong></h3><p>模型拟合完成后，必须对其优劣进行定量评价。</p><ul><li><p><strong>决定系数 (R-squared, R²)</strong>：</p><ul><li><p><strong>定义</strong>：衡量模型能够解释因变量总变异的百分比。其值介于0和1之间，越接近1，说明模型的解释能力越强。</p><p><span class="math display">\[ R^2 = 1 - \frac{\sum (y_i -f(x_i))^2}{\sum (y_i - \bar{y})^2} = 1 - \frac{SSR}{SST}\]</span></p></li></ul></li><li><p><strong>修正决定系数 (Adjusted R²)</strong>：</p><ul><li><strong>目的</strong>：R²有一个缺陷，即增加模型复杂度（如增加多项式次数）会使其值只增不减。修正R²在R²的基础上引入了对模型参数数量的惩罚，因此在比较不同复杂度的模型时，它是一个更公允的指标。</li></ul></li></ul><h2 id="总结"><strong>4. 总结</strong></h2><p>插值与拟合是数据分析的基石。<strong>插值</strong>是基于“<strong>信任数据</strong>”的哲学，在点与点之间构建精确的桥梁；而<strong>拟合</strong>是基于“<strong>怀疑数据</strong>”的哲学，在嘈杂的迷雾中寻找潜在的真理。在实践中，若数据来源可靠、误差极小，且目标是局部估计，插值（尤其是样条插值）是首选。反之，若数据存在测量误差，且目标是探索全局规律或进行预测，则必须采用拟合（以最小二乘法为核心）的方法。深刻理解二者的区别与适用场景，是进行有效定量分析的前提。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>综述概要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微分方程与差分方程方法综述</title>
    <link href="/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0/"/>
    <url>/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B8%8E%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%96%B9%E6%B3%95%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文旨在系统梳理微分方程与差分方程这两种重要的动态过程建模方法。首先，从宏观角度介绍动态过程建模的背景与方法选择，随后分别深入探讨差分方程和微分方程的基本概念、建模依据、在种群变化、污染物扩散、产品销量等领域的具体应用案例。差分方程适用于刻画具有离散时间特性的阶段性变化过程，而微分方程则精于描绘连续、平滑的动态演变。重点阐述两类方程的求解思路（解析解、数值解）与定性分析方法，特别是平衡点与稳定性的判断，并强调其在实际问题预测与干预中的指导意义。最后，通过传染病模型等案例展示了如何考虑脉冲效应、时滞因素以及不同维度（时间和空间）的复杂模型构建与持续改进方向。</p><h2 id="动态过程建模概述"><strong>1. 动态过程建模概述</strong></h2><h3 id="概念"><strong>1.1 概念</strong></h3><p>我们之前讨论的很多模型（如线性回归）是在静态分析事物的内在组成，能清晰地展示事物在某一瞬间的内部结构和关系。但世界是运动的，很多时候我们更关心的是一部事物是如何随时间或空间演变的。当我们的研究对象其特征在不断变化时，动态过程建模就该登场了。</p><h3 id="建模方法选择"><strong>1.2 建模方法选择</strong></h3><h4id="路线一掌握充足数据但机理不清黑箱方法"><strong>路线一：掌握充足数据，但机理不清（“黑箱”方法）</strong></h4><p><strong>方法</strong>：数据拟合、统计回归。</p><p>我们不知道一个机器内部是怎么工作的，但我们有很多组“输入-输出”数据。我们的任务就是找一个数学函数，让它能最大程度地模仿这个机器的行为。我们不关心函数本身有没有物理意义，只要它能“以假乱真”就行。</p><p><strong>常用方法</strong>：</p><p><strong>多项式拟合</strong>：最简单直接的工具，但有可能因为追求拟合效果导致过拟合。</p><p><strong>其他拟合类型</strong>：要根据数据的“长相”来选工具：</p><ul><li><p>看到数据增速越来越慢，像快吃饱了的人，试试<strong>对数拟合</strong>。</p></li><li><p>看到数据像滚雪球一样越滚越快，试试<strong>指数拟合</strong>。</p></li><li><p>看到数据呈现“中间高、两边低”的钟形，试试<strong>高斯拟合</strong>。</p></li><li><p>看到数据有周期性波动，<strong>傅里叶级数拟合</strong>是你的不二之选。</p></li></ul><p><strong>时间序列分析</strong>：当数据看起来杂乱无章，但又隐约感觉有某种惯性（今天的数据和昨天有关），就需要用到更高级的时间序列模型（如ARIMA）。</p><p><strong>统计回归</strong>：本质也是拟合，但它更“诚实”地承认了误差项<code>e</code>的存在，并有一整套理论来检验模型和系数的显著性。</p><p><strong>路线二：了解详细机理，但数据不足（“白箱”方法）</strong></p><p><strong>方法</strong>：微分/差分方程、随机过程。</p><p>我们虽然没有太多数据，但我们知道它内部的运行规律。我们的任务就是根据这些物理、化学或生物学定律，写出描述其动态行为的方程。</p><p>这种方法建立的模型通常更稳健，尤其适合做<strong>长期预测</strong>，因为它抓住了事物发展的本质规律，而不是表面的数据模式。</p><hr /><h2 id="差分方程方法建模"><strong>2. 差分方程方法建模</strong></h2><h3 id="差分方程基本概念"><strong>2.1 差分方程基本概念</strong></h3><p><strong>适用场景</strong>：当事物的变化是<strong>一步一步、跳跃式</strong>的，有明显的阶段性时，就用差分方程。</p><p>我们不关心每一帧之间发生了什么，只关心第n帧和第n+1帧（或前几帧）之间的关系。比如，我们按“年”来统计人口，按“天”来更新股票收盘价，按“繁殖周期”来计算种群数量。</p><h3 id="差分方程建模依据"><strong>2.2 差分方程建模依据</strong></h3><p>核心就是“<strong>承前启后</strong>”，用过去的状态来描述现在的状态。</p><ul><li><p><strong>xn+1​=f(xn​)</strong>：最简单的模型，认为“明天”只和“今天”有关。</p></li><li><p><strong>xn+2​=f(xn​,xn+1​)</strong>：更复杂一点，认为“后天”不仅和“明天”有关，还和“今天”有关（考虑了“惯性”）。</p></li></ul><h3 id="差分方程应用案例"><strong>2.3 差分方程应用案例</strong></h3><h5 id="种群模型一个逐步完善的思考过程"><strong>2.3.1种群模型（一个逐步完善的思考过程）</strong></h5><ol type="1"><li><p><strong>模型V1.0：理想国模型 (Malthus模型)</strong></p><ul><li><p><strong>思想</strong>：假设在一个资源无限的“理想国”里，种群的增长只取决于固定的生育率和死亡率。</p></li><li><p><strong>问题</strong>：这个模型太天真了。它预测的结果要么是指数爆炸，要么是指数灭亡，这在现实中几乎不可能持续发生。</p></li></ul></li><li><p><strong>模型V2.0：现实世界模型 (Logistic模型)</strong></p><ul><li><p><strong>思想</strong>：引入“<strong>资源约束</strong>”和“<strong>竞争</strong>”的概念。当种群数量太多时，食物不够吃，生存空间变小，导致生育率下降，死亡率上升。</p></li><li><p><strong>结论</strong>：这个模型高级多了。它预测种群数量会趋向于一个环境能承载的<strong>稳定上限</strong>，这非常符合自然规律。但它也揭示了更复杂的现象：根据参数不同，种群可能稳定在上限，也可能围绕上限做周期性波动，甚至进入不可预测的<strong>混沌(Chaos)</strong> 状态。</p></li></ul></li><li><p><strong>模型V3.0：考虑代际差异</strong></p><ul><li><strong>思想</strong>：引入“<strong>时滞 (TimeLag)</strong>”的概念。很多生物不是一出生就能繁殖的，需要一个成长期。今天的出生率，其实是由k个周期前的成年个体数量决定的。</li></ul></li><li><p><strong>模型V4.0, V5.0：考虑更多现实因素</strong></p><ul><li><p><strong>性别因素</strong>：能生孩子的只有雌性，引入雌性比例<code>s</code>可以让模型更精确。</p></li><li><p><strong>年龄结构(Leslie模型)</strong>：这是个巨大的进步。它不再把种群看成一个单一的数字，而是看成一个向量，向量的每个元素代表一个年龄段的人口。通过一个“<strong>状态转移矩阵M</strong>”，我们可以精确地描述整个种群年龄结构的代际演变。</p></li></ul></li><li><p><strong>模型V6.0：考虑突发冲击 (脉冲效应)</strong></p><ul><li><p><strong>思想</strong>：现实世界充满了“意外”。这些意外可以是定期的（如每年固定季节捕鱼），也可以是因状态而触发的（如蝗虫数量一旦超过某个阈值，就立刻开始大规模喷洒农药）。</p></li><li><p><strong>建模</strong>：通过引入一个开关函数（T(n)或S(x)），我们可以在方程中模拟这些“脉冲式”的干预。这对于模拟传染病防治、经济调控等问题至关重要。</p></li></ul></li></ol><h4 id="差分方程的稳定性"><strong>2.4 差分方程的稳定性</strong></h4><ul><li><p><strong>核心问题</strong>：当时间趋于无穷时，这个系统最终会走向何方？是稳定在一个点上，还是无限增长，还是来回振荡？</p></li><li><p><strong>平衡点</strong>：系统静止不动的那个状态点，即<code>x* = f(x*)</code>。它是系统可能趋向的“归宿”。</p></li><li><p><strong>稳定性判断</strong>：</p><ul><li><p><strong>用人话讲</strong>：在平衡点附近，我们轻轻地推它一下，它是会自己滚回平衡点（<strong>稳定</strong>），还是会越滚越远（<strong>不稳定</strong>）？</p></li><li><p><strong>数学工具</strong>：这个“推一下”的效应，就由导数<code>|f'(x*)|</code> 来刻画。</p><ul><li><code>|f'(x*)| &lt; 1</code>：说明扰动会被逐渐“吸收”，系统会收敛回平衡点，是稳定的。</li><li><code>|f'(x*)| &gt; 1</code>：说明扰动会被“放大”，系统会远离平衡点，是不稳定的。</li></ul></li></ul></li></ul><hr /><h2 id="微分方程方法建模"><strong>3. 微分方程方法建模</strong></h2><h4 id="微分方程概述"><strong>3.1 微分方程概述</strong></h4><p><strong>适用场景</strong>：当事物的变化是<strong>光滑、连续</strong>的时候，就用微分方程。</p><h4 id="微分方程主要内容"><strong>3.2 微分方程主要内容</strong></h4><ol type="1"><li><p><strong>求解析解</strong>：就像得到一个“万能公式”，可以算出任何时刻的状态。但这是可遇不可求的，只有极少数简单的方程能做到。</p></li><li><p><strong>定性分析</strong>：退而求其次。我们虽然没有万能公式，但可以通过分析方程本身，画出解的“<strong>草图</strong>”（相图），了解系统的长期行为、平衡点、是否存在周期性等。这在很多时候比一个具体的数值解更有洞察力。</p></li><li><p><strong>求数值解</strong>：最实用、最强大的方法。给定初始条件和参数，用计算机一步步地“迭代”出任意时刻的近似解。这就像我们虽然不知道火箭的精确轨迹方程，但可以算出它在第1秒、第1.01秒、第1.02秒...的位置，连起来就是它的轨迹。</p></li></ol><h4 id="建立微分方程模型的依据"><strong>3.4建立微分方程模型的依据</strong></h4><ul><li><p>核心是找到“<strong>变化率</strong>”和“<strong>状态</strong>”之间的关系。</p></li><li><p><strong>经典例子</strong>：<code>dx/dt = kx</code>。这句话的翻译是：“某个东西x的变化速度，正比于它本身的大小”。这可以描述无约束下的种群增长、放射性元素衰变、复利计算等众多现象。</p></li></ul><h4 id="微分方程案例"><strong>3.5 微分方程案例</strong></h4><ol type="1"><li><p><strong>新产品销量变化模型 (Logistic模型)</strong>：</p><ul><li><strong>机理</strong>：销量增长的动力来自两方面：一是已购买者的“口碑宣传”（与已售数量<code>x</code>成正比），二是潜在购买者的“市场需求”（与未售数量<code>K-x</code>成正比）。两者一乘，就得到了经典的Logistic模型。</li></ul></li><li><p><strong>人口模型（按年龄段划分）</strong>：</p><ul><li>这是Leslie模型的连续版本。我们不再按“年”来更新，而是考察每一瞬间，有多少人从“青年”变成“中年”，又有多少人从“中年”变成“老年”。</li></ul></li><li><p><strong>异常因素影响</strong>：和差分方程类似，微分方程也可以加入脉冲、时滞等复杂因素，使其更贴近现实。</p></li><li><p><strong>数理方程 (偏微分方程, PDE)</strong>：</p><ul><li><p>当我们的研究对象不仅随<strong>时间</strong>变化，还随<strong>空间位置</strong>变化时，就需要用偏微分方程。</p></li><li><p><strong>用人话讲</strong>：我们不仅关心一个池塘里污染物的<strong>总量</strong>随时间的变化，还关心在池塘的<strong>不同位置</strong>（x,y,z），污染物<strong>浓度</strong>随时间的变化。这就需要用到偏导数。</p></li></ul></li></ol><h4 id="微分方程的定性分析"><strong>3.6 微分方程的定性分析</strong></h4><ul><li><p><strong>核心思想</strong>：与差分方程类似，也是找<strong>平衡点</strong>，并判断其<strong>稳定性</strong>。</p></li><li><p><strong>判断方法</strong>：对于二维系统，我们通过分析线性近似的<strong>雅可比矩阵</strong>在平衡点处的<strong>特征值</strong>来判断。特征值的实部决定了系统在那个方向上是“收敛”还是“发散”。当所有特征值的实部都为负时，平衡点是稳定的。</p></li></ul><h4 id="持续改进深入讨论以传染病模型为例"><strong>3.7持续改进、深入讨论（以传染病模型为例）</strong></h4><p>这是一个极佳的范例，展示了建模是一个“<strong>不断迭代、逼近现实</strong>”的过程。</p><ol type="1"><li><p><strong>从SIR经典模型出发</strong>：这是一个最简化的“骨架”。</p></li><li><p><strong>增加人口流动</strong>：变成SIRS，考虑康复者会再次丧失免疫力。</p></li><li><p><strong>增加现实约束</strong>：考虑出生和死亡，让总人口不再是固定的。</p></li><li><p><strong>增加时间特征</strong>：考虑潜伏期（SEIR模型）、考虑节假日的脉冲效应。</p></li><li><p><strong>增加社会干预</strong>：考虑疫苗接种、隔离措施。</p></li><li><p><strong>增加生物特性</strong>：考虑病毒变异、考虑垂直感染。</p></li><li><p><strong>增加随机性</strong>：用随机微分方程来描述传染率等参数受环境噪声的随机扰动。</p></li></ol><p>通过这样一步步地“打补丁”，我们的模型就能从一个粗糙的玩具，变成一个能为公共卫生决策提供参考的强大工具。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>综述概要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计与数据挖掘综述</title>
    <link href="/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%BB%BC%E8%BF%B0/"/>
    <url>/2025/08/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E7%BB%9F%E8%AE%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文系统梳理了统计学与数据挖掘的基本概念、方法论及其在数据分析中的应用。首先从数据理解、准备与建模流程入手，介绍了分类与回归模型的常用评价指标。随后，对集成学习方法（Bagging、Boosting、Stacking、Blending）进行了比较与总结，阐述了其在提升模型性能与鲁棒性方面的作用。在统计分析部分，涵盖了假设检验、列联分析、相关分析、回归分析以及方差分析等核心方法，强调了它们在数据关系探索与显著性验证中的价值。文章进一步综述了预测建模、分类建模、聚类分析、关联与序列模式挖掘，以及Web数据挖掘的典型技术与应用场景。整体而言，本综述将统计学的严谨方法论与数据挖掘的实用算法框架相结合，为理解和解决实际问题提供了系统化的思路，对数学建模及跨学科数据分析研究具有重要的参考价值。</p><h2 id="绪论">1. 绪论</h2><h3 id="概念">1.1 概念</h3><p>数据挖掘从大型数据库中发现数据所表现出的特征，从中归纳得出新知识新方法。</p><p>统计学是研究如何测度、收集、整理和分析反映客观现象有关信息的数据，以帮助人们正确认识客观世界数量规律的方法论科学。包括数据采集、数据处理、数据分析的各种统计学方法。</p><h3 id="方法论">1.2 方法论</h3><p>有一套跨行业数据挖掘标准，具体步骤为：</p><ol type="1"><li><p>商业理解，就是了解国内外研究现状；换句话讲就是明确我们进行数据分析的要求与最终目的是什么，明确数据挖掘能在其中为我带来什么。具体到数学竞赛中，往往目的就很明确了，要做的就是查找相关文献来了解相关的方法，同时进一步明确该方法的复现难度，提升空间。</p></li><li><p>数据理解，即了解数据需要进行如何进行预处理；了解数据完整性、正确性，初步掌握数据可能有什么特征，适合用什么样的建模方法</p></li><li><p>数据准备，即对数据进行预处理。</p></li><li><p>选择合适的建模方法，在确定参数时，可以手工调参，也可采用网格式搜索，即遍历给出的超参数组合来设定模型并训练，或者用随机搜索、贝叶斯搜索法，注意提前熟悉相关内容，预先准备好程序代码。如果不知道哪种建模方法更好，可以训练多个模型，通过一定的结合策略，以集成学习的形式得到一个较好的集成模型。</p></li><li><p>评价模型成效；</p></li><li><p>输出建模结果。</p></li></ol><h3 id="模型评价参数">1.3 模型评价参数</h3><p>当我们建立好一个模型后，无论是用于分类还是预测，我们都需要一套客观的标准来衡量它的性能。</p><h4 id="分类变量预测模型-classification-metrics">分类变量预测模型(Classification Metrics)</h4><p>这类模型预测的是类别，比如“是/否”、“A/B/C类”、“有病/没病”。评价它们时，我们通常会先得到一个叫<strong>混淆矩阵(Confusion Matrix)</strong>的东西，它就是一个表格，总结了模型“猜对”和“猜错”的各种情况。</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: center;"><strong>预测为正例</strong></th><th style="text-align: center;"><strong>预测为负例</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>实际为正例</strong></td><td style="text-align: center;">真阳性 (TP)</td><td style="text-align: center;">假阴性 (FN)</td></tr><tr><td style="text-align: left;"><strong>实际为负例</strong></td><td style="text-align: center;">假阳性 (FP)</td><td style="text-align: center;">真阴性 (TN)</td></tr></tbody></table><ul><li><strong>正例 (Positive)</strong>:通常是我们更关心的那个类别，比如“有病”、“是垃圾邮件”。</li><li><strong>TP (True Positive)</strong>:猜对了，本来是正例，模型也预测是正例。</li><li><strong>FN (False Negative)</strong>:猜错了，本来是正例，模型却预测是负例。（<strong>漏报</strong>）</li><li><strong>FP (False Positive)</strong>:猜错了，本来是负例，模型却预测是正例。（<strong>误报</strong>）</li><li><strong>TN (True Negative)</strong>:猜对了，本来是负例，模型也预测是负例。</li></ul><p>基于这个矩阵，我们有了下面这些指标：</p><ul><li><p><strong>准确率 (Accuracy)</strong></p><ul><li><p><strong>定义：</strong>所有样本中，被模型正确分类的样本所占的比例。</p></li><li><p><strong>公式：</strong><code>(TP + TN) / (TP + TN + FP + FN)</code></p></li><li><p><strong>局限性：</strong>在<strong>样本不均衡</strong>的情况下，准确率是个“骗子”。比如，一个癌症检测模型，在1000个样本里只有1个是真病人。如果模型偷懒，把所有人都预测为“没病”，那它的准确率高达99.9%，看起来很棒，但实际上一个病人都没找出来，完全没用。</p></li></ul></li><li><p><strong>查准率 (Precision)</strong></p><ul><li><p><strong>定义：</strong>模型预测为“正例”的样本中，有多少是真正的“正例”。</p></li><li><p><strong>公式：</strong> <code>TP / (TP + FP)</code></p></li><li><p><strong>应用场景：</strong> 当<strong>误报 (FP)的代价很高</strong>时，我们希望查准率高。比如垃圾邮件检测，你绝不希望一封重要的工作邮件被误判为垃圾邮件(FP)，宁可放过一些垃圾邮件。</p></li></ul></li><li><p><strong>查全率 (Recall) / 召回率</strong></p><ul><li><p><strong>定义：</strong>所有真正的“正例”中，有多少被模型成功地找了出来。</p></li><li><p><strong>公式：</strong> <code>TP / (TP + FN)</code></p></li><li><p><strong>应用场景：</strong> 当<strong>漏报 (FN)的代价很高</strong>时，我们希望查全率高。比如传染病筛查或癌症诊断，漏掉一个真正的病人(FN) 后果不堪设想，宁可把一些健康的人叫来复查 (FP)。</p></li></ul></li><li><p><strong>F1 分数 (F1-Score)</strong></p><ul><li><p><strong>定义：</strong> 查准率和查全率的调和平均数。</p></li><li><p><strong>公式：</strong><code>2 * (Precision * Recall) / (Precision + Recall)</code></p></li><li><p>查准率和查全率往往是一对矛盾体，一个高了另一个可能就低了。F1分数就是想找一个平衡点，它同时兼顾了这两个指标，只有当两者都比较高时，F1分数才会高。它是一个更综合、更鲁棒的评价指标。</p></li></ul></li></ul><h4 id="连续变量预测模型-regression-metrics">连续变量预测模型(Regression Metrics)</h4><p>这类模型预测的是一个具体的数值，比如房价、气温、股票价格。</p><ul><li><p><strong>均方误差 (Mean Squared Error, MSE)</strong></p><ul><li><p><strong>定义：</strong>就是方差，预测值与真实值之差的平方的平均值。</p></li><li><p><strong>公式：</strong> (1/n) * Σ(y_true - y_pred)²</p></li><li><p><strong>局限性</strong>：对偏差过大的值较为敏感</p></li></ul></li><li><p><strong>均方根误差 (Root Mean Squared Error, RMSE)</strong></p><ul><li><p><strong>定义：</strong> 平方差，就是对MSE开个根号。</p></li><li><p><strong>公式：</strong> <code>sqrt(MSE)</code></p></li><li><p>开根号的好处是，它的<strong>量纲和原始数据是一样</strong>的。如果你的模型预测的是房价（单位：万元），那么RMSE的单位也是“万元”，这样你就能直观地理解“模型平均预测误差大概在xx万元”这个量级，解释性比MSE好。</p></li></ul></li><li><p><strong>平均绝对误差 (Mean Absolute Error, MAE)</strong></p><ul><li><p><strong>定义：</strong>预测值与真实值之差的绝对值的平均值。</p></li><li><p><strong>公式：</strong><code>(1/n) * Σ|y_true - y_pred|</code></p></li><li><p><strong>用人话讲：</strong>它同样衡量预测的离谱程度，但因为它用的是绝对值而不是平方，所以它对那些特别离谱的异常值<strong>没有那么敏感</strong>，显得更“温和”，更能反映一般情况下的预测误差。</p></li></ul></li><li><p><strong>决定系数 (R-squared, R²)</strong></p><ul><li><p><strong>定义：</strong>一个衡量模型拟合优度的指标，表示模型的预测结果能解释因变量变化的百分比。</p></li><li><p><strong>公式：</strong><code>1 - (Σ(y_true - y_pred)² / Σ(y_true - y_mean)²)</code></p></li><li><p><strong>用人话讲：</strong>它的值在0到1之间。可以这样理解：如果我们不用任何模型，直接猜所有样本的值都是平均数（<code>y_mean</code>），这会产生一个总误差。而我们的模型产生的误差是<code>Σ(y_true - y_pred)²</code>。R²衡量的就是“<strong>我们的模型比瞎猜（猜平均数）好多少</strong>”。</p><ul><li><strong>R² = 1</strong>：完美模型，预测值和真实值完全一样。</li><li><strong>R² = 0</strong>：模型和瞎猜一样烂。</li><li><strong>R² &lt; 0</strong>：模型比瞎猜还要烂，简直是帮倒忙。</li></ul></li><li><p>它提供了一个与量纲无关的、非常直观的“模型好坏”的百分比度量。</p></li></ul></li></ul><h3 id="集成学习方法">1.4 集成学习方法</h3><p>集成学习的方法就是多种模型来组合成一个大模型，来提高整体模型店准确性与鲁棒性，具体的话之前的第二次校赛拿几种回归分析组合为一个大分（雾）析就是这样的。</p><p>集成学习主要方法归类为下述几种：</p><h4 id="装袋bagging">装袋（Bagging）</h4><p>这是一种并行集成方法，‌通过构造多个独立的模型，‌然后通过投票、平均或加权的方式构造强学习器。‌</p><p><strong>随机森林</strong>是Bagging的一个典型应用，‌它通过构建多个决策树并通过投票或平均来做出最终预测。‌</p><h4 id="提升boosting">提升（Boosting）</h4><p>这是一种串行集成方法，‌利用基学习器之间串行的方式进行构造强学习器。‌它通过调整数据点的权重来训练一系列弱学习器，赋予预测错误数据更高权重，使得后继学习器更试图纠正前一个学习器的错误。‌AdaBoost是一种典型的Boosting方法。</p><h4 id="堆叠stacking">堆叠（Stacking）</h4><p>结合了Bagging和Boosting两种方法的集成方式。‌将第一层模型的输出作为第二层模型的输入，‌通过模型对原数据的堆叠进行建模，‌提高模型的泛化能力。‌</p><h4 id="融合blending">融合（Blending）</h4><p>是一种集成学习方法，‌它通过结合多个模型的预测结果来提高预测的准确性和稳定性。‌这种方法主要分为两个阶段：‌第一阶段是训练多个基模型，‌这些基模型可以是同质的（‌使用相同类型的算法）‌或异质的（‌使用不同类型的算法）‌；‌第二阶段是使用第一阶段模型在验证集上的输出结果作为特征，‌训练一个元模型（‌通常是线性回归模型）‌，‌最终利用这个元模型对测试集进行预测。‌优点包括：‌易于理解。‌可扩展性高：‌Blending的模型框架具有较高的可扩展性，‌可以根据需要添加或替换基模型。‌缺点‌则为实现难、计算量大，感觉在国赛中现在我的水平我是不会用的。</p><h2 id="数据准备与探索性分析">2. 数据准备与探索性分析</h2><h3 id="统计学简介"><strong>2.1 统计学简介</strong></h3><p>定义：收集、分析、表述和解释数据的科学。</p><p>统计研究过程：收集、整理、分析、解释数据。</p><p>基本概念：总体、样本、参数、统计量。</p><h3 id="统计数据的分类"><strong>2.2 统计数据的分类</strong></h3><p><strong>按计量层次</strong>：定类数据、定序数据、定距型数据。</p><p><strong>按收集方法</strong>：观测数据、试验数据。</p><p><strong>按时间状况</strong>：截面数据、时间序列数据。</p><h3 id="描述统计量"><strong>2.3 描述统计量</strong></h3><p><strong>集中趋势</strong>：均值、中位数、众数、总和（及其关系与特点）。</p><p><strong>离散趋势</strong>：标准差、方差、最小值、最大值、极差、均值标准误。</p><p><strong>形状</strong>：偏度系数（Skewness）、峰度系数（Kurtosis）及其对分布的解释。</p><p>标准分数（Standard Score）及其作用。</p><h3 id="数据可视化"><strong>2.4 数据可视化</strong></h3><p>可视化简介：数据视觉表现形式的科技研究，发展阶段（科学可视化、信息可视化、数据可视化、可视分析）。</p><p>DIKW层次模型：数据 -&gt; 信息 -&gt; 知识 -&gt; 智慧的转化过程。</p><p><strong>统计图类型</strong>：</p><p>条形图：反映分类数据频数分布。</p><p>线图：反映变量变化趋势（适用于连续变量）。</p><p>箱形图：显示原始数据分布（最大值、最小值、中位数、四分位数），观察分布形状。</p><p>散点图：展示两变量间数量关系和趋势。</p><p>直方图：反映分组数据的频数分布。</p><p>P-P图 / Q-Q图：检验数据是否服从特定理论分布（如正态分布）。</p><h3 id="探索性数据分析eda">2.5<strong>探索性数据分析（EDA）</strong></h3><h4 id="介绍">介绍</h4><p>它是一种数据统计分析方法，通过可视化图表和统计量表格，在没有太多先验假设的情况下，探索数据的内在结构和规律，提取关键信息。</p><h4 id="分析目的">分析目的</h4><ul><li><p><strong>数据理解和预处理：</strong>帮助你弄清数据的含义和结构，发现异常值、缺失值、重复值，以便进行数据清洗和整理。</p></li><li><p><strong>特征描述和关系分析：</strong>掌握数据的重要信息，比如变量的分布和它们之间的关系 。</p></li><li><p><strong>为后续分析做准备：</strong>帮助你决定是否需要进行数据变换、使用非参数方法或建立线性回归模型，从而将业务问题转化为可行的数据分析问题。</p></li></ul><h4 id="分析内容">分析内容</h4><ol type="1"><li><p><strong>数据筛查：</strong>检查数据是否存在缺失值、异常值、重复值，判断样本是否均衡，以及是否需要抽样、增加新的变量或变量转换。</p></li><li><p><strong>数据特征描述：</strong></p></li></ol><ul><li><p><strong>连续变量：</strong>使用平均值、中位数、标准差等统计量，以及直方图、箱线图等图表来描述。</p></li><li><p><strong>离散变量（无序型和有序型）：</strong>使用频数、占比等统计量，以及频数分布表、条形图、饼图来描述 。</p></li></ul><ol start="3" type="1"><li><strong>变量关系：</strong></li></ol><p><strong>连续变量vs.连续变量</strong></p><p>这个属于相关分析</p><p>图表：散点图、相关系数矩阵、热图</p><p>量化指标：Pearson、Spearman、Kendall相关系数。具体可见本站相关文章</p><p><strong>离散变量vs.离散变量</strong></p><p>图表：两两之间用交叉列联表、复式条形图；多个离散变量中用网格图</p><p>有序型离散变量使用相关分析，指标就是那些相关系数</p><p>无序型离散变量使用列连分析，量化指标是 <spanclass="math inline">\(\varphi\)</span> 相关系数、 <spanclass="math inline">\(V\)</span> 相关系数，列联相关系数</p><p><strong>离散变量vs.连续变量</strong></p><p>图像：直方图、箱线图、小提琴图</p><p>量化分析：t检验、方差分析等方法进行量化分析</p><p>量化指标：独立样本t检验中t统计量以及相应的p值，单多因素方差分析的统计量</p><ol start="4" type="1"><li>数据正态性检验</li></ol><p>直方图：看图形与钟形曲线吻合程度</p><p>箱线图：看图形是否对称</p><p>P-P图：正态分布，数据的累积比例与正态分布累积比例基本保持一致。将数据累积比例为X轴，对应正态分布累积比例为Y轴，作散点图。若各点近似分布在一条直线上,则数据符合指定分布。</p><p>Q-Q图：比较数据的分位数与某个理论分布的分位数是否匹配。</p><ol start="5" type="1"><li>检验数据的分布类型</li></ol><p>夏皮罗－威尔克检验（Shapiro-Wilk test）</p><p>科尔莫戈罗夫－斯米尔诺夫检验（Kolmogorov-Smirnov test）</p><p>6.数据变换</p><p>box-cox变换</p><h4 id="用以描述的统计量"><strong>用以描述的统计量</strong></h4><ul><li><p><strong>集中趋势：</strong></p><ul><li><p><strong>均值（Mean）：</strong> 最常用，但容易受极端值影响。</p></li><li><p><strong>中位数（Median）：</strong>数据排序后中间的那个数，不受极端值影响，适用于所有分布 。</p></li><li><p><strong>众数（Mode）：</strong>出现频率最高的数，不受极端值影响，可以有多个 。</p></li></ul></li><li><p><strong>离散趋势：</strong></p><ul><li>描述数据分散程度，比如标准差、方差、极差等 。</li></ul></li></ul><h4 id="可视化图表"><strong>可视化图表</strong></h4><ul><li><p><strong>条形图（Bar chart）：</strong>用长短表示数据类别频数，适用于离散变量 。</p></li><li><p><strong>线图（Line chart）：</strong>用线条升降表示变量随时间的变化趋势，适用于连续变量 。</p></li><li><p><strong>箱形图（Box plot）：</strong>用箱子和线段展示数据的分布，包括最大值、最小值、中位数和四分位数，可以直观地看出数据的对称性。</p></li></ul><h2 id="主要分析方法">3. 主要分析方法</h2><h3 id="假设检验-hypothesis-testing"><strong>3.1 假设检验 (HypothesisTesting)</strong></h3><p>我们有一个怀疑或主张（比如“这个新药有效”），但我们不能直接下结论。我们必须先设定一个原假设H0，通常代表“无效”或“没变化”，并假定它是“无辜的”。然后，我们收集样本数据，看看这些证据是否足够强大，能够“毫无疑义地”（在某个概率水平上）推翻这个“无辜”的假定。</p><h4 id="步骤-the-steps-of-the-trial"><strong>步骤 (The Steps of theTrial)</strong>：</h4><ol type="1"><li><strong>提出假设 (State the Hypotheses)</strong>：</li></ol><p><strong>原假设 (Null Hypothesis,H0)</strong>：也叫“零假设”，代表“现状”或“没有效应”。它总是包含等号（=,≤,≥）。在法庭上，这就是“被告无罪”。例如：<code>H0: 新药的平均疗效 = 安慰剂的平均疗效</code>。</p><p><strong>备择假设 (Alternative Hypothesis, H1 或Ha)</strong>：这是我们想要证明的、与原假设对立的观点。它总是包含不等号（≠,&lt;,&gt;）。在法庭上，这就是“被告有罪”。例如：<code>H1: 新药的平均疗效 ≠ 安慰剂的平均疗效</code>。</p><ol start="2" type="1"><li><strong>规定显著性水平 α (Set the SignificanceLevel)</strong>：</li></ol><p>在审判开始前，我们要先设定一个“定罪标准”。这个标准就是显著性水平α，通常取 0.05。它代表我们愿意承担的“判错案”的风险上限。α = 0.05意味着，我们允许有5%的概率冤枉一个“好人”（即错误地推翻了一个实际上成立的H0）。</p><ol start="3" type="1"><li><strong>确定并计算检验统计量 (Calculate the TestStatistic)</strong>：</li></ol><p>这是将“证据”（样本数据）量化成一个单一数值的过程。这个数值衡量了我们的样本结果与原假设H0之间的差距有多大。不同的问题需要用不同的检验统计量（如Z,t, χ², F）。</p><ol start="4" type="1"><li><strong>作出统计决策 (Make the Decision)</strong>：</li></ol><p>这是最后“宣判”的环节。我们有两种方法：<strong>临界值法</strong>：将计算出的检验统计量与一个“临界值”（根据α查表得出）进行比较。如果统计量落入了“拒绝域”，就拒绝H0。</p><p><strong>P值法 (P-valueApproach)</strong>：这是现代统计软件中最常用的方法。计算出一个<strong>p值</strong>，它代表“<strong>如果原假设H0是真的，我们能观测到现有样本结果（或更极端结果）的概率</strong>”。然后将p值与α比较：</p><p>如果 <strong>p ≤α</strong>：说明在H0成立的前提下，发生我们观测到的事件是个小概率事件。我们有理由怀疑H0的真实性，因此<strong>拒绝原假设H0</strong>。</p><p>如果 <strong>p &gt;α</strong>：说明在H0成立的前提下，我们的样本结果很正常，不值得大惊小怪。我们<strong>没有足够证据拒绝原假设H0</strong>。</p><p><strong>两类错误 (Two Types of Errors)</strong>：</p><p><strong>第一类错误 (Type I Error,弃真错误)</strong>：原假设H0本来是真的，但我们却错误地拒绝了它。其发生的概率就是我们设定的<strong>α</strong>。</p><p><strong>第二类错误 (Type II Error,取伪错误)</strong>：原假设H0其实是假的，但我们却没有足够的证据拒绝它，错误地接受了它。其发生的概率用<strong>β</strong> 表示。</p><h4 id="常见检验类型"><strong>常见检验类型</strong></h4><h5 id="一个正态总体参数检验">1. 一个正态总体参数检验</h5><p><strong>均值检验 (σ 已知) - Z检验</strong><strong>问题</strong>：“我知道全国男性的平均身高是175cm，标准差σ是5cm。我随机抽了我们学校100个男生，算出平均身高是177cm。我们学校的男生比全国更高吗？”</p><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ Z = \frac{\bar{x} - \mu_0}{\sigma /\sqrt{n}} \]</span></p><p>其中 <span class="math inline">\(\bar{x}\)</span> 是样本均值，<spanclass="math inline">\(\mu_0\)</span> 是假设的总体均值，<spanclass="math inline">\(\sigma\)</span> 是总体标准差，<code>n</code>是样本量。</p><p><strong>均值检验 (σ 未知) - t检验</strong></p><p><strong>问题</strong>：这是更常见的情况。“我想知道一批新生产的灯泡的平均寿命是否是800小时。我抽了25个灯泡，测出平均寿命是790小时，样本标准差s是30小时。”</p><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ t = \frac{\bar{x} - \mu_0}{s /\sqrt{n}} \]</span></p><p>注意这里用的是样本标准差<code>s</code>。t分布比Z分布更“胖”一点，因为它考虑了用<code>s</code>估计<code>σ</code>带来的额外不确定性。</p><p><strong>方差检验 - χ² (卡方) 检验</strong></p><p><strong>问题</strong>：“一个零件的生产标准要求其长度的方差不能超过0.01mm²。我抽了30个零件，算出样本方差是0.015mm²。这条生产线的稳定性是否不达标？”</p><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ \chi^2 = \frac{(n-1)s^2}{\sigma_0^2}\]</span></p><p>其中 <span class="math inline">\(s^2\)</span> 是样本方差，<spanclass="math inline">\(\sigma_0^2\)</span> 是假设的总体方差。</p><p><strong>比例检验 - Z检验</strong></p><p><strong>问题</strong>：“去年我们产品的市场占有率是20%。今年我们搞了市场推广，在1000个新用户里，有230个选择了我们的产品。我们的市场占有率是否显著提升了？”</p><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ Z = \frac{\hat{p} -p_0}{\sqrt{\frac{p_0(1-p_0)}{n}}} \]</span></p><p>其中 <span class="math inline">\(\hat{p}\)</span>是样本比例，<code>p₀</code> 是假设的总体比例。</p><h5 id="两个正态总体参数检验">2. 两个正态总体参数检验</h5><p><strong>双独立样本均值检验 (Independent Samples t-test)</strong></p><p><strong>问题</strong>：“A、B两种不同的教学方法，哪种效果更好？我把学生随机分成两组，一组用A方法，一组用B方法，然后比较两组的期末平均分。”</p><p><strong>检验统计量 (假设方差相等)</strong>：</p><p><span class="math display">\[ t = \frac{(\bar{x}_1 - \bar{x}_2) -(\mu_1 - \mu_2)_0}{\sqrt{s_p^2 (\frac{1}{n_1} + \frac{1}{n_2})}} \quad ,\quad s_p^2 = \frac{(n_1-1)s_1^2 + (n_2-1)s_2^2}{n_1+n_2-2}\]</span></p><p>其中 <span class="math inline">\(s_p^2\)</span> 是合并方差。</p><p><strong>双独立样本方差检验 - F检验</strong></p><p><strong>问题</strong>：“在做上面的t检验之前，我需要先判断两组的方差是否相等。A组分数的方差是100，B组是120。这两个方差有显著差异吗？”</p><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ F = \frac{s_1^2}{s_2^2} \]</span></p><p>习惯上将较大的样本方差放在分子。</p><p><strong>配对样本t检验 (Paired Samples t-test)</strong></p><p><strong>问题</strong>：“我想知道一种减肥药有没有效果。我找了一批人，记录下他们服药前的体重，再记录下他们服药一个月后的体重，然后比较这两组体重的差异。”</p><p><strong>思路</strong>：这不是独立样本，因为数据是“成对”出现的（同一个人前后对比）。我们先计算出每个人的体重<strong>差值d</strong>，然后问题就转化成了<strong>对这些差值d进行单样本t检验</strong>，看差值的平均值<span class="math inline">\(\bar{d}\)</span> 是否显著不为零。</p><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ t = \frac{\bar{d} - D_0}{s_d /\sqrt{n}} \]</span></p><p>其中 <code>D₀</code> 通常是0，<code>s_d</code> 是差值 <code>d</code>的标准差。</p><h3 id="列联分析-contingency-analysis"><strong>3.2 列联分析 (ContingencyAnalysis)</strong></h3><p><strong>目的</strong>：专门用来分析<strong>定性变量（分类变量）</strong>之间是否存在关联。</p><ul><li><p><strong>分析思路 - 卡方检验 (Chi-squared Test, χ²)</strong>：</p><ul><li>这个检验的核心思想是“<strong>期望与现实的比较</strong>”。</li></ul><ol type="1"><li><p><strong>提出假设(H0)</strong>：我们先假设这两个变量是<strong>完全独立、互不相干</strong>的。</p></li><li><p><strong>计算期望频数 (ExpectedFrequency)</strong>：基于“独立”这个假设，我们来算一下，理论上，列联表中每个格子里应该有多少人。</p><ul><li><strong>公式</strong>：某个格子的期望频数 =<code>(该格子所在行的总和 × 该格子所在列的总和) / 总人数</code></li></ul></li><li><p><strong>计算卡方统计量(χ²)</strong>：现在我们有了“期望”和“现实”（观测频数），就可以计算出卡方值，它衡量了现实与期望之间的总体差距。</p><ul><li><p><strong>公式</strong>： <span class="math display">\[ \chi^2 =\sum \frac{(\text{观测频数} - \text{期望频数})^2}{\text{期望频数}}\]</span></p></li><li><p><strong>解读</strong>：如果现实和期望差得很多，算出来的χ²值就会很大，这说明我们的“独立”假设可能站不住脚。</p></li></ul></li><li><p><strong>作出统计决策</strong>：将计算出的χ²值与临界值比较（或直接看p值）。如果p值小于显著性水平α，我们就拒绝原假设，认为这两个变量之间<strong>存在显著关联</strong>。</p></li></ol></li><li><p><strong>列联表中的相关测量 (Measures ofAssociation)</strong>：</p><ul><li><p>卡方检验只能告诉我们变量之间“有没有”关联，但不能告诉我们这个关联有多“强”。下面的系数就是用来度量关联强度的。</p></li><li><p><strong>φ (Phi) 相关系数</strong>：专门用于 <strong>2x2</strong>列联表。</p><ul><li><p><strong>公式</strong>： <span class="math inline">\(\phi =\sqrt{\frac{\chi^2}{n}}\)</span> (n是总样本量)</p></li><li><p><strong>解读</strong>：它的值在0到1之间，越接近1，表示关联性越强。</p></li></ul></li><li><p><strong>V (Cramér's V)相关系数</strong>：更通用的系数，可用于任意大小的列联表。</p><ul><li><p><strong>公式</strong>： <span class="math inline">\(V =\sqrt{\frac{\chi^2}{n \cdot (\min(r, c) - 1)}}\)</span> (r是行数,c是列数)</p></li><li><p><strong>解读</strong>：它的值也在0到1之间，同样是越接近1，关联性越强。这使得它在不同大小的表格之间具有可比性，是实践中最常用的指标之一。</p></li></ul></li></ul></li></ul><h3 id="相关分析-correlation-analysis"><strong>3.3 相关分析 (CorrelationAnalysis)</strong></h3><ul><li><p><strong>目的</strong>：判明<strong>定量数据（连续变量）</strong>之间有无关联，以及关联的强度和方向。</p></li><li><p><strong>和函数关系之间的区别在于？</strong></p><ul><li><p><strong>函数关系</strong>：是一种<strong>确定性</strong>的关系，一个X值精确地对应一个Y值。比如，<code>y = 2x + 1</code>。只要x定了，y就定了，没有任何偏差。画出来是完美的一条线。</p></li><li><p><strong>相关关系</strong>：是一种<strong>非确定性</strong>的、随机的关系。变量之间存在着大致的趋势，但并不严格。比如，身高和体重，身高越高的人，体重“倾向于”越重，但不是绝对的。画出来是围绕着一条趋势线分布的一团散点。<strong>回归分析研究的就是如何找出这团散点背后的那条“平均趋势线”，而相关分析则衡量这团散点向这条线“靠拢的紧密程度”</strong>。</p></li></ul></li><li><p><strong>相关关系的测定</strong>：</p><ul><li><p><strong>图形 - 散点图 (ScatterPlot)</strong>：这是判断关系最直观的工具。通过观察散点的形态，我们可以看出：</p><ul><li><p>关系的方向（从左下到右上是正相关，从左上到右下是负相关）。</p></li><li><p>关系的形态（是直线还是曲线）。</p></li><li><p>关系的强度（点越是紧密地聚集在一条线周围，关系越强）。</p></li></ul></li><li><p><strong>相关系数 (CorrelationCoefficient)</strong>：将图形化的关系量化成一个具体的数值。</p><ul><li><p><strong>Pearson简单相关系数 (r)</strong>：</p><ul><li><p><strong>用途</strong>：最最常用的相关系数，衡量两个<strong>连续变量</strong>之间<strong>线性关系</strong>的强度和方向。</p></li><li><p><strong>公式</strong>： <span class="math display">\[ r =\frac{\sum_{i=1}^{n}(x_i - \bar{x})(y_i -\bar{y})}{\sqrt{\sum_{i=1}^{n}(x_i - \bar{x})^2 \sum_{i=1}^{n}(y_i -\bar{y})^2}} \]</span></p></li><li><p><strong>解读</strong>：</p><ul><li><p>取值范围在 <strong>-1 到 +1</strong> 之间。</p></li><li><p><code>r &gt; 0</code> 为正相关，<code>r &lt; 0</code>为负相关。</p></li><li><p><code>|r|</code> 的绝对值越大，线性关系越强。<code>|r| = 1</code>表示完全线性相关，所有点都在一条直线上。<code>r = 0</code>表示没有线性关系。</p></li></ul></li><li><p><strong>重要前提</strong>：它要求变量服从正态分布，并且对异常值非常敏感。</p></li></ul></li><li><p><strong>Spearman等级相关系数 (ρ 或 rs)</strong>：</p><ul><li><p><strong>用途</strong>：当数据不满足正态分布，或者数据是<strong>定序变量（等级数据）</strong>时使用。比如，“产品喜好度排名”和“广告投入排名”之间的关系。</p></li><li><p><strong>具体操作</strong>：它不直接用原始数值，而是先把每个变量的数据<strong>从小到大进行排序，用它们的“排名”来代替原始值</strong>。然后，再对这两个排名序列计算皮尔逊相关系数。</p></li><li><p><strong>解读</strong>：它衡量的是两个变量单调关系（是不是同增同减）的强度。</p></li></ul></li><li><p><strong>Kendall's Tau (τ) 相关系数</strong>：</p><ul><li><p><strong>用途</strong>：也是一种非参数的等级相关系数，同样适用于定序变量。</p></li><li><p><strong>具体操作</strong>：它的计算方式更复杂一些。它通过比较数据中所有“<strong>一致对</strong>”（两个变量的排序方向相同）和“<strong>非一致对</strong>”（排序方向相反）的数量来衡量关系。</p></li><li><p><strong>解读</strong>：与Spearman相比，Kendall'sTau对于小样本和有大量相同等级的数据时可能更稳健。</p></li></ul></li><li><p><strong>相关系数的显著性检验 (t检验)</strong>：</p><ul><li><p>我们算出来的相关系数r不等于0，但这会不会只是样本的巧合？我们需要检验这个相关性在总体中是否也存在。</p></li><li><p><strong>检验统计量</strong>：</p><p><span class="math display">\[ t = \frac{r\sqrt{n-2}}{\sqrt{1-r^2}}\]</span></p></li><li><p>将计算出的t值与t分布的临界值比较（或看p值），来判断相关系数是否显著不为零。</p></li></ul></li></ul></li></ul></li><li><p><strong>偏相关系数 (Partial Correlation)</strong>：</p><ul><li><p><strong>目的</strong>：在多元分析中，我们想知道两个变量X1和Y之间的“纯粹”关系，需要<strong>排除掉其他变量（如X2）的干扰</strong>。</p></li><li><p><strong>用人话讲</strong>：比如我们发现“冰淇淋销量”(X1)和“溺水人数”(Y)之间有很强的正相关。但这很可能是个伪相关，因为它们都受到了“气温”(X2)这个变量的影响。偏相关分析就是要计算在<strong>控制住“气温”这个变量不变</strong>的前提下，“冰淇淋销量”和“溺水人数”之间还剩下多少相关性。结果很可能是，剩下的相关性几乎为零。</p></li></ul></li><li><p><strong>3.4 回归分析</strong></p><ul><li><p><strong>目的</strong>：建立变量间相互依赖的量化关系，进行预测或控制。</p></li><li><p><strong>分类</strong>：一元/多元、简单/多重、线性/非线性回归。</p></li><li><p><strong>线性回归分析</strong>：</p><ul><li><p><strong>模型假设</strong>。</p><ol type="1"><li><p><strong>线性(Linearity)</strong>：自变量和因变量之间必须存在线性关系。</p></li><li><p><strong>独立性(Independence)</strong>：各个观测样本的误差项之间是相互独立的，互不影响。比如你预测今天的股价，那个误差不应该影响你对明天股价误差的判断。</p></li><li><p><strong>方差齐性(Homoscedasticity)</strong>：误差项的方差应该是一个常数，不随自变量的取值而改变。<strong>用人话讲</strong>，就是模型预测的“离谱程度”应该是均匀的，不能在自变量小的时候预测很准，自变量大的时候就预测得非常离谱。</p></li><li><p><strong>正态性(Normality)</strong>：误差项必须服从正态分布。</p></li></ol></li><li><p><strong>回归系数的最小二乘估计</strong>。</p></li><li><p><strong>回归方程的拟合优度</strong>：</p><p>决定系数（R²） <span class="math display">\[  R^2 = 1 - \frac{SS_{Res}}{SS_{Total}}   \]</span></p><p>复相关系数</p><p><span class="math display">\[R = \sqrt{R^2}\]</span></p><p>修正决定系数</p><p><span class="math display">\[R^2_{\text{adj}} = 1 - (1 - R^2) \cdot\frac{n - 1}{n - p - 1}\]</span></p><ul><li><p>普通的R²有个毛病——你往模型里加的自变量越多，R²就一定会变大（或不变），哪怕你加的是一个毫无关系的变量（比如用星座来预测房价）。这会误导我们以为模型越复杂越好。</p></li><li><p><strong>解读</strong>：修正R²就是给R²打了个“补丁”，它在计算时考虑了自变量的数量。如果你加入的自变量对模型没有显著贡献，修正R²反而会下降。因此，在比较包含不同数量自变量的模型时，<strong>看修正R²比看R²更靠谱</strong>。公式中的 <code>n</code> 是样本量，<code>p</code> 是自变量个数。</p></li></ul></li><li><p><strong>回归标准误差</strong></p></li><li><p><strong>显著性检验</strong></p><ul><li><p>我们的模型和变量真的有意义吗？还是仅仅是数据巧合？这就需要做显著性检验。</p></li><li><p><strong>回归的显著性检验 (F检验)</strong></p></li><li><p><strong>目的</strong>：检验整个模型的<strong>总体显著性</strong>。它回答的问题是：“你这个回归方程，作为一个整体，到底有没有用？”</p></li><li><p><strong>怎么看</strong>：看F检验的p值。如果p值很小（比如&lt;0.05），我们就有信心拒绝“所有自变量都和因变量没关系”这个原假设，认为这个模型整体上是成立的。</p></li><li><p><strong>回归系数的显著性检验 (t检验)</strong></p></li><li><p><strong>目的</strong>：检验<strong>每一个自变量</strong>的<strong>个体显著性</strong>。它回答的问题是：“模型里的这个XX变量，它对因变量到底有没有显著的影响？”</p></li><li><p><strong>怎么看</strong>：看每个系数对应的t检验的p值。如果某个变量的p值很小（&lt;0.05），说明它是个有用的预测变量。如果p值很大，说明这个变量可能没什么用，可以考虑从模型中剔除。</p></li></ul></li></ul></li><li><p><strong>残差分析</strong>：</p><ul><li><p><strong>概念</strong>：残差就是“真实值 -预测值”，是模型没能解释的那部分“意外”。</p></li><li><p><strong>目的</strong>：就是通过分析“意外”，看看我们的“理论”是不是出了问题。</p></li><li><p><strong>残差图</strong>：这是最重要的诊断工具。我们通常画出“残差vs.预测值”的散点图。一个好的残差图，应该像一盘散沙，点在0线上下随机均匀分布，看不出任何模式。</p><ul><li><p>如果残差图呈现出<strong>喇叭形</strong>或<strong>漏斗形</strong>，说明<strong>方差不齐</strong>。</p></li><li><p>如果残差图呈现出明显的<strong>曲线模式</strong>，说明可能存在<strong>非线性关系</strong>。</p></li></ul></li><li><p><strong>P-P图 /Q-Q图</strong>：这是专门用来检验<strong>残差正态性</strong>的图形工具。如果点基本都落在对角线上，就说明残差大致服从正态分布。</p></li></ul></li><li><p><strong>其他问题</strong>：</p></li><li><p><strong>自变量筛选方法</strong></p></li><li><p>当自变量很多时，我们想选出一组“最佳”的自变量组合。手动筛选太麻烦，于是有了自动筛选的方法。</p><ul><li><p><strong>前进法 (ForwardSelection)</strong>：像搭积木。从一个空模型开始，每次都把那个能让模型改善最显著的变量加进来，直到没有变量能再提供显著改善为止。</p></li><li><p><strong>后退法 (BackwardElimination)</strong>：像砍树。从包含所有变量的完整模型开始，每次都把那个最没用的变量（p值最大）剔除出去，直到剩下的变量都显著为止。</p></li><li><p><strong>逐步回归法 (StepwiseRegression)</strong>：前进法和后退法的结合体，更加灵活。每引入一个新变量后，都会重新审视一下模型里已有的所有变量，看看有没有哪个因为新成员的加入而变得不那么重要了，如果有就把它踢出去。</p></li></ul></li><li><p><strong>多重共线性 (Multicollinearity)</strong></p><ul><li><p><strong>概念</strong>：指在多元回归中，自变量之间存在高度相关关系。</p></li><li><p><strong>用人话讲</strong>：就是模型里的几个自变量“说的话都差不多”，信息重叠了。比如，同时用“房屋使用面积”和“房屋建筑面积”来预测房价，这两个变量高度相关，就可能引发多重共线性。</p></li><li><p><strong>危害</strong>：它会导致回归系数的估计变得非常不稳定，符号可能与预期相反，t检验也可能不显著，让我们无法准确判断每个自变量的单独贡献。</p></li><li><p><strong>诊断</strong>：最常用的指标是<strong>方差扩大因子(Variance Inflation Factor,VIF)</strong>。如果某个变量的VIF值很大（通常认为&gt;5或&gt;10），就说明它和其他自变量存在严重的多重共线性问题。</p></li></ul></li></ul></li><li><p><strong>3.5 方差分析 (ANOVA)</strong></p><ul><li><p><strong>引论</strong>：</p><ul><li><p>目的：检验多个总体均值是否相等，研究分类型自变量对数值型因变量的影响。</p><p>有关术语</p></li><li><p>基本思想：比较组间方差（系统误差+随机误差）与组内方差（随机误差），通过F比值判断均值差异是否显著。</p></li><li><p>基本假定：正态性、方差齐性、独立性。</p></li></ul></li><li><p><strong>单因素方差分析</strong>：</p><ul><li><p>数据结构。</p></li><li><p>分析步骤：提出假设、构造检验统计量（SST, SSA,SSE及其自由度、均方MSA, MSE）、计算F值、统计决策。</p></li><li><p>关系强度测量（R²）。</p></li><li><p>多重比较：当拒绝原假设后，进一步检验哪些均值之间存在差异（如LSD方法）。</p></li></ul></li><li><p><strong>双因素方差分析</strong>：</p><ul><li><p>类型：无交互作用、有交互作用。</p></li><li><p>目的：分析两个因素（行因素、列因素）及其交互作用对试验结果的影响。</p></li><li><p>数据结构。</p></li><li><p>分析步骤：提出假设（行因素、列因素及交互作用）、计算平方和（SST,SSR, SSC, SSinteract, SSE）、计算均方、计算F值、统计决策。</p></li><li><p>关系强度测量。</p></li></ul></li></ul></li></ul><h3 id="方差分析-analysis-of-variance-anova"><strong>3.4 方差分析(Analysis of Variance, ANOVA)</strong></h3><ul><li><p><strong>引论 (Introduction)</strong></p><ul><li><p><strong>目的</strong>：方差分析主要用于检验<strong>两个或更多个总体（组）的均值是否相等</strong>。本质上，它研究的是一个或多个<strong>分类型自变量</strong>对一个<strong>数值型因变量</strong>的影响。</p><ul><li><strong>用人话讲</strong>：当我们想比较的组别超过两个时（比如，比较A、B、C三种教学方法下的学生平均分），做多次t检验会增加犯第一类错误的概率。ANOVA提供了一种“一锅端”的解决方案，一次性判断所有组的均值是否都相等。</li></ul></li><li><p><strong>有关术语</strong>：</p><ul><li><p><strong>因素(Factor)</strong>：就是我们研究的那个分类型自变量，比如“教学方法”。</p></li><li><p><strong>水平(Level)</strong>：因素的不同取值，比如“A方法”、“B方法”、“C方法”。</p></li></ul></li><li><p><strong>基本思想 (The Core Idea)</strong>：</p><ul><li><p>ANOVA的精髓在于“<strong>分解总变异</strong>”。它把数据的总波动（总方差）分解为两个部分：</p><ol type="1"><li><p><strong>组间方差 (Between-GroupVariance)</strong>：由不同组别（因素的不同水平）带来的系统性差异。比如，A、B、C三种教学方法本身的效果差异。这部分方差既包含了<strong>系统误差</strong>，也包含了随机误差。</p></li><li><p><strong>组内方差 (Within-GroupVariance)</strong>：同一组内部，由于个体差异等随机因素造成的波动。比如，同样用A方法教学，学生的分数也不可能完全一样。这部分方差被认为是纯粹的<strong>随机误差</strong>。</p></li></ol></li><li><p><strong>F比值</strong>：通过比较这两个方差，我们就能做出判断。<span class="math display">\[ F =\frac{\text{组间方差}}{\text{组内方差}} = \frac{MSA}{MSE} \]</span></p><ul><li><strong>逻辑</strong>：如果原假设“所有组的均值都相等”成立，那么就不存在系统误差，组间方差和组内方差应该差不多大，F比值就会接近1。反之，如果不同组的均值确实有差异，组间方差就会显著大于组内方差，F比值就会很大。</li></ul></li></ul></li><li><p><strong>基本假定(Assumptions)</strong>：和线性回归一样，ANOVA也有它的“地基”。</p><ol type="1"><li><p><strong>正态性</strong>：各组的样本都分别来自正态分布的总体。</p></li><li><p><strong>方差齐性</strong>：各组的总体方差相等。这是ANOVA非常重要的一个前提。</p></li><li><p><strong>独立性</strong>：各样本之间是相互独立的。</p></li></ol></li></ul></li></ul><h4 id="单因素方差分析-one-way-anova"><strong>单因素方差分析 (One-WayANOVA)</strong></h4><ul><li><p>研究<strong>一个</strong>分类型自变量对一个数值型因变量的影响。</p></li><li><p><strong>分析步骤</strong>：</p><ol type="1"><li><strong>提出假设</strong>：<ul><li>H0: <span class="math inline">\(\mu_1 = \mu_2 = \dots =\mu_k\)</span> (所有组的总体均值都相等)</li><li>H1: 至少有两个组的总体均值不相等</li></ul></li><li><strong>构造检验统计量</strong>：这一步是核心，即分解平方和(Sum ofSquares)。<ul><li><strong>总平方和 (SST, Total Sum ofSquares)</strong>：所有数据点与总平均值的离差平方和，代表了总变异。</li><li><strong>组间平方和 (SSA, Sum of Squares BetweenGroups)</strong>：也叫处理平方和，代表了由不同组别引起的变异。 <spanclass="math display">\[ SSA = \sum_{i=1}^{k} n_i (\bar{x}_i -\bar{\bar{x}})^2 \]</span> (<spanclass="math inline">\(k\)</span>是组数, <spanclass="math inline">\(n_i\)</span>是第i组样本量, <spanclass="math inline">\(\bar{x}_i\)</span>是第i组均值, <spanclass="math inline">\(\bar{\bar{x}}\)</span>是总均值)</li><li><strong>组内平方和 (SSE, Sum of Squares WithinGroups)</strong>：也叫误差平方和，代表了随机误差引起的变异。 <spanclass="math display">\[ SSE = \sum_{i=1}^{k} \sum_{j=1}^{n_i} (x_{ij} -\bar{x}_i)^2 \]</span></li><li><strong>关系</strong>：<span class="math inline">\(SST = SSA +SSE\)</span></li></ul></li><li><strong>计算F值</strong>：<ul><li>为了消除样本量的影响，我们要用平方和除以各自的<strong>自由度(df)</strong>，得到<strong>均方 (Mean Square)</strong>。<ul><li>组间均方 (MSA): <span class="math inline">\(MSA =\frac{SSA}{k-1}\)</span></li><li>组内均方 (MSE): <span class="math inline">\(MSE =\frac{SSE}{N-k}\)</span> (N是总样本量)</li></ul></li><li><strong>F统计量</strong>： <span class="math display">\[ F =\frac{MSA}{MSE} \]</span></li></ul></li><li><strong>统计决策</strong>：将计算出的F值与F分布的临界值比较（或看p值）。如果p值&lt; α，则拒绝H0，说明各组均值之间存在显著差异。</li></ol></li><li><p><strong>多重比较 (Post-Hoc Multiple Comparisons)</strong>：</p><ul><li>ANOVA的F检验拒绝了H0，只告诉我们“这些组的均值不全相等”，但没告诉我们<strong>具体是哪些组之间</strong>有差异。是A和B有差异？还是B和C有差异？多重比较就是用来做这个“事后追查”的。</li><li><strong>常用方法</strong>：LSD (Least Significant Difference)、TukeyHSD、Bonferroni等。它们本质上是两两t检验的变体，但对显著性水平进行了修正，以控制整体的第一类错误率。</li></ul></li></ul><hr /><h4 id="双因素方差分析-two-way-anova"><strong>双因素方差分析 (Two-WayANOVA)</strong></h4><ul><li><p>研究<strong>两个</strong>分类型自变量及其<strong>交互作用</strong>对一个数值型因变量的影响。</p></li><li><p><strong>类型</strong>：</p><ul><li><strong>无交互作用的双因素方差分析</strong>：假定两个因素的影响是相互独立的、可以叠加的。</li><li><strong>有交互作用的双因素方差分析</strong>：这是更常见、更现实的情况。它不仅考虑两个因素各自的独立影响（<strong>主效应</strong>），还考虑它们组合在一起时产生的特殊“化学反应”（<strong>交互效应</strong>）。<ul><li><strong>交互效应举例</strong>：假设我们研究“肥料种类”（A/B）和“浇水量”（高/低）对农作物产量的影响。如果A肥在低水量时效果好，B肥在高水量时效果好，这就说明两个因素之间存在交互作用。它们的影响不是简单的1+1=2。</li></ul></li></ul></li><li><p><strong>分析步骤</strong>：</p><ol type="1"><li><strong>提出假设</strong>：现在我们有三套假设要检验。<ul><li>关于<strong>交互作用</strong>的：H0: 两个因素之间没有交互作用。</li><li>关于<strong>行因素主效应</strong>的：H0:行因素的各个水平均值相等。</li><li>关于<strong>列因素主效应</strong>的：H0:列因素的各个水平均值相等。</li></ul></li><li><strong>计算平方和</strong>：总变异被分解得更细了。<ul><li><span class="math inline">\(SST = SSR + SSC + SS_{interaction} +SSE\)</span><ul><li><strong>SST</strong>: 总平方和</li><li><strong>SSR (Rows)</strong>: 行因素引起的平方和</li><li><strong>SSC (Columns)</strong>: 列因素引起的平方和</li><li><strong>SS_interaction</strong>: 交互作用引起的平方和</li><li><strong>SSE</strong>: 随机误差平方和</li></ul></li></ul></li><li><strong>计算F值</strong>：我们要分别计算三个F值。<ul><li><span class="math inline">\(F_{interaction} =\frac{MS_{interaction}}{MSE}\)</span></li><li><span class="math inline">\(F_{R} = \frac{MSR}{MSE}\)</span></li><li><span class="math inline">\(F_{C} = \frac{MSC}{MSE}\)</span></li></ul></li><li><strong>统计决策</strong>：<ul><li><strong>首先看交互作用的F检验</strong>。如果交互作用显著，说明两个因素的影响是纠缠在一起的，此时单独分析主效应的意义不大，应重点分析交互效应的模式。</li><li>如果交互作用不显著，我们再分别去看两个主效应的F检验，判断每个因素是否对因变量有独立、显著的影响。</li></ul></li></ol></li></ul><h2 id="问题建模">4. 问题建模</h2><h3 id="预测建模-predictive-modeling">4.1 <strong>预测建模 (PredictiveModeling)</strong></h3><p>利用已有数据，建立数学模型，来预测未来的数值。</p><h4 id="回归分析-regression-analysis"><strong>回归分析 (RegressionAnalysis)</strong></h4><p>（这部分在之前的对话中已经详细展开，此处补充和完善上述提到的其他回归类型。）</p><ul><li><p><strong>线性回归 (LinearRegression)</strong>：基础模型，寻找最佳直线（或超平面）来拟合数据。</p></li><li><p><strong>岭回归 (Ridge Regression)</strong></p><ul><li><p><strong>目的</strong>：主要用于解决线性回归中的<strong>多重共线性</strong>问题。当自变量之间高度相关时，普通最小二乘法（OLS）估计的回归系数会非常不稳定，方差很大。</p></li><li><p><strong>用人话讲</strong>：岭回归就像是给不稳定的回归系数“上了一道枷锁”。它在最小二乘法的基础上，增加了一个“惩罚项”（L2范数惩罚），这个惩罚项会抑制回归系数变得过大。这种约束使得模型整体上变得更稳定、更可靠，即使牺牲了一点点在训练集上的拟合精度。</p></li></ul></li><li><p><strong>Lasso回归 (Lasso Regression)</strong></p><ul><li><p><strong>目的</strong>：它和岭回归很像，也是为了解决多重共线性问题。但它有一个更强大的特性——<strong>特征选择(Feature Selection)</strong>。</p></li><li><p><strong>用人话讲</strong>：Lasso回归用的惩罚项（L1范数惩罚）比岭回归更“狠”。它不仅会抑制系数的大小，还会把那些它认为不重要的自变量的系数<strong>直接压缩到零</strong>。因此，Lasso回归在得到一个稳定模型的同时，还帮我们做了一轮变量筛选，告诉我们哪些变量才是真正重要的。</p></li></ul></li><li><p><strong>逻辑回归 (Logistic Regression)</strong></p><ul><li><p><strong>注意</strong>：虽然名字里带“回归”，但它实际上是一个<strong>分类模型</strong>。</p></li><li><p><strong>目的</strong>：用于预测一个<strong>二元结果</strong>（是/否，1/0）。比如预测一个用户是否会点击广告，一封邮件是否是垃圾邮件。</p></li><li><p><strong>用人话讲</strong>：它通过一个特殊的<strong>Sigmoid函数</strong>，巧妙地将线性回归的连续输出值（可以从负无穷到正无穷）映射到(0, 1)区间内。这个输出值就可以被解释为“事件发生的概率”。比如，输出0.8，就表示模型预测有80%的概率是正例。然后我们再设定一个门槛（比如0.5），大于这个门槛就判为1，小于就判为0，从而实现了分类。</p></li></ul></li></ul><h4id="决策树-回归---cr-tree-classification-and-regression-tree"><strong>决策树(回归) - C&amp;R Tree (Classification and Regression Tree)</strong></h4><ul><li><p><strong>目的</strong>：用树状结构来做回归预测。</p></li><li><p><strong>用人话讲</strong>：分类决策树的每个叶子节点代表一个类别，而回归树的每个叶子节点则代表一个<strong>具体的数值</strong>。它的构建过程是这样的：树不断地通过对某个特征提出问题（比如“面积是否&lt;80平米？”）来分裂数据，目标是让每次分裂后，新生成的节点（分支）内的因变量（比如房价）的<strong>方差变得最小</strong>。最终，当树停止生长时，一个新样本落入某个叶子节点，它的预测值就是这个叶子节点里所有训练样本的<strong>平均值</strong>。</p></li></ul><h4 id="xgboost回归-extreme-gradient-boosting"><strong>XGBoost回归(eXtreme Gradient Boosting)</strong></h4><ul><li><p><strong>目的</strong>：一种极其强大和高效的集成学习算法。</p></li><li><p><strong>用人话讲</strong>：可以把它想象成一个“精英团队在不断学习和弥补错误”。</p><ol type="1"><li><p>第一个学习器（一棵简单的决策树）先对数据进行一个粗略的预测。</p></li><li><p>第二个学习器上场，它的任务不是预测原始数据，而是专门学习和预测<strong>第一个学习器没预测对的那部分（残差）</strong>。</p></li><li><p>第三个学习器再来学习和预测第二个学习器没预测对的残差……</p></li></ol><p>这个过程不断迭代，每一棵新树都在弥补前面所有树的不足。XGBoost在这个基础上做了大量的优化，速度极快，效果极好，并且内置了正则化来防止过拟合。</p></li></ul><h4 id="神经网络-neural-networks"><strong>神经网络 (NeuralNetworks)</strong></h4><p>通过模拟人脑神经元的连接方式，来学习数据中极其复杂的非线性关系。这个略。</p><h4id="支持向量回归机-support-vector-regression-svr"><strong>支持向量回归机(Support Vector Regression, SVR)</strong></h4><ul><li><p><strong>目的</strong>：支持向量机 (SVM) 的回归版本。</p></li><li><p><strong>用人话讲</strong>：普通线性回归的目标是找到一条线，让所有点到线的距离平方和最小。而SVR的目标是找到一个“<strong>管道</strong>”或“<strong>街道</strong>”，这个管道的宽度是<code>2ε</code>。它的目标是让<strong>尽可能多的数据点落在这个管道里</strong>，同时让管道本身尽可能“窄”。对于落在管道外的点，SVR才会计算它们的“损失”。那些决定了管道边界的点，就是“<strong>支持向量</strong>”。这种“对管道内的点不计较”的特性，使得SVR对异常值不那么敏感，模型更稳健。</p></li></ul><h3 id="分类建模-classification-modeling">4.2 <strong>分类建模(Classification Modeling)</strong></h3><p>利用数学模型，将事物划分到预先定义好的不同类别中。因变量Y是离散的。</p><ul><li><p><strong>逻辑回归</strong>、<strong>判别分析</strong></p></li><li><p><strong>决策树（分类）</strong></p></li><li><p><strong>神经网络</strong></p></li><li><p><strong>支持向量分类机 (SVC)</strong>：</p><p>它的核心思想是在不同类别的样本之间，找到一个“<strong>最宽的街道</strong>”（最大间隔超平面）。街道的边缘由距离最近的几个点（<strong>支持向量</strong>）来支撑。这样划分出来的边界容错性最好。对于线性不可分的数据，它通过“<strong>核技巧</strong>”（KernelTrick）将数据映射到更高维的空间，让它们变得线性可分，再寻找那条最宽的街道。</p></li><li><p><strong>随机森林 (Random Forest)</strong>：</p><p>一种集成学习算法，也是决策树的一种。</p><ol type="1"><li><p>它构建<strong>很多棵不同的决策树</strong>。为了让每棵树都不同，它在训练时采用了两种随机性：一是随机抽取一部分样本（<strong>行抽样</strong>），二是随机抽取一部分特征来参与决策（<strong>列抽样</strong>）。</p></li><li><p>当需要做预测时，让森林里的每一棵树都独立地“投票”，最后<strong>少数服从多数</strong>，得票最多的那个类别就是最终的预测结果。</p></li></ol><p>这种机制极大地提高了模型的准确性和稳定性，并且能有效防止单棵决策树容易出现的过拟合问题。</p></li></ul><h3 id="关联分析-association-analysis">4.3 <strong>关联分析 (AssociationAnalysis)</strong></h3><p>从一大堆看似无关的事件中，找出“A发生了，B也很可能发生”这种模式。最经典的例子就是“啤酒与尿布”的故事。</p><ul><li><p><strong>Apriori算法</strong></p><ul><li><p><strong>核心思想</strong>：“<strong>一个项集如果是频繁的，那么它的所有子集也必须是频繁的。</strong>”反过来说就是：“如果一个项集不频繁，那么它的所有超集也肯定不频繁。”</p></li><li><p><strong>操作</strong>：它像“筛筛子”一样，从包含1个商品的频繁项集开始，一层层地往上找包含2个、3个...商品的频繁项集。在每一层，它都利用上面的核心思想来“剪枝”，提前淘汰掉大量不可能频繁的组合，从而提高效率。</p></li></ul></li><li><p><strong>FP-growth算法</strong></p><ul><li><p><strong>核心思想</strong>：Apriori算法需要反复扫描数据库并产生大量候选集，效率不高。FP-growth算法则更高明，它把整个数据库的交易信息压缩到一棵叫<strong>FP树(Frequent Pattern Tree)</strong> 的特殊树状结构里。</p></li><li><p><strong>操作</strong>：它只需要扫描两次数据库：一次是统计商品频率，一次是建树。建好树后，所有的挖掘工作都在这棵紧凑的树上进行，不再需要访问原始数据库，速度大大提升。</p></li></ul></li><li><p><strong>CARMA算法</strong></p></li><li><p><strong>序列模式挖掘算法</strong></p></li></ul><h3 id="聚类分析-cluster-analysis">4.4 <strong>聚类分析 (ClusterAnalysis)</strong></h3><ul><li><p><strong>用人话讲</strong>：聚类就是“<strong>人以群分，物以类聚</strong>”。它事先不知道有哪些类别，也没有标准答案。算法需要自己根据数据的“长相”（特征），把相似的样本自动地归为一堆，把不相似的分开。</p></li><li><p><strong>系统聚类 (Hierarchical Clustering)</strong></p><ul><li><strong>操作</strong>：它有两种方式。一种是“凝聚”法，开始时每个点都是一个独立的簇，然后一步步地把最相近的两个簇合并，直到所有点都合并成一个大簇，整个过程就像画一棵“树状图”。另一种是“分裂”法，反过来操作。</li></ul></li><li><p><strong>K-Means算法</strong></p><ul><li><strong>操作</strong>：这是最经典的聚类算法之一。<ol type="1"><li>你先<strong>指定要聚成几类 (K)</strong>。</li><li>算法随机选择K个点作为初始的“簇中心”。</li><li>所有其他点根据自己离哪个“簇中心”最近，来决定自己的归属。</li><li>然后，重新计算每个簇的“新中心”（该簇所有点的平均位置）。</li><li>重复第3、4步，直到簇中心的位置不再变化为止。</li></ol></li></ul></li><li><p><strong>TwoStep算法</strong></p></li></ul><h3 id="序列分析-sequence-analysis">4.5 <strong>序列分析 (SequenceAnalysis)</strong></h3><ul><li><p><strong>目的</strong>：与关联分析类似，但它额外考虑了<strong>时间顺序</strong>。它要发现的是形如“顾客先买了A，过了一段时间后，又买了B”这样的<strong>时序模式</strong>。</p></li><li><p><strong>用人话讲</strong>：关联分析告诉你顾客的购物篮里同时有什么，而序列分析告诉你顾客的“购物时间线”是怎样的。比如，发现“买了新电脑的顾客，通常会在一个月内购买打印机”，或者“看了电影A的观众，下周很可能会去看它的续集B”。</p></li><li><p><strong>应用</strong>：网站点击流分析（分析用户的浏览路径）、客户生命周期价值分析、DNA序列分析等。</p></li></ul><h3 id="web数据挖掘-web-data-mining">4.6 <strong>Web数据挖掘 (Web DataMining)</strong></h3><p><strong>目的</strong>：一个综合性的领域，指利用数据挖掘技术从海量的Web数据（包括网页内容、网页链接结构、用户访问日志等）中发现有用的知识和模式。</p><p><strong>主要内容</strong>：</p><ol type="1"><li><p><strong>Web内容挖掘 (Web ContentMining)</strong>：从网页的文本、图片、音视频中提取信息。搜索引擎的网页索引就属于这一类。</p></li><li><p><strong>Web结构挖掘 (Web StructureMining)</strong>：分析网页之间的链接关系（超链接）。比如，Google著名的PageRank算法就是通过分析网页的链接结构来判断网页的重要性。</p></li><li><p><strong>Web使用挖掘 (Web UsageMining)</strong>：分析用户的访问日志，发现用户的访问模式和行为习惯。这包括了上面提到的关联分析和序列分析在网站上的具体应用，用于个性化推荐、网站布局优化等。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>综述概要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化方法综述</title>
    <link href="/2025/08/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%BB%BC%E8%BF%B0/"/>
    <url>/2025/08/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>实际上最优化问题的本质就是求极值，求目标函数/评价函数的极值，这个点运用是十分广泛的。</p><h2 id="实际求解工具">实际求解工具</h2><ul><li><p>matlab 不推荐，优化较少</p></li><li><p>lingo 推荐，专门的优化软件，但是有的极端题算不完</p></li><li><p>gurobi 推荐，算得很好，而且可以直接上python</p></li></ul><h2 id="如何建立最优化问题的数学模型">如何建立最优化问题的数学模型</h2><p>（1）决策变量和参数</p><p>决策变量是由数学模型的解确定的未知数。参数表示系统的控制变量，有确定性的也有随机性的。</p><p>用人话就是找哪些是定量，哪些是未知量，哪些是目标求解的量；哪些是自变量，哪些是因变量。</p><p>（2）约束或限制条件</p><p>由于现实系统的客观物质条件限制，模型必须包括把决策变量限制在它们可行值之内的约束条件，而这通常是用约束的数学函数形式来表示的。</p><p>换句话讲就是寻找约束条件，并且将其用数学语言描述出来。</p><p>（3）目标函数</p><p>这是作为系统决策变量的一个数学函数来衡量系统的效率，即系统追求的目标。</p><h2 id="最优化数学模型分类">最优化数学模型分类</h2><p>根据目标函数和约束条件的性质，最优化模型可以分为多种类型。不同的类型特征鲜明，求解的思路和难度也大相径庭。</p><h3 id="线性规划-linear-programming-lp">1. 线性规划 (Linear Programming,LP)</h3><ul><li><p><strong>特征：</strong>这是最基础、最经典的一类优化模型。它的核心特征是“线性”，具体说就是：</p><ol type="1"><li><p><strong>目标函数是线性的</strong>：比如求 <spanclass="math inline">\(max Z = 2x + 3y\)</span>。</p></li><li><p><strong>所有约束条件也都是线性的</strong>：比如 <spanclass="math inline">\(x + y &lt;= 10\)</span>，<spanclass="math inline">\(x - y &gt;= 0\)</span> 等。</p></li><li><p>决策变量 <code>x, y</code> 是连续的，可以取小数。</p></li></ol></li><li><p><strong>思路：</strong></p><ul><li><p><strong>几何直观</strong>：所有线性约束在坐标系里画出来，会围成一个多边形（二维）或多面体（高维），这叫“可行域”。理论已经证明，最优解一定在这个多边形的某个顶点上取到。</p></li><li><p><strong>核心算法</strong>：<strong>单纯形法 (SimplexMethod)</strong>。这个方法非常巧妙，它从可行域的一个顶点开始，沿着边走到一个更好的顶点，一步步迭代，直到找到最优的顶点，效率很高。现在大规模的线性规划问题通常用<strong>内点法(Interior Point Method)</strong> 求解。</p></li></ul></li></ul><p>但是我怎么感觉这类的话，最多出个第一小问呢，感觉用处不大。</p><h3 id="整数规划-integer-programming-ip">2. 整数规划 (IntegerProgramming, IP)</h3><ul><li><p><strong>特征：</strong>它是在线性规划的基础上，增加了一个或多个决策变量必须是整数的约束。</p><ul><li><p>如果<strong>所有</strong>决策变量都必须是整数，称为<strong>纯整数规划(Pure IP)</strong>。</p></li><li><p>如果<strong>部分</strong>决策变量需要是整数，另一部分可以是连续的，称为<strong>混合整数线性规划(Mixed-Integer Linear Programming, MILP)</strong>。</p></li><li><p>最特殊的一种是 <strong>0-1 整数规划</strong>，决策变量只能取 0 或1，常用于表示“是/否”、“选/不选”这类决策。</p></li></ul></li><li><p><strong>思路：</strong></p><ul><li><p>千万不要以为四舍五入就行！对线性规划的结果取整，很可能得到一个不可行或者很差的解。</p></li><li><p>整数规划的求解难度比线性规划高得多，属于NP-hard问题。</p></li><li><p><strong>核心算法</strong>：<strong>分支定界法 (Branch andBound)</strong> 和 <strong>割平面法 (Cutting PlaneMethod)</strong>。分支定界法可以理解为一种“聪明的穷举”，它不断地把问题分解成小问题（分支），并利用线性规划的解来判断哪些分支可以提前放弃（定界），从而避免了无谓的搜索。</p></li></ul></li></ul><h3 id="非线性规划-nonlinear-programming-nlp">3. 非线性规划 (NonlinearProgramming, NLP)</h3><p>当目标函数或约束条件中，只要有一个不是线性的，就进入了非线性规划的范畴。它的世界比线性规划复杂得多。</p><h4 id="无约束非线性规划">3.1 无约束非线性规划</h4><ul><li><p><strong>特征：</strong>目标函数是<strong>非线性</strong>的，但<strong>没有任何约束条件</strong>。用人话讲，就是在整个定义域里自由地寻找函数的最高点或最低点。</p></li><li><p><strong>思路：</strong></p><ul><li><p>这就是微积分大显身手的地方。对于可导函数，我们寻找<strong>梯度(Gradient)</strong> 为零的点，即 <code>∇f(x) = 0</code>的点，这些是可能的极值点（驻点）。</p></li><li><p><strong>核心算法</strong>：各种<strong>迭代下降算法</strong>。从一个初始点开始，每一步都朝着能让函数值减小（或增大）最快的方向走一小步，不断逼近最优点。经典算法包括：</p><ul><li><p><strong>梯度下降法 (GradientDescent)</strong>：最简单，就是沿着梯度的反方向走。</p></li><li><p><strong>牛顿法 (Newton'sMethod)</strong>：考虑了二阶导数（Hessian矩阵），收敛更快，但计算量更大。</p></li><li><p><strong>共轭梯度法 (Conjugate Gradient Method)</strong>等。</p></li></ul></li></ul></li></ul><h4 id="约束非线性规划">3.2 约束非线性规划</h4><ul><li><p><strong>特征：</strong>目标函数和/或约束条件中至少有一个是<strong>非线性</strong>的，并且存在<strong>约束条件</strong>。这是现实世界中最常见也最复杂的一类问题。</p></li><li><p><strong>思路：</strong></p><ul><li><p>处理约束是关键。你提到的<strong>拉格朗日乘数法</strong>就是处理等式约束的经典理论基础，它的思想是把一个有约束的问题，转化为一个更大的无约束问题（构造拉格朗日函数）来求解。</p></li><li><p>对于不等式约束，则需要用到更复杂的 <strong>KKT(Karush-Kuhn-Tucker) 条件</strong>，它是拉格朗日乘数法的推广。</p></li><li><p><strong>核心算法</strong>：求解方法非常多样，比如<strong>序列二次规划(Sequential Quadratic Programming, SQP)</strong>、<strong>内点法(Interior Point Method)</strong>、<strong>罚函数法 (PenaltyMethod)</strong>等。这些算法通常都非常复杂，依赖于成熟的优化求解器。</p></li></ul></li></ul><h3 id="二次规划-quadratic-programming-qp">4. 二次规划 (QuadraticProgramming, QP)</h3><ul><li><p><strong>特征：</strong>这是非线性规划中一个特别且重要的小类。它的目标函数是<strong>二次函数</strong>，而所有约束条件依然是<strong>线性</strong>的。</p></li><li><p><strong>思路：</strong>因为它的结构比较“良善”（目标函数是二次的，约束是线性的），所以有比一般非线性规划更高效的特定算法，例如<strong>有效集法(Active SetMethod)</strong>。它在金融（如投资组合优化）、机器学习（如支持向量机SVM）等领域有广泛应用。</p></li></ul><h3 id="动态规划-dynamic-programming-dp">5. 动态规划 (DynamicProgramming, DP)</h3><ul><li><p><strong>特征：</strong>严格来说它是一种求解问题的思想，但常用于解决一类多阶段决策的最优化问题。这类问题的决策过程可以分解成一系列相互关联的阶段，前一个阶段的决策会影响后一个阶段的状态。</p></li><li><p><strong>思路：</strong></p><ul><li><p><strong>核心思想</strong>：<strong>最优子结构</strong> 和<strong>重叠子问题</strong>。它不是一次性做出所有决策，而是从后往前（或从前向后）分阶段求解。首先解决最后一个阶段的最优决策，然后带着这个信息，去求解倒数第二个阶段……直到回到起点。</p></li><li><p>通过记录和复用子问题的解（通常用一个表格），避免了重复计算，大大提高了效率。背包问题、最短路径问题都是动态规划的经典应用。</p></li></ul></li></ul><h3 id="组合优化-combinatorial-optimization">6. 组合优化 (CombinatorialOptimization)</h3><ul><li><p><strong>特征：</strong><strong>就是找各种组合的最优方案，比如分配土地使用策略（24年C题）</strong>。这不是一种具体的问题，而是一大类问题。它的核心特征是决策变量是<strong>离散的</strong>，并且可行解的数量是有限的（但通常是天文数字）。它要解决的问题不是在一条连续的曲线上找最低点，而是在众多可能性中“组合”出一个最佳方案。</p><ul><li><p>用人话讲，就是做“选择题”或“排序题”。比如：从100个项目中选出10个进行投资，怎么选才能收益最大？（选择）或者，安排一个生产车间里10个工序的加工顺序，怎么排才能总时间最短？（排序）</p></li><li><p>上面讲到的<strong>整数规划</strong>，以及下面要讲的<strong>选址问题</strong>、<strong>TSP问题</strong>，都属于组合优化的范畴。</p></li></ul></li><li><p><strong>思路：</strong>组合优化问题的求解思路五花八门，取决于问题的具体结构和难度。</p><ul><li><p><strong>精确算法 (ExactAlgorithms)</strong>：目标是找到绝对的最优解。</p><ul><li><p>对于一些“简单”的问题（比如求图的最小生成树），有多项式时间算法（见下文）可以快速求解。</p></li><li><p>对于大部分“困难”的问题（即NP-hard问题），精确算法（如动态规划、分支定界法）的计算时间会随着问题规模的增长而爆炸，只适用于小规模情况。</p></li></ul></li><li><p><strong>近似算法 (ApproximationAlgorithms)</strong>：退而求其次，不去寻找“最好”的解，而是寻找一个“足够好”的解。这类算法速度快，并且能从理论上保证它给出的解与最优解的差距不会超过一个特定的比例。</p></li><li><p><strong>启发式算法(Heuristics/Metaheuristics)</strong>：当问题规模太大，精确算法跑不动，又没有好的近似算法时，就轮到启发式算法登场了。它们是一些基于直觉或经验的“聪明”搜索策略，比如模拟退火、遗传算法、蚁群算法等。它们通常能快速找到一个不错的解，但不能保证这个解有多好，有可能陷入局部最优。在工程实践中应用极为广泛。</p></li></ul></li></ul><h4 id="选址问题-facility-location-problem">6.1 选址问题 (FacilityLocation Problem)</h4><ul><li><p><strong>特征：</strong>这是组合优化中一类非常经典的问题。它的典型场景是：有一批潜在的设施点（比如仓库、基站、超市）和一批客户点，目标是决定<strong>在哪里建设施</strong>、<strong>建多少个</strong>，以及<strong>每个客户由哪个设施来服务</strong>，从而在满足所有客户需求的前提下，使得总成本（如建设成本+运输成本）最低。</p></li><li><p><strong>思路：</strong></p><ul><li><p>选址问题通常被建模为<strong>混合整数线性规划(MILP)</strong>。</p></li><li><p>其中，是否在某个地点建设施，可以用一个<strong>0-1整数变量</strong>来表示（1代表建，0代表不建）。</p></li><li><p>而每个客户点由哪个设施来服务，可以用另外的变量来表示。</p></li><li><p>模型建好后，就可以调用成熟的优化求解器（如 Gurobi,CPLEX）来求解。对于大规模问题，同样需要设计专门的近似算法或启发式算法。</p></li></ul></li></ul><h4 id="tsp-旅行商问题-traveling-salesperson-problem">6.2 TSP(旅行商问题, Traveling Salesperson Problem)</h4><ul><li><p><strong>特征：</strong>这是组合优化里最著名、最典型的“明星问题”。</p><ul><li><p><strong>问题描述</strong>：一个旅行商人要拜访 n个城市，他必须从一个城市出发，访问<strong>每一个城市恰好一次</strong>，最后再回到出发的城市。问题是：他应该按照什么样的顺序访问这些城市，才能使得总的旅行路程最短？</p></li><li><p>用人话讲，就是“一笔画”走遍所有点，怎么走路线最短。TSP是<strong>NP-hard问题</strong>的杰出代表，意味着当城市数量稍微多一点（比如几十个），想要靠暴力枚举所有路径来找到最优解就已是天方夜谭。</p></li></ul></li><li><p><strong>思路：</strong></p><ul><li><p><strong>精确算法</strong>：对于城市数量较少（例如20个以内）的情况，可以使用<strong>动态规划（如Held-Karp算法）</strong>或 <strong>分支定界法</strong> 求得最优解。</p></li><li><p><strong>近似与启发式算法</strong>：对于大规模的TSP问题，几乎总是使用这两类算法。</p><ul><li><p><strong>近似算法</strong>：例如<strong>Christofides算法</strong>，可以保证找到的路径长度不会超过最优路径的1.5倍。</p></li><li><p><strong>启发式算法</strong>：比如“贪心”策略（每次都走向最近的未访问过的城市）、2-opt/3-opt（随机交换路径中的2条或3条边，看是否能改进路线），以及更高级的遗传算法、模拟退火等，都能在合理的时间内找到非常接近最优解的路径。</p></li></ul></li></ul></li></ul><hr /><p><em>接下来这两个概念是串联起来的，它们更多地是关于“算法效率”的分类，而不是“优化模型”的分类，但对于理解一个优化问题能否“解决”至关重要。</em></p><h3 id="多项式时间算法-polynomial-time-algorithm-p问题">7.多项式时间算法 (Polynomial-Time Algorithm) &amp; P问题</h3><ul><li><p><strong>特征：</strong>一个算法的运行时间（或计算步骤数）上界，可以表示为问题输入规模<code>n</code> 的一个多项式函数，即 <spanclass="math inline">\(O(n^k)\)</span>，其中 k 是一个常数。</p><ul><li><p>用人话讲，就是这个算法<strong>很高效</strong>。当问题规模<code>n</code> 变大时，它的计算时间增长得比较“温和”，不会失控。比如<span class="math inline">\(O(n^2)\)</span>, <spanclass="math inline">\(O(n^3)\)</span> 都是多项式时间。相比之下，指数时间<span class="math inline">\(O(2^n)\)</span> 增长得就非常恐怖。</p></li><li><p>所有可以由多项式时间算法解决的<strong>判定问题</strong>（回答是/否的问题），构成了一个集合，称为<strong>P类问题(Polynomialtime)</strong>。P问题通常被认为是“可以有效解决的”或“计算上易解的”问题。</p></li><li><p><strong>注意</strong>：线性规划就是一个P问题（虽然单纯形法在最坏情况下是指数时间，但内点法是多项式时间的）。</p></li></ul></li></ul><h3 id="非确定性多项式-nondeterministic-polynomial-np问题">8.非确定性多项式 (Nondeterministic Polynomial) &amp; NP问题</h3><ul><li><p><strong>特征：</strong>这个名字听起来很玄乎，但核心思想不复杂。它描述的是这样一类判定问题：</p><ol type="1"><li><p>直接找到它的解可能非常困难（目前不知道有没有多项式时间算法）。</p></li><li><p>但是，如果有人给了你一个<strong>声称是解的答案</strong>，你可以在<strong>多项式时间内验证</strong>这个答案对不对。</p></li></ol><ul><li><p>用人话讲：<strong>“解答”难，但“验算”容易。</strong></p></li><li><p>这类问题的集合，就叫<strong>NP类问题 (Nondeterministic Polynomialtime)</strong>。</p></li></ul></li><li><p><strong>举例：</strong>TSP的判定版本：“是否存在一条长度小于L的旅行路线？”</p><ul><li><p><strong>解答难</strong>：让你直接找出这条路来，非常困难。</p></li><li><p><strong>验算容易</strong>：如果我给你画出一条具体的路线，你只需要把路径上的各段距离加起来，看看总和是不是小于L。这个加法运算是非常快的（多项式时间）。</p></li><li><p>因此，TSP属于NP问题。</p></li></ul></li><li><p><strong>重要关系</strong>：</p><ul><li><p>所有P问题都是NP问题（因为如果我能快速解答，自然也能快速验算）。</p></li><li><p>但NP问题是不是都是P问题？即，<strong>P = NP?</strong>这就是计算机科学领域最核心的百万美元大奖难题。目前普遍认为 P ≠NP，也就是说，存在一大批“只能快速验算，不能快速解答”的难题。</p></li><li><p>在NP问题中，最难的一批问题被称为<strong>NP完全问题(NP-Complete)</strong>。TSP就是一个NP完全问题。如果我们能为任何一个NP完全问题找到多项式时间解法，那么所有的NP问题都能迎刃而解。</p></li><li><p>而那些比NP完全问题“至少一样难”的<strong>优化问题</strong>（不仅仅是判定问题），就被称为<strong>NP-hard</strong>问题。</p></li></ul></li></ul><h2 id="最优化方法">最优化方法</h2><h4 id="微积分中的最优化方法">微积分中的最优化方法</h4><p>首先要讲的是一元二元三元函数导数为零取极值的东西，在这里就不细讲。</p><p>然后是拉格朗日数乘法求解附加有条件的极值，这个在写一遍：</p><p>要找函数 <span class="math inline">\(z= f(x,y)\)</span> 在条件 <spanclass="math inline">\(\phi(x,y)=0\)</span> 下的可能极值点，先构造函数<span class="math inline">\(F(x,y)=f(x,y)+\lambda \phi(x,y)\)</span>，其中 <span class="math inline">\(\lambda\)</span> 为某一常数;</p><p>可由</p><p><span class="math display">\[\begin{cases}f_x(x, y) + \lambda \varphi_x(x, y) = 0, \\f_y(x, y) + \lambda \varphi_y(x, y) = 0, \\\varphi(x, y) = 0.\end{cases}\]</span></p><p>解出 <span class="math inline">\(x,y,\lambda\)</span> ，其中 <spanclass="math inline">\(x,y\)</span> 就是可能的极值点的坐标.</p><h4 id="启发式算法-heuristics">启发式算法 (Heuristics)</h4><p>一个基于直观或经验构造的算法，在可接受的花费(指计算时间、占用空间等)下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度不一定事先可以预计.</p><p>用人话讲，启发式算法就是一套“经验法则”或“捷径”。当一个问题太复杂，我们找不到完美的“最优解”，或者找最优解太花时间，启发式算法就能帮我们快速找到一个“还不错的”、“八九不离十”的解。它追求的是效率和实用性，牺牲了一定的最优性保证。</p><h5 id="算法解释">算法解释</h5><p><strong>1. 贪心算法 (Greedy Algorithm)</strong></p><ul><li><p><strong>概念：</strong> 一种只顾眼前的算法。它在做决策时，总是做出当前看起来最好的选择，而不去考虑这个选择对未来的影响。它希望通过每一步的局部最优，最终能达到全局最优。这个算法总是想要获取局部最优解。对于某些特定布局的情况，这个策略确实是最好的。但对于大多数复杂布局，这种“短视”会导致它错过全局最优的路线，甚至绕个大圈。</p></li><li><p><strong>应用场景：</strong> 虽然贪心算法不总是对的，但在某些问题上（如求最小生成树的Prim和Kruskal算法、求单源最短路径的Dijkstra算法）它却能奇迹般地得到最优解。</p></li></ul><p><strong>2. 邻域搜索算法 (Neighborhood Search) 或 爬山算法 (HillClimbing)</strong></p><ul><li><p>找局部最优-&gt;移动到局部最优-&gt;重新找局部最优。直到周围再也找不到更好的解为止。</p></li><li><p><strong>思路比喻（来自gemini2.5pro）：</strong> 想象你在一个浓雾弥漫的山脉里，想找到最高的山峰。你被随机空投到一个位置，你唯一能做的就是环顾四周，朝着脚下能迈出的、坡度最陡峭的向上方向走一步。你不断地重复这个过程，一步步“爬山”。最终，你会到达一个山顶，因为你再往任何方向走都是下坡路了。</p></li><li><p><strong>核心缺陷：</strong> 容易落入局部最优解就停止寻找全局最优解。</p></li></ul><p><strong>3. 模拟退火算法 (Simulated Annealing, SA)</strong></p><ul><li><p>为了克服爬山算法容易陷入局部最优的缺陷，模拟退火算法被设计了出来。它在邻域搜索的基础上，引入了“随机性”和“概率性”的跳出机制。</p></li><li><p><strong>思路比喻：</strong> 这个过程模拟了金属冶炼中“退火”的过程：先高温融化，再缓慢冷却，让内部分子找到能量最低的稳定结构。还是那个浓雾里爬山的例子。这次你不是一个稳健的登山者，而是一个“喝了酒的登山者”。在刚开始（温度高）的时候，你处于微醺状态，精力旺盛，大部分时间会往高处走，但偶尔也会晃晃悠悠地往山下走几步。这种“犯糊涂”的行为，恰好给了你一个机会，能够走出那个小山丘的范围，去探索远处的其他山峰。随着时间推移（温度降低），你的酒劲儿慢慢过去，变得越来越清醒和稳健，最终只选择向上走，直到找到一个你认为最高的山峰。</p></li></ul><p><strong>4. 遗传算法 (Genetic Algorithm, GA)</strong></p><ul><li><p>一种模仿生物界“物竞天择，适者生存”进化规律的算法。它不是只维护一个解，而是一次性维护一大群解（称为“种群”），然后让这个种群通过一代代的“繁衍”和“淘汰”来进化，最终整个种群的质量都会越来越高，从而找到问题的优秀解。</p></li><li><p>把它想象成一个“育种农场”：</p><ol type="1"><li><p><strong>初始种群：</strong> 你随机培育出第一批各种各样的种子（初始解）。</p></li><li><p><strong>适应度评估：</strong> 把这些种子种下去，看哪个长得最好（哪个解更优）。</p></li><li><p><strong>选择：</strong> 优先选择那些长得好的种子作为下一代的“父母”。</p></li><li><p><strong>交叉/繁殖：</strong> 让这些优秀的“父母”互相杂交，产生“后代”。后代会继承父母双方的优良基因（解的优秀特征）。</p></li><li><p><strong>变异：</strong> 在繁殖过程中，允许有极小的概率发生基因突变，给种群带来新的多样性，防止所有种子都长得一样。经过成千上万代的“优胜劣汰”和“繁衍进化”，你的农场里最终会培育出超级品种。</p></li></ol></li></ul><h5 id="长处">长处</h5><p>简单易行；比较直观；易被使用者接受。</p><p>速度快，在实时管理中非常重要。</p><p>多数情况下，程序简单，因此易于修改。</p><h5 id="短处">短处</h5><p>不能保证求得最优解。</p><p>表现不稳定。启发式算法在同一问题的不同实例计算中会有不同的效果，有些解好，而有些则很差，在实际应用中，这种不稳定性造成计算结果不可信。</p><p>算法的好坏依赖于实际问题、经验和设计者的技术，这一点很难总结规律，同时使不同算法之间难以比较。</p><h3 id="现代优化算法-metaheuristics">现代优化算法 (Metaheuristics)</h3><p>当问题变得极其复杂时，传统的启发式算法（如贪心、爬山）可能会显得力不从心。现代优化算法，通常也称为<strong>元启发式算法(Metaheuristics)</strong>，提供了一套更高层次的、用于指导和改进底层启发式搜索过程的策略框架。它们通常受到自然现象的启发，更加强大和智能。</p><p><strong>1. 禁忌搜索 (Tabu Search)</strong></p><ul><li><p>它是对“爬山算法”的一个极佳的改进。爬山算法最大的问题是容易被“小山丘”（局部最优解）困住，而禁忌搜索的核心思想就是要有“记忆力”，能帮助搜索过程跳出这个陷阱。</p></li><li><p>再次回到那个浓雾里爬山的例子。爬山算法让你停在第一个找到的山顶。而禁忌搜索的登山者会带一个“<strong>禁忌列表</strong>”（TabuList），就像一本小黑本。</p><ol type="1"><li><p>当你从一个位置 A 移动到更好的位置 B时，你会在小黑本上记下：“刚刚从 A 走过来，短期内禁止再走回 A”。</p></li><li><p>这样一来，即使 B所在的这个小山丘的周围都是下坡路，你因为被禁止走回头路，就被<strong>迫</strong>去探索其他的、以前没走过的下坡路。</p></li><li><p>这一个“被迫”的操作，就给了你一个机会，让你能够先下山，再从另一侧登上旁边那座可能更高的山峰。</p></li></ol><p>通过这种“记住走过的路，短期内不走回头路”的机制，禁忌搜索大大增强了跳出局部最优的能力。</p></li></ul><p><strong>2. 人工神经网络 (Artificial Neural Networks,ANN)</strong></p><ul><li><p>它本身不是一个直接求解优化问题的算法，而是一种模仿人脑神经元连接方式的计算模型。但在优化领域，它扮演着两个关键角色。</p></li><li><p><strong>角色一：它本身就是一个巨大的优化问题。</strong></p><ul><li>他本身就是一个巨大的优化问题，现在ai领域的各种涨点比赛就是为了进一步优化他。</li></ul></li><li><p><strong>角色二：它可以作为优化问题的辅助工具。</strong></p><ul><li>当一个优化问题的目标函数或约束条件复杂到无法写出数学表达式时（比如预测一个化工过程的产率），我们可以先训练一个神经网络来学习输入（原料配比）和输出（产率）之间的关系。然后，这个训练好的神经网络就成了一个“代理模型”，我们转而去优化这个神经网络的输入，以获得最高的预测产率。</li></ul></li></ul><p><strong>3. 蚁群优化算法 (Ant Colony Optimization, ACO)</strong></p><ul><li><p><strong>这是什么：</strong>一种模拟真实蚂蚁群体寻找食物过程的算法，特别擅长解决在图上寻找最优路径一类的问题（比如旅行商问题TSP）。</p></li><li><p><strong>思路比喻：</strong>这个比喻非常直观，因为它就是算法的来源。</p><ol type="1"><li><p><strong>初始探索：</strong>蚁巢和食物之间有多条路径，一开始，蚂蚁们会随机地向各个方向探索。</p></li><li><p><strong>信息素释放：</strong>蚂蚁在走过的路上会留下一种叫“信息素”的化学物质。</p></li><li><p><strong>正反馈循环：</strong>假设有A、B两条路，A路比B路短。走A路的蚂蚁，会更快地往返于蚁巢和食物之间。因此，在相同时间内，A路上的蚂蚁往返次数更多，留下的信息素浓度也就会越来越高。</p></li><li><p><strong>路径选择：</strong>后续出发的蚂蚁闻到信息素，更倾向于选择浓度高的路径。这就导致越来越多的蚂蚁被吸引到A路上去，A路的信息素进一步增强。</p></li><li><p><strong>收敛：</strong>经过这样一个正反馈过程，整个蚁群很快就能共同“发现”并锁定那条最短的路径。算法中的“虚拟蚂蚁”就是通过模拟这个过程来构造出问题的优良解。</p></li></ol></li></ul><h3 id="图论-graph-theory">图论 (Graph Theory)</h3><p>在优化领域，很多问题都可以抽象成一个图。比如，城市交通网络、社交关系网、任务依赖关系等。图论就是研究这些“点”和“线”组成的结构的数学分支。</p><h4 id="基础知识">基础知识</h4><p>首先，我们要明确，这里的“图”不是指柱状图、饼状图，而是指由<strong>顶点(Vertex)</strong> 和连接顶点的<strong>边 (Edge)</strong>组成的数学对象。</p><ul><li><strong>无向图 (Undirected Graph)</strong><ul><li><p><strong>定义：</strong> 图中的边是没有方向的。如果顶点 A 和顶点 B之间有一条边，那么你可以从 A 到 B，也可以从 B 到 A。</p></li><li><p>就是“双向关系”。比如微信好友关系，你是我的好友，我必然也是你的好友。连接你我的那条线不带箭头。</p></li></ul></li><li><strong>有向图 (Directed Graph)</strong><ul><li><p><strong>定义：</strong>图中的边是有方向的，用箭头表示。如果有一条从 A 指向 B的边，意味着你可以从 A 到 B，但不能从 B 到A（除非还有一条反向的边）。</p></li><li><p>就是“单向关系”。比如微博的“关注”，我关注了你，但你不一定关注我。连接我俩的线必须带个箭头，表明关系的方向。城市里的单行道网络也是一个典型的有向图。</p></li></ul></li><li><strong>无向赋权图 (Undirected Weighted Graph)</strong><ul><li><p><strong>定义：</strong>在无向图的基础上，给每一条边都赋予一个数值，称为“权重”或“成本”。</p></li><li><p>不仅关系是双向的，而且这个关系还有个“度量”。比如一张城市地图，城市是顶点，连接城市的道路是边。道路是双向通行的（无向），每条道路的长度（公里数）就是它的权重。</p></li></ul></li><li><strong>有向赋权图 (Directed Weighted Graph)</strong><ul><li><p><strong>定义：</strong>在有向图的基础上，给每一条带方向的边赋予一个权重。</p></li><li><p>关系是单向的，并且这个单向关系有度量。比如一张机票价格图，城市是顶点，从A 飞往 B 的航班是一条有向边，这张机票的价格就是权重。注意，从 A 到 B的票价和从 B 到 A 的票价通常是不同的。</p></li></ul></li><li><strong>邻接矩阵 (Adjacency Matrix)</strong><ul><li><p><strong>定义：</strong> 一种用矩阵来表示图的方法。对于一个有 n个顶点的图，我们可以创建一个 n x n 的矩阵。矩阵的第 i 行第 j 列的元素<code>A[i][j]</code> 表示顶点 i 和顶点 j 之间的连接关系。</p></li><li><p>就是一张“连接关系表”。</p><ul><li><p>对于<strong>无权图</strong>：如果顶点 i 和 j 之间有边，那么<code>A[i][j] = 1</code>，否则为 0。</p></li><li><p>对于<strong>赋权图</strong>：如果顶点 i 和 j 之间有边，那么<code>A[i][j]</code>就等于这条边的权重，否则可以是一个特殊值（比如无穷大 ∞）。</p></li></ul></li><li><p>这个矩阵非常直观，但如果图很“稀疏”（边很少），用矩阵存储会浪费大量空间。</p></li></ul></li></ul><h4 id="最短路径-shortest-path">最短路径 (Shortest Path)</h4><ul><li><p>在一个赋权图（有向或无向）中，找到从一个起始顶点到一个目标顶点，所经过的边的权重之和最小的那条路径。这个“权重”可以是距离、时间、成本、或者任何可以累加的度量。就是导航。</p></li><li><p><strong>核心算法与分类：</strong></p><ul><li><p><strong>单源最短路径 (Single-Source Shortest Path -SSSP):</strong> 计算从一个固定的起点（源点）到图中所有其他顶点的最短路径。</p><ul><li><p><strong>Dijkstra算法(迪杰斯特拉算法):</strong> 最经典的SSSP算法。它的策略是<strong>贪心算法</strong>。</p><ul><li><p><strong>思路：</strong> 想象你在起点，手上有一个“已确定最短路径”的区域，初始时只有你自己。算法每次都从这个区域的边缘向外“扩张”，选择一个离起点最近的、尚未被纳入区域的顶点，将它纳入，并更新它所有邻居到起点的距离。这个过程就像水波纹一样，从起点开始，一圈圈地蔓延，直到覆盖所有你想去的顶点。</p></li><li><p><strong>重要限制：</strong> Dijkstra算法非常高效，但它有一个致命弱点——<strong>不能处理带有负权重边的图</strong>。因为它的贪心策略一旦将一个点纳入“已确定”区域，就不会再回头看它，而负权边可能会让这个“确定”变得不确定。</p></li></ul></li><li><p><strong>Bellman-Ford算法(贝尔曼-福特算法):</strong> 更强大的SSSP算法，可以处理带有负权重边的情况。</p><ul><li><p><strong>思路：</strong> 它不搞贪心，而是采用一种“暴力”的迭代松弛策略。它对图中的每一条边，都反复进行“松弛”操作（检查并更新通过这条边能否让终点离源点更近），这个过程会重复 <code>V-1</code> 遍（V是顶点数量）。它的思想是，一条最短路径最多包含 <code>V-1</code> 条边，所以经过 <code>V-1</code> 轮迭代，一定能把最短路径的距离传递到终点。</p></li><li><p><strong>额外功能：</strong> Bellman-Ford算法还有一个独门绝技——<strong>可以检测图中是否存在负权环</strong>。如果在 <code>V-1</code> 轮迭代后，还能继续松弛某条边，那就说明图里存在一个“越走权重越小”的怪圈，这种情况下最短路径没有意义（可以无限刷分）。</p></li></ul></li></ul></li><li><p><strong>所有顶点对之间的最短路径 (All-Pairs Shortest Path -APSP):</strong> 计算图中任意两个顶点之间的最短路径。</p><ul><li><p><strong>Floyd-Warshall算法(弗洛伊德算法):</strong> 解决APSP问题的经典算法，思想是<strong>动态规划</strong>。</p><ul><li><strong>思路：</strong> 它的思考方式非常巧妙。它问自己一个问题：“从顶点i 到顶点j，如果只允许经过顶点1作为中转站，最短路径是多少？”，“如果允许经过顶点1和2作为中转站，最短路径又是多少？”……它通过迭代，不断地增加“允许被用作中转站”的顶点，来更新任意两点i 和 j之间的最短距离。当所有顶点都被考虑为中转站后，就得到了最终所有点对之间的最短路径。它的代码实现极其简洁优美。</li></ul></li></ul></li></ul></li></ul><h4 id="行遍性问题-traversability-problem">行遍性问题 (TraversabilityProblem)</h4><ul><li><p>探讨如何不重复地走遍一个图的所有边或所有顶点。它不关心路径的“长短”，只关心“能不能走完”以及“怎么走”。就是“一笔画”</p></li><li><p><strong>两个经典问题：</strong></p><ul><li><p><strong>欧拉路径/回路 (Eulerian Path/Circuit):</strong></p><ul><li><p><strong>问题：</strong> 能不能找到一条路径，恰好<strong>走过图中的每一条边一次</strong>？如果这条路径的起点和终点是同一个点，就称为<strong>欧拉回路</strong>；如果起点和终点不同，就称为<strong>欧拉路径</strong>。</p></li><li><p><strong>怎么判断：</strong> 这个问题有非常简单明确的判定方法，这要归功于大数学家欧拉。关键在于看每个顶点的<strong>度(Degree)</strong>，也就是连接这个顶点的边的数量。</p><ul><li><p>对于<strong>无向图</strong>：</p><ul><li><p>如果所有顶点的度都是<strong>偶数</strong>，那么一定存在欧拉回路（可以从任意点出发，最终回到该点）。</p></li><li><p>如果恰好有两个顶点的度是<strong>奇数</strong>，那么存在欧拉路径（必须从一个奇数度顶点出发，在另一个奇数度顶点结束）。</p></li><li><p>其他情况（奇数度顶点超过2个），则不存在一笔画走完所有边的路径。</p></li></ul></li></ul></li><li><p><strong>现实应用：</strong> 城市扫雪车或邮递员的路线规划。目标是走遍每一条街道，且总路程最短（即不走重复路），这就是一个典型的欧拉回路问题。</p></li></ul></li><li><p><strong>哈密顿路径/回路 (Hamiltonian Path/Circuit):</strong></p><ul><li><p><strong>问题：</strong> 能不能找到一条路径，恰好<strong>经过图中的每一个顶点一次</strong>？如果这条路径的起点和终点是同一个点，就称为<strong>哈密顿回路</strong>。</p></li><li><p><strong>怎么判断：</strong> 这个问题和欧拉问题看起来很像，但难度却是天壤之别。<strong>哈密顿问题是著名的NP完全问题</strong>，目前没有任何简单的、通用的判定法则。我们无法像检查顶点的度那样，快速判断一个图是否存在哈密顿路径。</p></li><li><p><strong>现实应用：</strong> 我们前面提过的<strong>旅行商问题(TSP)</strong>，其实就是在一个赋权完全图中寻找权重最小的<strong>哈密顿回路</strong>。因为旅行商要求访问每个城市（顶点）恰好一次，并最终返回起点。</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>综述概要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>江协STM32笔记（二）</title>
    <link href="/2025/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B1%9F%E5%8D%8FSTM32%E5%85%A5%E9%97%A8/%E6%B1%9F%E5%8D%8FSTM32%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/08/12/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B1%9F%E5%8D%8FSTM32%E5%85%A5%E9%97%A8/%E6%B1%9F%E5%8D%8FSTM32%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这边建议看我这篇笔记的话不如去看江协的课程：</p><ul><li><ahref="https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.1387.0.0&amp;vd_source=35efa20a3dc2d6382913a782f2bf8ad8">STM32入门教程-2023版细致讲解 中文字幕_哔哩哔哩_bilibili</a></li></ul><h2 id="oled">OLED</h2><p>OLED（Organic Light Emitting Diode）：有机发光二极管</p><p>供电：3~5.5V，通信协议：I2C/SPI，分辨率：128*64</p><p>然后这边是江协给的库函数文件，我也没改也没看，直接拿过来用：</p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508121203347.png"alt="image.png" /> <imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508121204619.png"alt="image.png" /></p><h2 id="中断">中断</h2><h3 id="概念">概念</h3><p>中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p><p>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p><p>在stm32里面中断优先级会有很多的分类，然后根据这个分类来配置具体的中断优先级。</p><p>中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回<imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508121300473.png"alt="image.png" /></p><h3 id="stm32中断">stm32中断</h3><p>包含68个可屏蔽中断通道（即中断源，这个68个是F1系列的上限，具体的还要看型号是多少个），包含EXTI（外部中断，即外设控制的中断）、TIM、ADC、USART、SPI、I2C、RTC等多个外设</p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508132216720.png"alt="image.png" /> <imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508132216642.png"alt="image.png" /> <imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508132216679.png"alt="image.png" /></p><p>使用NVIC（嵌套中断向量控制器）统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级</p><p>其中抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p><p>NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508132218279.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508132220308.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="extiafio">EXTI、AFIO</h3><p>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p><p>如果CPU是医生，NVIC就是叫号机，然后EXTI就是护士站里面负责观察情况叫号排号的。</p><p>支持的触发方式：上升沿/下降沿/双边沿/软件触发</p><p>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断，具体的原因实际上是因为AFIO是个数据选择器，在相同的Pin下只能从GPIOA</p><p>而具体的AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p><p>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p><p>触发响应方式：中断响应/事件响应</p><p>中断响应就是正常的触发CPU进行处理，而事件响应就是触发别的外设对来的这个事件进行响应。</p><p>后面四个是因为EXTI有能够从低功耗模式下唤醒的功能，然后顺便加上的功能</p><p>下面这个图是做外部中断时候的重中之重，记住他就记住了总体怎么配置怎么写：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508121301547.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="硬件模块">硬件模块</h3><h4 id="旋转编码器">旋转编码器</h4><p>旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向</p><p>类型：机械触点式/霍尔传感器式/光栅式</p><p>然后我们使用的旋转编码器的具体阴间电路如下</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508132235702.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="库函数介绍">库函数介绍</h3><h4 id="stm32f10x_exti"><code>stm32f10x_exti</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI_DeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//重置exti为上电之后的默认状态，即缺省值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI_Init</span><span class="hljs-params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;<br><span class="hljs-comment">//初始化exti</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI_StructInit</span><span class="hljs-params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;<br><span class="hljs-comment">//给该结构体默认值，即按照缺省值填入参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI_GenerateSWInterrupt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span></span>;<br><span class="hljs-comment">//产生一个软件中断，参数的意味是使能或者失能这个线路中断</span><br><span class="hljs-function">FlagStatus <span class="hljs-title">EXTI_GetFlagStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span></span>;<br><span class="hljs-comment">//检查标志位设置与否</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI_ClearFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span></span>;<br><span class="hljs-comment">//挂起标志位</span><br><span class="hljs-function">ITStatus <span class="hljs-title">EXTI_GetITStatus</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span></span>;<br><span class="hljs-comment">//检查这个线路是否发生了中断触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI_ClearITPendingBit</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> EXTI_Line)</span></span>;<br><span class="hljs-comment">//清除挂起位</span><br></code></pre></td></tr></table></figure><h4 id="misc.h"><code>misc.h</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NVIC_PriorityGroupConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NVIC_PriorityGroup)</span></span>;<br><span class="hljs-comment">//设置NVIC优先级分组，标定程序是按照什么方式设置优先方式的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NVIC_Init</span><span class="hljs-params">(NVIC_InitTypeDef* NVIC_InitStruct)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NVIC_SetVectorTable</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> NVIC_VectTab, <span class="hljs-type">uint32_t</span> Offset)</span></span>;<br><span class="hljs-comment">//设置中断向量表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NVIC_SystemLPConfig</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> LowPowerMode, FunctionalState NewState)</span></span>;<br><span class="hljs-comment">//系统低功耗配置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SysTick_CLKSourceConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> SysTick_CLKSource)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="程序编写">程序编写</h3><h4 id="初始化">初始化</h4><p>具体就是从这个GPIO到NVIC一条线路配置调通就好。</p><p>首先是RCC配置外部时钟，这个配置AFIO和GPIO的就够了，其中NVIC和EXTI的时钟不用我们配置，具体原因EXTI不知道，NVIC是因为他是内核的外设，RCC管不到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOB, ENABLE);<br><span class="hljs-built_in">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_AFIO, ENABLE);<br><br>GPIO_InitTypeDef GPIO_InitStruct;<br>GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14;<br>GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;<br><span class="hljs-built_in">GPIO_Init</span>(GPIOB, &amp;GPIO_InitStruct);<br></code></pre></td></tr></table></figure><p>然后是配置AFIO的端口，具体为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);<br></code></pre></td></tr></table></figure><p>然后初始化EXTI给连接上，这个函数来自于<code>stm32f10x_exti.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">EXTI_InitTypeDef EXTI_InitStruct;<br>EXTI_InitStruct.EXTI_Line = EXTI_Line14;<br>EXTI_InitStruct.EXTI_LineCmd = ENABLE;<br>EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;<br>EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;<br><span class="hljs-built_in">EXTI_Init</span>(&amp;EXTI_InitStruct);<br></code></pre></td></tr></table></figure><p>配置优先级分组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">NVIC_PriorityGroupConfig</span>(NVIC_PriorityGroup_2);<br></code></pre></td></tr></table></figure><p>初始化NVIC</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">NVIC_InitTypeDef NVIC_InitStruct;<br>NVIC_InitStruct.NVIC_IRQChannel = EXTI15_10_IRQn;<br>NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;<br>NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number">1</span>;<br>NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">NVIC_Init</span>(&amp;NVIC_InitStruct);<br></code></pre></td></tr></table></figure><h4 id="中断函数">中断函数</h4><p>具体而言就是从<code>startup_stm32f10x_md.c</code>找这个中断向量表，这个中断函数都名称都是定好的</p><p>其中中断向量表是位于内存固定位置的一个数组。其每个表项（称为中断向量）存储着特定中断号对应的中断服务程序（ISR）的入口地址。当CPU接收到中断请求并获取中断号后，硬件自动以该中断号为索引访问此表，获取对应的ISR 入口地址并跳转执行，从而实现快速、准确的中断处理。</p><p>这里的用的是下面的这个，注意还要判别一下这个标志位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">EXTI_GetITStatus</span>(EXTI_Line14) == SET)<br>&#123;<br>CountSonser_Count++;<br><span class="hljs-built_in">EXTI_ClearITPendingBit</span>(EXTI_Line14);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>江协STM32入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>江协STM32入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>江协STM32笔记（一）</title>
    <link href="/2025/08/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B1%9F%E5%8D%8FSTM32%E5%85%A5%E9%97%A8/%E6%B1%9F%E5%8D%8FSTM32%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/08/11/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%B1%9F%E5%8D%8FSTM32%E5%85%A5%E9%97%A8/%E6%B1%9F%E5%8D%8FSTM32%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这边建议看我这篇笔记的话不如去看江协的课程：</p><ul><li><ahref="https://www.bilibili.com/video/BV1th411z7sn/?spm_id_from=333.1387.0.0&amp;vd_source=35efa20a3dc2d6382913a782f2bf8ad8">STM32入门教程-2023版细致讲解 中文字幕_哔哩哔哩_bilibili</a></li></ul><h2 id="简介">简介</h2><ul><li>STM32是ST公司基于ARMCortex-M内核开发的32位微控制器，用处有很多不细讲。</li><li>ARM既指ARM公司，也指ARM处理器内核</li><li>ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片</li></ul><p>本篇写的都是跟江协讲的对应，用的是STM32F103C8T6</p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111745925.png"alt="05ba1409-18a2-4715-ab13-edd1496230a3.png" /> <imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111942561.png"alt="image.png" /></p><ul><li>内核：ARM Cortex-M3</li><li>主频：72MHz</li><li>RAM(Random Access Memory)：20K（SRAM）</li><li>ROM(Read-Only Memory)：64K（Flash）</li><li>供电：2.0~3.6V（标准3.3V）</li><li>封装：LQFP48</li></ul><h3 id="片上资源">片上资源</h3><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111746199.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="引脚定义">引脚定义</h3><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111748229.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="系统结构">系统结构</h3><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111749052.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="启动配置">启动配置</h3><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111749557.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="最小系统电路">最小系统电路</h3><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111752749.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="c语言补充">C语言补充</h3><h4 id="数据类型">数据类型</h4><p>在这里面的数据类型就变成这个样子了，仔细看看就好</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508120027434.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h4 id="宏定义">宏定义</h4><p>这个就是用 <code>#define ABC 123</code>来为数字进行可读性的解释。</p><p>想法比较类似的还有 <code>typedef unsigned char uint8_t</code>，给比较长的变量类型名换个名字便于使用。</p><h4 id="枚举">枚举</h4><ul><li><p>关键字：enum</p></li><li><p>用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合</p></li><li><p>定义枚举变量：</p><p>enum{FALSE = 0, TRUE = 1} EnumName;</p><p>因为枚举变量类型较长，所以通常用typedef更改变量类型名</p></li><li><p>引用枚举成员：</p><p>EnumName = FALSE;</p><p>EnumName = TRUE;</p></li></ul><h2 id="新建工程步骤">新建工程步骤</h2><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111937570.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="工程架构">工程架构</h2><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508111938103.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="gpio部分">GPIO部分</h2><h3 id="基础知识">基础知识</h3><p>可根据需求配置为8种输入输出模式：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508112324208.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>详情见参考手册第110页</p><p>引脚电平：0V~3.3V，部分引脚可容忍5V</p><p>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</p><p>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p><p>stm32片上资源如下：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508112322193.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="库函数讲解">库函数讲解</h3><p>‘ 具体的话去翻参考文档里面的pdf文件以及原始库文件的注释</p><p>说实在的听江协的课实际上学的是他写这种工程文件的一种思维，了解我应该从什么入手，如何抽丝剥茧一般了解这些东西，完整的经历这样一个项目的周期。</p><p>所以这里只讲明所用到的库里面的各个函数是干什么的，不讲解如何去用，这个是开发的时候都事情。</p><p>stm32f10x_gpio.h：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_DeInit</span><span class="hljs-params">(GPIO_TypeDef* GPIOx)</span></span>; <br><span class="hljs-comment">//重置GPIO为缺省值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_AFIODeInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//将复用的GPIO重置为缺省值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_Init</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span>;<br><span class="hljs-comment">//初始化函数，其中这个GPIO_InitTypeDef是需要配置的GPIO的具体参数，这个具体看注释</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_StructInit</span><span class="hljs-params">(GPIO_InitTypeDef* GPIO_InitStruct)</span></span>;<br><span class="hljs-comment">//将参数按照缺省值填入结构体</span><br><br><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">GPIO_ReadInputDataBit</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span></span>;<br><span class="hljs-comment">//读取指定端口管脚的输入</span><br><br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">GPIO_ReadInputData</span><span class="hljs-params">(GPIO_TypeDef* GPIOx)</span></span>;<br><span class="hljs-comment">//带bit的就是微操，然后这个不带bit的就是直接批量读取，读回来一个包括有全部端口信息的十六位无符号整数，然后我可以对其进行位操作</span><br><br><span class="hljs-function"><span class="hljs-type">uint8_t</span> <span class="hljs-title">GPIO_ReadOutputDataBit</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span></span>;<br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">GPIO_ReadOutputData</span><span class="hljs-params">(GPIO_TypeDef* GPIOx)</span></span>;<br><span class="hljs-comment">//这俩拿来看输出了啥东西的</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_SetBits</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span></span>;<br><span class="hljs-comment">//设定指定输出位</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_ResetBits</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span></span>;<br><span class="hljs-comment">//给输出清除为默认值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_WriteBit</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span></span>;<br><span class="hljs-comment">//给某管脚的输出设定为什么</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_Write</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> PortVal)</span></span>;<br><span class="hljs-comment">//将寄存器设定为什么</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_PinLockConfig</span><span class="hljs-params">(GPIO_TypeDef* GPIOx, <span class="hljs-type">uint16_t</span> GPIO_Pin)</span></span>;<br><span class="hljs-comment">//锁定管脚设置的寄存器 锁定后需复位MCU才能解除锁定</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_EventOutputConfig</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> GPIO_PortSource, <span class="hljs-type">uint8_t</span> GPIO_PinSource)</span></span>;<br><span class="hljs-comment">//将其用作为事件输出，这个没怎么用明白</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_EventOutputCmd</span><span class="hljs-params">(FunctionalState NewState)</span></span>;<br><span class="hljs-comment">//使能或者失能事件输出</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_PinRemapConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span></span>;<br><span class="hljs-comment">//引脚重映射用这个</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_EXTILineConfig</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> GPIO_PortSource, <span class="hljs-type">uint8_t</span> GPIO_PinSource)</span></span>;<br><span class="hljs-comment">//连接GPIO引脚到外部中断线，实际上就是在配置AFIO</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GPIO_ETH_MediaInterfaceConfig</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> GPIO_ETH_MediaInterface)</span></span>;<br><span class="hljs-comment">//这个是拿来配置以太网物理层接口类型的，拿来选MII或者RMII以太网接口，但是这个普通的支持吗？不是很清楚</span><br></code></pre></td></tr></table></figure><p>stm32f10x_rcc.：</p><p>这个文件是复位与时钟控制，用到了下面一句这个，他这个库里面基本上都是这个套路，RCC开头然后参数基本上就这，就是拿来配置时钟的，啥时候用啥时候翻。高级用法暂时不用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">RCC_APB2PeriphClockCmd</span>(RCC_APB2Periph_GPIOA, ENABLE);<br></code></pre></td></tr></table></figure><h3 id="实验部分">实验部分</h3><h4 id="元器件">元器件</h4><ul><li>有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定</li><li>无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音</li><li>LED灯：略</li><li>按键：这个按键内部用的是机械式弹簧片进行通断，会有抖动，要做个削震。</li><li>传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出</li></ul><h4 id="编码流程">编码流程</h4><ul><li>用RCC配置时钟</li><li>GPIO初始化</li><li>主循环实现代码逻辑</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>江协STM32入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>江协STM32入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专利写作·初</title>
    <link href="/2025/08/03/%E5%86%99%E4%BD%9C/%E4%B8%93%E5%88%A9%E5%86%99%E4%BD%9C%C2%B7%E5%88%9D/"/>
    <url>/2025/08/03/%E5%86%99%E4%BD%9C/%E4%B8%93%E5%88%A9%E5%86%99%E4%BD%9C%C2%B7%E5%88%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>具体就是我们之前写了最初的一版的报告，但是老师之后又找到我们，大概意思就是委婉的指出这个玩意儿写的就是一坨翔，跟中期检查报告一样，不符合写作要求，然后就是又手把手让我学着写了一部分（虽然到现在的话也忘的差不多了），又发了往届的几份写好的专利给我们，让我们比着写，之后就是我用一星期一边玩一边搓，用word和visio写了大概万把字几张图给整出来了个初版二号，现在就先写一下这个过程中的一些经验教训吧。</p><p><strong>再次之前，先说明一点，我这篇文章只是说明我这份初稿按照什么思路写的，我对这个的写作的理解是怎么样的。</strong></p><p><strong>在写作之前不能只看我这篇笔记，还是要按照已经授权的这些专利的稿子进行比对着写，看看他们的行文思路咋样，我这里只提供一个我认为的思路。</strong></p><p>首先上图，这个是偷b站一个up主的：</p><figure><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202508031550798.png"alt="发明专利结构与撰写（方法类）.png" /><figcaptionaria-hidden="true">发明专利结构与撰写（方法类）.png</figcaption></figure><p>关于专利的介绍，分什么发明、实用新型、外观就不细讲，像我们信息类工科就发发明专利就行，实用新型都比较鸡肋，外观就更不是我们的事儿了；</p><p>另外是从别人那复制来的三性：</p><ol type="1"><li><p><strong>实用性 (Utility/Industrial Applicability)：</strong></p><p>实用性是指发明创造必须能够在产业上被制造或使用，并且能够产生积极效果或解决特定的技术问题。它要求发明不能是纯理论、抽象的概念或违背自然规律的空想，而必须具有实际的应用价值。具体而言，该发明应当能够被所属技术领域的技术人员根据说明书公开的内容实现其技术方案（可实施性），并能在实际应用中达到预期的有益效果（有益性）。例如，永动机因违背能量守恒定律而无法实现，即不具备实用性。</p></li><li><p><strong>新颖性 (Novelty)：</strong></p><p>新颖性要求该发明创造在专利申请日（或优先权日）之前，不属于现有技术。所谓“现有技术”，是指在申请日以前在国内外为公众所知的技术，其公开形式包括出版物公开（如专利文献、科技论文、书籍、产品手册等）、使用公开（如公开销售、展示、使用）以及其他方式公开（如口头报告、公开演示、网络公开等）。判断新颖性的核心在于：申请专利的技术方案是否与任何一份现有技术记载的技术方案_完全相同_，或者是否是该技术方案的一种_直接、等同的替换_。如果存在任何形式的相同公开，则丧失新颖性。</p></li><li><p><strong>创造性 (Inventive Step/Non-obviousness)：</strong></p><p>创造性（或称“非显而易见性”）是指与申请日以前的现有技术相比，该发明创造具有突出的实质性特点和显著的进步（对于发明），或者具有实质性特点和进步（对于实用新型）。它要求发明创造不仅仅是现有技术的简单叠加、组合或微小改动，而是需要体现出超越本领域普通技术人员在现有技术基础上通过常规推理或实验就能轻易想到的程度。判断创造性的关键在于：对于所属技术领域具有普通知识和技术水平的人员（即“本领域技术人员”）而言，该发明创造相对于现有技术的整体（通常需要结合多份文件）是否是_非显而易见_的，并且通常能带来有益的技术效果。</p></li></ol><h2 id="说明书">说明书</h2><p>先讲说明书的事儿，毕竟我的想法就是先写具体的说明书，具体而言就是要包括标题、技术领域、背景技术、发明内容、附图说明、具体实施方式这些东西。其中发明内容、附图说明和具体实施方式应该占篇幅的大头。</p><h3 id="标题">标题</h3><p>首先就是标题，这个很简单，一般来说是先有想法再写专利，这个想法具体叫什么，给他改个说法叫什么“基于xxx的xxx方法”就可以作为标题吗。</p><h3 id="技术领域">技术领域</h3><p>然后就是技术领域，这一部分也是不用很操心，讲出我们这个专利是属于什么方向的就好，具体模板就是“本发明涉及XX领域，具体涉及XX方法”。</p><h3 id="背景技术">背景技术</h3><p>然后就是背景技术，具体跟论文的国内外研究现状比较像，目的是交代进行发明创造的根本原因，要详细阐述本领域中现有技术的缺陷，具体模板就是讲一个大背景，什么随着社会的什么问题的日渐严重，什么什么的需求日益增加，然后进一步的有什么的需求，但是现有的产品不能满足什么的问题，于是我们需要提出一种什么样的方法装置系统。</p><h3 id="发明内容">发明内容</h3><p>发明内容部分就是大头了</p><p>主要可以分为三部分（不是要继续细分小标题！）</p><p><strong>发明目的</strong>：两句话解释一下这个发明要解决背景技术里面的什么缺陷与问题；</p><p><strong>技术方案</strong>：这个具体而言就是介绍一下这个发明的具体工作流程了，对于我们这个专利而言就是介绍一下各模块之间的关系和基本的处理流程。其中很多话术我是学的一个学姐的，就是先模糊再把具体的流程写在“可选的，其中：”下面。</p><p>我看还要基本跟权利要求书的内容一致，这个注意一下。</p><p><strong>有益效果</strong>：什么成效，这个就随便扯了，不细讲。</p><h3 id="附图说明">附图说明</h3><p>这个部分做起来还是一个比较重要的流程，在我的这篇专利里面老师讲的是我们缺TOC（Tableof Content）总图。主要讲述各个功能单元的处理流程或基本结构。</p><p>同时需要注意，讲到流程需要画流程图作为附图解释；讲到硬件需要画原理/示意图作为附图解释。这个都是最基础的对自己专利的一个解释。</p><p>然后还有进一步的要求就是用向量图，每个流程要注意标注出类似S1这样的流程编号来方便在文字部分的叙述。我们采用的就是老师说的方案，用visio来画然后转为.svg再交上去。</p><p>将图像部分放在最后附上，在文字部分要按照诸如“图X为本发明实施例的XX图”的方式来描述这个图是什么。</p><h3 id="具体实施方式">具体实施方式</h3><p>我的理解就是根据技术方案来提出一个示例，能够使该方案实施的所有技术要点、特征都写进来。具体而言我的做法就是用这个发明内容里面的流程进一步细化，根据附图说明的部分来进行说明与展示。</p><h2 id="说明书摘要">说明书摘要</h2><p>然后是说明书摘要部分，这一部分老师不放心，还是老师写好给我们发过来的，要包括：</p><ul><li>本发明公开了XX方法，涉及什么领域；</li><li>包括XXX；</li><li>优点，解决了什么问题；</li></ul><p>同时要从说明书附图中选择一个代表性图片作为摘要附图。</p><h2 id="权利要求书">权利要求书</h2><p>这个就是规定保护范围用的，如果是那种企业保护自身财产的就很重要。</p><p>具体分独权（独立权力要求）和从权（从属权利要求）。</p><p>如果你是要拿这个专利赚钱，就尽可能扩大保护范围，防止他人侵权的角度出发，具体就是像俄罗斯套娃一样，独权包含的范围要尽可能的大，这样才能有效的保护你的知识产权，然后从权一步步的将其限定下去，比如独权就写个叉子，从权1就写木质叉子，从权2就写檀木叉子，从权3就写中国产的檀木叉子，如果第一次产权局不给你过就把从权1归到独权里面，再不过就给从权2归到独权里面，以此类推，保护范围越大越好；</p><p>如果你是为了评职称或者丰富简历，尽可能申请上，那就可以独权就直接详细描述，牺牲保护范围，申请上的可能就更大。</p><p>进一步的，专利就是要保证他的新颖性、创造性和实用性，这三点要不断的在你的权要书里面体现。</p><p>差不多就这些。</p><p>参考教程： &gt;<ahref="https://www.bilibili.com/video/BV1vs4y1974j/?spm_id_from=333.1391.0.0&amp;vd_source=35efa20a3dc2d6382913a782f2bf8ad8">大学老师手把手教你写（水）专利_哔哩哔哩_bilibili</a>&gt; &gt;<ahref="https://www.bilibili.com/video/BV1ph4y1s7gq/?spm_id_from=333.1391.0.0&amp;vd_source=35efa20a3dc2d6382913a782f2bf8ad8">发明专利撰写入门介绍（适合小白）_哔哩哔哩_bilibili</a></p><p>其他参考暂略。</p>]]></content>
    
    
    <categories>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>visio绘图</title>
    <link href="/2025/07/30/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-07-30-visio%E7%BB%98%E5%9B%BE/"/>
    <url>/2025/07/30/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-07-30-visio%E7%BB%98%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="下载">下载</h2><p>具体怎么下载就补不细讲了，然后可以参考一下相关的帖子。我想能学到这一步的应该也不用出个保姆级的教程了。</p><blockquote><p><ahref="https://support.microsoft.com/zh-cn/office/%E5%AE%89%E8%A3%85-visio-%E6%88%96%E8%AE%BF%E9%97%AE-visio-%E7%BD%91%E9%A1%B5%E7%89%88-f98f21e3-aa02-4827-9167-ddab5b025710">安装Visio 或访问 Visio 网页版 - Microsoft 支持</a> <ahref="https://blog.csdn.net/qq_38348202/article/details/127723561">Visio从安装到使用完整版_visiocsdn-CSDN博客</a> <ahref="https://blog.csdn.net/binbinaishijie88/article/details/149247723">【2025】Visio安装教程保姆级一键安装教程（附安装包）-CSDN博客</a><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MzE4NDU4NQ==&amp;mid=2247506730&amp;idx=2&amp;sn=4bcaa57e0835bc5e1fbdbf90cddde8fe&amp;chksm=c335548cf442dd9a86ff301a26a85a9c30dcc9ecb84dd0584fde2281b71cce789df1b546a968&amp;token=2032306290&amp;lang=zh_CN&amp;scene=21#wechat_redirect">Visio2021 安装教程【64位/32位】</a></p></blockquote><p>甚至这个东西还有网页版，而且顺便看了一下，office全家桶现在都有，倒真挺不错的，如果氪的起金的话，当然我是没用过：</p><blockquote><p>https://visio.office.com/</p></blockquote><p>有一个比较奇妙的问题就是，我在下载好office2021全家桶（word、ppt等）的情况下没办法直接安装visio，给office卸掉再安装就能安装上了，就比较奇妙。</p><p><strong>最终我确定的安装方法是直接卸载office然后重新从学校的正版化软件平台找office全家桶安装的光盘映像，勾上安装visio，勾八的。</strong></p><p>如果你是校友的话，不妨就直接上ca.bit.edu.cn看看。</p><h2 id="发展脉络补充">发展脉络补充</h2><p>总结一下就是最开始出的是office套件，即word、excel、ppt等，这些都只不过是在电脑本地跑，写作的话需要手动传文件，之后在一零年代微软推出个office365，加了点云服务，即onedrive、邮箱等，再往后二零年代就吧这个品牌名改为了Microsoft365，加了点ai功能和更多的协作功能。</p><p>总体来说还是看协作要求程度以及个人经济实力来选择合适的办公用具。</p><p>接下来具体的讲述的材料源为deepseek-R1：</p><h3id="微软办公套件核心发展时间线"><strong>微软办公套件核心发展时间线</strong></h3><h4 id="传统买断制时代-1989---2010"><strong>1. 传统买断制时代 (1989 -2010)</strong></h4><ul><li><strong>1989年</strong>：微软首次提出 <strong>“MicrosoftOffice”</strong> 品牌概念，将多个独立办公应用打包销售 。</li><li><strong>1990年11月19日</strong>：发布划时代的<strong>Windows版Office套件</strong>，包含 <strong>Word 1.0、Excel2.0、PowerPoint2.0</strong>（即“办公三件套”），定义了此后数十年的文档处理标准 。</li><li><strong>1995年</strong>：<strong>Office 95</strong> 随<strong>Windows 95</strong>操作系统爆发式普及，成为全球企业和个人事实上的办公标准，击败了WordPerfect、Lotus等竞争对手。</li><li><strong>2000s年代</strong>：微软持续推出 <strong>Office2000/XP/2003/2007/2010</strong>等买断版本，功能迭代但本质仍是本地安装软件，协作依赖文件传输 。</li></ul><h4 id="云订阅转型office-365时代-2011---2019"><strong>2.云订阅转型：Office 365时代 (2011 - 2019)</strong></h4><ul><li><strong>2011年6月28日</strong>：微软正式推出 <strong>Office365</strong>，标志<strong>从买断制向订阅制云服务转型</strong>。初始版本面向<strong>企业/教育用户</strong>，整合ExchangeOnline、SharePoint Online、Lync Online（后改名Skype forBusiness）。</li><li><strong>2013年</strong>：<ul><li>推出面向<strong>小型企业</strong>的“高级版”订阅计划 。</li><li>集成商业智能工具 <strong>Power BI</strong> 到Excel 。</li></ul></li><li><strong>2014年3月</strong>：推出面向<strong>个人消费者</strong>的订阅计划（个人版/家庭版），首次将云服务覆盖至C端用户。</li><li><strong>2017年</strong>：<ul><li>Office 365收入占比首次<strong>超过50%</strong>，云转型完成关键里程碑。</li><li><strong>7月</strong>：发布 <strong>Microsoft 365企业服务</strong>（含Office 365企业版 + Windows 10企业版 +企业移动安全套件），但<strong>此时“Office365”仍是消费者端主品牌</strong> 。</li></ul></li></ul><h4 id="品牌统一与生态扩展microsoft-365时代-2020---至今"><strong>3.品牌统一与生态扩展：Microsoft 365时代 (2020 - 至今)</strong></h4><ul><li><strong>2020年3月30日</strong>：微软宣布 <strong>Office365消费者订阅服务（个人/家庭版）将于4月21日正式更名为Microsoft365</strong>，标志“Office”品牌淡出，云生态成为核心 。<ul><li><strong>关键升级</strong>：新增AI功能如 <strong>写作助手（MicrosoftEditor）</strong>、<strong>PPT演讲教练（PresenterCoach）</strong>、<strong>Excel个人记账工具（Money in Excel）</strong>。</li><li>价格不变（中国区个人版398元/年，家庭版498元/年）。</li></ul></li><li><strong>2022年10月</strong>：微软在Ignite大会宣布，<strong>Office移动端/网页端/桌面端应用将全面更名为“Microsoft365 App”</strong>，界面与图标同步更新 。</li><li><strong>2023年至今</strong>：<ul><li>持续深化AI集成（如Copilot）、跨平台兼容（如macOS打印支持）、安全更新。</li><li><strong>Microsoft365成为涵盖办公、协作、云存储、AI、安全的一站式平台</strong>，彻底超越传统Office工具定位。</li></ul></li></ul><h3 id="时间线速查表">时间线速查表</h3><table><thead><tr><th><strong>时间段</strong></th><th><strong>核心产品/品牌</strong></th><th><strong>重要事件</strong></th><th><strong>模式/特点</strong></th></tr></thead><tbody><tr><td><strong>1990-2010</strong></td><td>Microsoft Office</td><td>1990年发布三件套；1995年随Win95普及；买断制更新</td><td>本地安装，功能封闭</td></tr><tr><td><strong>2011-2019</strong></td><td>Office 365</td><td>2011年面向企业推出；2014年扩展至个人用户；2017年收入超50%</td><td><strong>订阅制云服务</strong>，整合在线协作工具</td></tr><tr><td><strong>2020-至今</strong></td><td>Microsoft 365</td><td>2020年4月消费者版更名；2022年应用全面更名；AI深度集成（写作/演讲/图表生成）</td><td><strong>云+AI+生态平台</strong>，跨设备无缝协作</td></tr></tbody></table><p>反正总结一下对于现阶段的我，一个啥都不会的大学生来说，直接继续选office套件找学习版绿色版就对了。</p><h2 id="操作">操作</h2><p>略，他的操作思路刚上手才发现确实跟office其他套件一个逻辑，没有必要再在这里废话。</p><p>总结就是这篇稿子等于啥都没写。</p>]]></content>
    
    
    <categories>
      
      <category>折腾杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾的小杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-07-26-青岛</title>
    <link href="/2025/07/26/%E5%8F%8D%E6%80%9D/2025-07-26-%E9%9D%92%E5%B2%9B/"/>
    <url>/2025/07/26/%E5%8F%8D%E6%80%9D/2025-07-26-%E9%9D%92%E5%B2%9B/</url>
    
    <content type="html"><![CDATA[<p>刚从青岛回来，写篇月记好了。</p><p>这次是第二次去青岛，也是第一次跟大学同学一块出去旅游，不过说实在的这两次出来反而让我更加迷茫了，我不知道出来玩是为了什么了，之前可能是多逛逛其他的地方，然后之后是为了多和朋友聊天，在之后是体会不同地方的风土人情跟不同的人交友，但是从这次到大连和青岛的经历来讲，我不知道是为了什么了。</p><p>行程很简单，第一天到了地儿在海大逛一逛，然后在海大校门旁边看海吹海风，第二天比赛，比完去沙滩坐一会然后去吃海鲜，第三天先去酒店参加颁奖，没想到这垃圾玩意还拿了省二，然后去海底世界，之后去海水浴场差点被淹死，第四天就是现在，睡到十一点起来打会台球哥几个各回各家了，我距离发车还有几个小时，就先来逛逛葡萄酒博物馆，然后在车上来写这篇文章。</p><p>第一天在海大的话，确实感觉到了海边和内陆的不一样，门卫大爷真就都晒的肤色十分额，性感？就是那种在海上吹着海风才能晒出来的深古铜色，这种肤色在信阳和北京基本上没见过。</p><p>然后海大西海岸校区确实是被流放了，而且旁边也没地铁站就很难受，而且还比较荒凉，商贸发达程度不如良乡，但是环境条件要比良乡好的太多，出门就是野沙滩，可以看海吹海风。我们去的时候还是多云不是很晒，海水很干净很蓝，当时没看见浒苔，踩在沙滩上面朝大海吹着海风，旁边是在海滩上维修的小渔船，好不惬意。</p><p>我有一所房子，面朝大海，春暖花开，大概就是这样的意境吧。</p><p>一眼望过去是看不到头的瓦蓝蓝的海水，上方映衬着蔚蓝的天空与洁白的云，想一想，一个一米高百来斤的人的悲欢痛苦，在这广阔的水域面前又算得了什么呢，无论如何，海还是在那里面无表情的涨潮落潮，海浪还是日复一日的拍打着海岸，冲刷着金色的沙滩，对他们还说，什么都没有发生。</p><p>倒也理解环境给人的影响了，住在海边的人，大概心胸能宽阔不少吧。</p><p>第二天上午准备准备答辩，我们分在第四个，上午答辩完吃饭就能走了，挺好的，然后中午在食堂管顿饭。说实在的感觉这次来参加这玩意收获确实挺多的。</p><p>答辩的时候三个老师，第一个问我们延迟指标和热成像的帧数，因为我们用的是无人机吗，做的火灾监测无人机，结果我们没有测。</p><p>第二个老师就是光电的，做这个军用的无人机，从需求分析开始扣，比如我们这个热成像是没啥用的，只用初始的获取到的温度数据作为自动判别的依据就好，热成像不行的话可以放在终端；超声避障只有一个的话为什么不用几块钱一个的激光模块？还有目标检测实际上没啥用。</p><p>总结一下就是我们的需求，要做个什么都搞错了，实际上如果是真正有使用价值的话，应该注重的是快速与稳定，而不是像我们这样做一个偏展示的东西。</p><p>还有就是需求里面的参数标准应该一开始就定下来，比如超声避障的话，就要按照无人机的最大转向速度飞行速度之类的来定这个识别速度和刷屏速度。</p><p>这个老师确实是批判性的给了一些建议。</p><p>第三个问我数据集用的什么，然后问出来了用我自己的话来批判我报告里面写的能识别建筑物结构，这个就提醒的是有的技术指标是不能偷懒的。</p><p>差不多就这些评价吧，然后就五分钟限时答辩被打断了，晚上的时候看到朋友圈有个大四学长发了个顶会之后在还跟sc聊。</p><blockquote><p>对的，就是没有拎清楚我们要解决什么问题 需求分析确实没有做好项目管理的经验也是不足 不过这倒提醒一件事吧就是之后我如何规划好精力应该放在什么地方项目的需求分析对应到个人发展上不就是怎么分配精力吗说实在的到现在还是没有客观的给我们专业各个方向的出路理出来应该准备什么弄清楚 很多情况下就是蒙着头瞎几把卷感觉这也是我接下来需要做的一件事</p></blockquote><p>唉，确实啊，庸庸碌碌过两年了，真的还能争吗？</p><p>下午在海大食堂吃个饭，宾馆躺了一会去海滩露出，吹吹风玩玩沙子啥的，一般般吧，没啥好写的。晚上无事。</p><p>第三天找的是个酒店来颁奖，几把的肯定不可能我自己没事来吃的那种，真几把奢华。</p><p>然后没想到我们这个屎还拿了二等奖，一问三不知，录取预通知吗，没进国赛，但也不错了吧、</p><p>不过说实在的感觉现在这个阶段还是脚踏实地给小东西做一下比较好。</p><p>下午先是去海底世界，展品一般但是票有点贵，拍了点照看看水母看看鱼看看海豹海狮看看标本啥的，也就那样。</p><p>但是最心有余悸的就是接下来去青岛海洋第一浴场。</p><p>不会游泳但是还是莫名其妙就莽，跟另外一个哥们下海去，我以为没到我身高就没啥事，忽略了水流的力量，直接被浪打倒了，幸亏是旁边哥们看着我人消失的，一把给我捞上来了，也就喝了两口海水搞的我很反胃。</p><p>但是如果他没看见呢？如果我就这样被卷出去了呢。有点后怕说真的。海水确实又咸又涩。</p><p>还是说不要总是给自己想象的这么重要，也不要给自己想象的多么聪明多么强大，要有所敬畏有所提防，君子不立于危墙之下。</p><p>还有就是当时都有点濒死体验了感觉（不是真快死），就是大脑愣住：唉？我是不是真要快死了？有谁能救我吗？怎么办呢？唉，</p><p>就是一种平静的死感，好像马上要死的不是我，又好像马上要死的确实是我，或者说莫名的有一种麻木的感觉，或者说解脱？</p><p>给我捞上来的时候旁边大哥还讲什么不会游泳就不要去下水，确实是用一种严厉的语气说这话。结果当时我打个哈哈嬉皮笑脸的说不搞了就过去了。</p><p>这个又想到当时的那个罗布泊驴友莫名其妙死掉的事儿了：</p><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202507270019143.jpg" /></p><p>说实在的我很赞同大哥的做法，人类进化出愤怒这个情绪，本来就是一种交流的工具，或者说所有情绪，都是交流的工具，他这样严厉的骂一顿，反而是对这种工具最好的试用方法，我很感谢他。反而感觉我需要反省。</p><p>之后不能在这样办事了，君子不立于危墙之下，不能这样轻视外界，当然也不能过于敬畏，有所为，有所不为。</p><p>第四天就是今天，上午睡到十一点，下午跟丁丁打了一个小时台球，打车去城里，勾八的这几天打车花的钱确实多，在路上写了上面的这些文字。</p><p>先是去的红酒博物馆，然后明明就准备直接随便走去火车站，反正几公里两小时的事儿，也是我一个人决定的吗，结果突然走到地铁站旁边了，再一看，中山路那一片老城区离得这么近，去前海潮吃海肠炒饭去。</p><p>啤酒博物馆说实在的价钱有点黑，几把的还好我是网上买的，旁边遇到俩韩国小夫妻带个娃在实地买，贵好多。</p><p>确实意识到了沟通能力和外语能力有所欠缺，总结就是那边博物馆的工作人员英语不咋好，然后跟他沟通很困难，然后我就我那半吊子外语跟他说明白是什么情况，对那个男的还会点中文，但是不标准，然后邀请他，要不我帮你们翻译着博物馆上的字儿，然后就被拒绝了。</p><p>前海潮的那家的海肠捞饭确实好吃，但是就是几把的贵，七十多一碗，还吃不饱，多点了盘炒蛤蜊，一盘饺子才饱，勾八的干了我一百五，不过海肠捞饭确实好吃。</p><p>从红酒博物馆出来，去地铁站的时候也是，莫名的意识到了我马上要走了，眼前的景色可能我这辈子都不会再见到第二次，莫名的感伤起来。</p><p>明明应该很美好的啊，为什么做不到很爽快的离开呢，还是放不下吗，或许真的像哥们说的：你不是喜欢美景，你只是喜欢欣赏这份景色的自己罢了。</p><p>不过我想我可能找到旅行的意义了，但是好像感觉这种意义在国内还是不够刺激，我还是想去异国感受一下完全陌生的环境，结交一些完全陌生的人，和他们沟通，了解他们的想法与观点。</p><p>在此之前还是要学好外语，扭转好不懂得如何与人相处的性格。</p><p>马上到学校了，现在是23点23分，就写到这里吧。</p><h2 id="又">又</h2><p>这段时间确实比我在宿舍宅着经历多了很多，也想了很多，我在思考为什么我要有这个博客呢，我为什么要这样做，给他放在一个大多数人看不到的地方，等于不会被人发现的地方，但是同样的，为什么我不愿意让人发现，还要给他放公网上呢。</p><p>我不知道。</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025-07-12-月记</title>
    <link href="/2025/07/12/%E5%8F%8D%E6%80%9D/2025-07-12/"/>
    <url>/2025/07/12/%E5%8F%8D%E6%80%9D/2025-07-12/</url>
    
    <content type="html"><![CDATA[<p>上次写blogs还是上次，现在正好刚从大连玩完回家后又回北京了，明天开始又要每天做牛马，不如趁这两天先给这段时间总结一下吧。</p><h2 id="一">一</h2><p>上次写还是考试之前。这学期专业课也就三门，数电信号和电磁，数电学的还行，题都会做，电磁就稍微次一点，不过还好考的样板题，信号还是熟练度不够，考的不咋地。不过单纯从学的角度来看，这三门实际上都挺有意思，比如数电用来设计抽象的电路来处理分立的信号，实现一定的逻辑功能，信号实际上是在发展数学模型，然后用几种变换来分析不同信号的频域特征，从哲学层面上来看就是用数学语言描述分析现实的问题，具体的推导过程挺有美感的，很有意思的一件事，不过我做题做的不好就是了，题没练够。</p><p>我在想要不要在暑假里面先给下学期的速通一下，不以做题为目的，就来理解他是在干啥。我一直以来都挺反感我现在的这种做法，就是平时不学，然后最后突击一下，刚刚了解到这门课的美感然后就考试了，考完就又是下一步了。这很不好，简直是暴殄天物。</p><p>转念一想，除了期末前被逼着看会书能感觉还有点意思，现在又有什么能让我提起兴致的呢？这也是刚刚跟哥们聊天的时候聊的内容，最开始是各种的手办周边和游戏，但是感觉没啥意思还浪费钱，然后是摄影、骑行、外设败家几件套，更浪费钱了；在之后是音乐（主要是v曲加点jpop）和轻小说，这个算是十分朴素了，但是目前来看对这些的兴趣也在消减，我都不知道接下来又会对什么感兴趣。之后会对什么感兴趣呢？</p><p>我不知道。</p><p>大概也还是会像这样，过一段时间就没有了原先的热情，或者因为其他各种的事情给耽误掉了吧。</p><p>刚刚又和rd哥聊，跟他说什么总是感觉很迷茫，不知道做什么，或者说不知道我为什么做这个。哥们指出有一点，学而不思则罔，思而不学则殆，确实就是做的时候蒙头做，反思之后也没有行动力，这叫啥，学思分离。</p><h2 id="二">二</h2><p>期末周还有个事儿，就是台里换届，确实台里这两年落寞了，一个萝卜几个坑，然后就是成功留在台里办事了，这也算我在大学里面为数不多的有意义的时刻吧。</p><p>能够在台里留任，接触到更多优秀的同学，和一些组织能力强的同学交流，对于我来说确实是一件很享受的事情，有很多智慧不是我能像从小到大这样闭门造车能得到的。聚餐，开会，一块干活，或许像我这样阴暗的私宅也可以得到一些慰藉吧。</p><h2 id="三">三</h2><p>考完回去招生，有几个感触比较大的吧，一个是信息差真的值钱，一个是只有外向、会来事的人混到更好的饭吃的概率更大。</p><p>具体怎么说呢，高中生确实如果一门心思学习，考完出来是什么都不明白，这个我实际上深有体会，我就是这样的，莫名其妙选了个专业来读，莫名其妙到了这一步，不过运气还好，莫名其妙报上的专业还挺喜欢，但是也就仅仅是运气好了。我见的很多学弟学妹就是也跟我一样，我可以说我选的方向歪打正着还好，但是下面的就不一定了。这种学生最好忽悠了。所以说我还是持这个观点，多结交朋友，多开辟信息渠道，听别人说什么话要结合这个人是什么状态，比如学生一般来说良知可能残存的多一些，或者他的利益和你冲突不冲突。</p><p>至于外向的这点，一个是当时有两位家长来跟我聊，加我微信，俩人都认识，但是其中一个加完主动问我，然后聊一些参考，我相应的就多讲一些；另外一位我顺便问了一句，然后问了一下我分数线就走了，不说我说的对不对，有没有相关的私人的倾向，光说信息获取量来说，外向的这位可能就不光跟我打，其他招生组的肯定都逐个聊过，这样拿到的信息肯定要比后者要多的。</p><p>还有的例子就算了，也不方便再举。也许之后我看到这里还能想起来吧，也许想不起来，无所谓了。</p><p>但是反观自己，真的做到了吗？我也不知道。</p><h2 id="四">四</h2><p>之后是回家。回一次感慨一次，每次回来家里都与记忆里有些不同，恐怕最后终将会变成最熟悉的陌生处，每次回来都明显感觉到长辈比记忆中衰老一些，但是我又混成了什么鬼样呢？人不人鬼不鬼，天天浑浑噩噩，如果高中毕业之后的我知道自己现在是这个样子，又会怎么想呢？</p><p>这倒又想起了招生时和学生打交道，高中生还是青春啊，那朝气蓬勃的样子，对未来的憧憬，跟他们对话之后不禁扪心自问：</p><h3id="問おう貴方は本当に今の己の在り様に満足しているのか">“問おう。貴方は本当に、今の己の在り様に満足しているのか？”</h3><p>两年前的盛夏，少年也是这样拿着自己的高考分数翻找填报信息，心中满怀着希冀，不知自己会溺死在秋天里。</p><blockquote><p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p></blockquote><h2 id="五">五</h2><p>招生完去大连，实际上感觉景区倒是都差不多，拉活的推销的，本来应该是来享受放松的但是一直被推销，就很不爽。</p><p>然后是在酒店里面补了两天的作业，这还是给活都堆到最后导致的，下次还是提前做，搞的玩也没玩尽兴，东西也没做太好。</p><p>主要还是为了跟哥们出去玩，爬山，聊天，聚餐，算账。实际上挺惘然的，原来的哥们越走越远，能交到的纯粹的朋友随着年龄增长越来越少，之后我还能有多少这样的机会？我不知道。</p><p>又给老摄像机拿出来确实是不错的，至少能多拍点东西。大连的海景还是不错的，遗憾的是第一天天气不太好，第二停留时间太短，要是能像当地同学一样没事跑海边吹风该有多好，总比没事去爬山强。</p><p>至于柜子话，之后再说吧，但是感觉学的越来越行，回北京的时候看番明显能感觉到听懂的部分越来越多，继续学着吧。</p><p>最后一部分有些流水账，感觉也许可以等到之后从青岛打完比赛之后回来慢慢写，写如何开始一天的工作，关于大连这两天又有什么感悟。</p><p>下次一定！</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06-09-思考与构建</title>
    <link href="/2025/06/09/%E5%8F%8D%E6%80%9D/2025-06-09-%E6%80%9D%E8%80%83%E4%B8%8E%E6%9E%84%E5%BB%BA/"/>
    <url>/2025/06/09/%E5%8F%8D%E6%80%9D/2025-06-09-%E6%80%9D%E8%80%83%E4%B8%8E%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>这个大概是在看漫画的时候莫名想到的吧，是个小说改的，原作者总是喜欢给自己的一些体会加到这本书里面，于是在书中就能看到作者自己的一些恋爱观、人生哲学以及恋爱小情趣。</p><p>然后想了很多，作为我个人而言吗，我固然在现在是想多接触一些人，想谈个恋爱之类的，但是思来想去感觉有个很大的问题就是和别人聊天的时候总是聊不到一块去，比如有的时候就是我单方面的诉苦，有的时候就是直接尬在那里。这个我觉得应该有两方面的问题：聊天技巧和知识丰度或者说观点的有趣程度。</p><p>关于聊天技巧我觉得首先可以给之前刷到的一个东西先讲出来：大冰之前跟一个小伙子连线，也是我这个问题，说话总是不到点子上，废话很多，表达能力很差。然后给的一个建议就是要少说，说话之前可以先停顿一下组织删掉自己的语言，大概可能2-3秒，最多不过五秒，多了可以先说我先想一会，然后删繁就简，讲出最精炼最能抓住重点的话来。这样做有两个核心逻辑在里面：第一个你本身不会说话，所以与其担心有啥没讲到，不如先守拙，言多必失吗；第二个，这个也是一个锻炼思维能力的过程，通过精炼自己的话来达到一个能够言简意赅阐释清楚意思的一个效果。当然还有有一些额外的好处，就是别人第一反应是得到了你的尊重，你在认真思考他的话。</p><p>然后其他的聊天技巧就之后再说，这个可以着重找一些资料，同时多加练习，多做一些有价值的对话，聊一些信息量大的话题，做一些头脑风暴。</p><p>还有聊天时候的观点以及聊天的相关内容，我觉得一方面要减少在碎片化娱乐项目上浪费的时间，刷一个小时短视频不如打一小时游戏，至少打了游戏看了番也算在兴趣爱好上多做了一些努力；其次多去找一些有价值有思考内容的资料，比如多去整理知乎的高赞回答，多去看一些书，学习一些技能，不要总是脑腐。我甚至觉得接下来可以每周有空闲时间给知乎的高赞回答的底层逻辑梳理一下吧，不过可能没法发到我这里来了。</p><p>睡觉。</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git介绍及用法</title>
    <link href="/2025/06/03/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-06-03-Git%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BB%8B%E7%BB%8D/"/>
    <url>/2025/06/03/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-06-03-Git%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>这篇blogs算是读git官方的这个 <ahref="https://git-scm.com/book/zh/v2">Pro Git Book</a>整的一个笔记。很多都是直接cv的。这篇blogs就看了他的前两章，后面的像是在服务器上搭建Git之类的之后再说吧。# Git历史</p><h3 id="版本控制发展">版本控制发展</h3><p>本地版本控制-&gt;集中版本控制-&gt;分布式版本控制</p><p>Git是在linux的开发过程中，在分布式版本控制系统bitkeeper收回免费linux开发组对该系统的使用权力后，由linus牵头写的一个版本开发系统，有简单而快速、支持并行开发、完全分布式、支持超大规模项目管理的特点。</p><h3 id="思路与优势">思路与优势</h3><p>Git的思路是每次存下一个文件快照的索引，每当提交更新，他就会做一个快照，并保存这个快照的索引。为了效率，如果有文件没有更改，他就不会重新储存，直接保留一个连接指向之前存过的文件的。在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p><p>这和之前的例如CVS、Subversion、Perforce按照类似于记录下各个版本之间的差异，按照类似于补丁的形式给记录下来，（通常称作基于差异（delta-based）的版本控制）。Perforce的话，没有连接服务器时几乎不能做什么事；而用 Subversion 和 CVS 的话，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。</p><p>Git有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p>这会让我们的 Git项目拥有三个阶段：工作区（某个版本独立出来让你改的）、暂存区（一个Git仓库目录的文件，写了下次提交要上报什么东西）以及Git 目录（.git）。</p><h1 id="git安装">Git安装</h1><ul><li>linux（Debian系为例）：<code>sudo apt install git-all</code></li><li>MacOS：<code>git --version</code>之后跟着系统提示走就行，直接用二进制安装程序详见Git官网：<ahref="https://git-scm.com/downloads/mac">Git - Downloading</a></li><li>Windows：直接用二进制安装程序详见<ahref="https://git-scm.com/downloads/win">Git - DownloadingPackage</a></li><li>源码编译：详见<ahref="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Git- 安装 Git</a>，这个我觉得没必要还耗费时间，有兴趣可以自己做一下。</li></ul><h1 id="git配置">Git配置</h1><p>用Git自带的工具<code>git config</code>。具体变量会存在三个位置：</p><ol type="1"><li><p>系统内全部用户：<code>/etc/gitconfig</code> ，如果在执行 <code>git config</code> 时带上 <code>--system</code> 选项，那么它就会读写该文件中的配置变量。注意这个是系统配置文件，要sudo。</p></li><li><p>当前用户：<code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>，你可以传递 <code>--global</code> 选项让 Git读写此文件，这会对你系统上所有的仓库生效。</p></li><li><p>当前使用仓库：<code>.git/config</code>，你可以在该仓库下传递 <code>--local</code> 选项让Git 强制读写此文件，虽然默认情况下用的就是它。</p></li></ol><p>每一个更细的级别会覆盖上一个大级别级别的配置。</p><p>在 Windows 系统中，Git会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code> ）的 <code>.gitconfig</code> 文件。Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP上在 <code>C:\Documents and Settings\All Users\Application Data\Git\config</code> ，WindowsVista及其以后的版本在 <code>C:\ProgramData\Git\config</code> 。此文件只能以管理员权限通过 <code>git config -f &lt;file&gt;</code> 来修改。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --list --show-origin <span class="hljs-comment">#查看所有的配置以及它们所在的文件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --list               <span class="hljs-comment">#查看所有的配置</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --list &lt;key&gt;         <span class="hljs-comment">#查看某项配置 eg:git config user.name</span></span><br></code></pre></td></tr></table></figure><h3 id="用户信息">用户信息</h3><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。这一点很重要，因为每一个 Git提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span><br></code></pre></td></tr></table></figure><p>这个 <code>--global</code>从上文可知是当前用户下的配置，如果要在特定项目下配其他的话在此项目中用去掉<code>--global</code> 的命令就行。</p><h3 id="ide配置">IDE配置</h3><p>一般来说在linux下会直接用系统默认的文本编辑器，更换编辑器命令（以emacs为例）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global core.editor emacs</span><br></code></pre></td></tr></table></figure><p>Windows 系统上，指定可执行文件的完整路径即可。</p><h1 id="git帮助">Git帮助</h1><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">help</span> &lt;verb&gt;      <span class="hljs-comment">#eg:git help config（找git config）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git &lt;verb&gt; --<span class="hljs-built_in">help</span>    <span class="hljs-comment">#eg:git add -h</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">man git-&lt;verb&gt;</span><br></code></pre></td></tr></table></figure><h1 id="git拉包">Git拉包</h1><h2 id="在已存在的目录中初始化仓库">在已存在的目录中初始化仓库</h2><p>在当前目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <span class="hljs-comment">#初始化，创建.git子目录，是git仓库中所有的必须文件</span><br>git add *.c<br>git add LICENSE<br>git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="克隆现有的仓库">克隆现有的仓库</h2><p>Git克隆的是该仓库服务器上几乎所有数据，默认是没一个版本都会拉下来</p><p>在目标克隆目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 <br>git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit  <span class="hljs-comment">#自定目录名</span><br></code></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 “libgit2”的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p><p>传输协议之后再写。</p><h1 id="git上传zzzz">Git上传(zzzz)</h1><p>文件的状态变化周期：</p><p>![[file-20250604000404216.png]]</p><p>接下来根据这个文件状态变化周期来进行叙述：</p><h2 id="跟踪新文件与暂存更改">跟踪新文件与暂存更改</h2><p>只有把文件添加到更新下面之后才能进行版本控制！新建文件后仍为未跟踪状态，需要执行<code>git add &lt;文件&gt;</code>将其转为已暂存，后续所有提交都只包含暂存区的内容；<code>git add</code>也可接受目录路径，递归跟踪目录下所有文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .  <span class="hljs-comment">#添加全部的文件</span><br></code></pre></td></tr></table></figure><p>注意有的时候你中途add进去一个新文件，在add之后在上传时，上传的是你add时的版本，再次修改的文件还在非暂存区中，需要重新add。</p><h2 id="忽略不需要版本控制的文件">忽略不需要版本控制的文件</h2><p>在项目根目录（或子目录）创建<code>.gitignore</code>，列出要忽略的模式（支持 glob 语法）；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.o        <span class="hljs-comment"># 忽略所有 .o 文件 </span><br>*.a        <span class="hljs-comment"># 忽略所有 .a 文件 </span><br>!lib.a     <span class="hljs-comment"># 但跟踪lib.a</span><br>*~         <span class="hljs-comment"># 忽略 Emacs 自动保存的临时文件  </span><br>/TODO      <span class="hljs-comment"># 只忽略仓库根目录下的 TODO 文件，匹配模式防止递归  </span><br>build/     <span class="hljs-comment"># 忽略任何目录下名为 build 的文件夹，指定文件夹递归入库  </span><br></code></pre></td></tr></table></figure><h2 id="查看文件状态">查看文件状态</h2><ul><li><code>git status</code>：显示当前分支、与远程分支的关系，以及“已暂存”和“未暂存”更改、和“未跟踪”文件；</li><li><code>git status -s</code>（或<code>--short</code>）：以紧凑格式显示状态</li></ul><h2 id="查看修改细节">查看修改细节</h2><p>在提交前，应先用 <code>git status</code>确认所有需要包含的修改都已暂存，然后再检查差异。</p><p>有一点需要注意的是，若只想看“未暂存”的修改，直接运行<code>git diff</code>；若想查看“已暂存且待提交”部分，可用<code>git diff --cached</code>（或 <code>--staged</code>）。</p><h2 id="移除文件">移除文件</h2><h3 id="彻底移除工作目录-git-仓库">1. <strong>彻底移除（工作目录 &amp;Git 仓库）</strong>：</h3><p> <code>git rm &lt;file&gt;</code>：</p><ul><li>从工作目录中删除文件。</li><li>将删除操作<strong>暂存</strong>（记录到暂存区）。</li><li>提交后，文件将不再被 Git 跟踪，且从磁盘消失。</li></ul><h3 id="仅移除-git-跟踪保留文件在工作目录">2. <strong>仅移除 Git跟踪（保留文件在工作目录）</strong>：</h3><p><code>git rm --cached &lt;file&gt;</code>：</p><ul><li>将文件从 Git 的跟踪列表和暂存区移除。</li><li><strong>保留</strong>文件在工作目录中，使其成为未跟踪文件。</li><li>适用于误添加到暂存区但需保留本地的文件（如日志、编译产物）。</li></ul><h3 id="强制移除-f">3.<strong>强制移除（<code>-f</code>）</strong>：</h3><ul><li>当文件已被修改且添加到暂存区时，需使用 <code>git rm -f &lt;file&gt;</code> 强制删除。</li><li>防止误删尚未提交快照的修改（这些修改无法由 Git 恢复）。</li></ul><h3 id="删除模式匹配的文件">4.<strong>删除模式匹配的文件</strong>：</h3><ul><li>使用 <code>git rm</code> 配合 glob模式（如 <code>git rm log/\*.log</code> 删除 <code>log/</code> 下所有 <code>.log</code> 文件）。</li><li><strong>注意</strong>：通常需转义 <code>*</code> 等特殊字符（如 <code>\*</code>）。</li></ul><h2 id="移动重命名文件"><strong>移动/重命名文件</strong></h2><p>Git通过内容变化智能推断文件是否被移动或重命名。可以用<code>git mv &lt;old_name&gt; &lt;new_name&gt;</code>进行重命名或者移动，该命令等效于执行以下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> &lt;old_name&gt; &lt;new_name&gt;   <span class="hljs-comment"># 1. 工作目录中重命名/移动</span><br>git <span class="hljs-built_in">rm</span> &lt;old_name&gt;          <span class="hljs-comment"># 2. 删除旧文件（暂存）</span><br>git add &lt;new_name&gt;         <span class="hljs-comment"># 3. 添加新文件（暂存）</span><br></code></pre></td></tr></table></figure><p>提交后，Git会将其识别为重命名操作（<code>git status</code> 会显示 <code>renamed</code>）。</p><p>如果你使用其他方式（如系统命令或文件管理器）移动/重命名了文件，需要手动执行：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">git rm <span class="hljs-variable">&lt;old_name&gt;</span>  <span class="hljs-comment"># 告诉 Git 删除旧路径的文件</span><br>git add <span class="hljs-variable">&lt;new_name&gt;</span> <span class="hljs-comment"># 告诉 Git 跟踪新路径的文件</span><br></code></pre></td></tr></table></figure><p>提交前完成这两步，Git 同样能识别为重命名。</p><h2 id="提交更改">提交更改</h2><p>执行 <code>git commit</code>会打开默认文本编辑器，其中包含对本次提交的注释模板（类似<code>git status</code>输出的注释行），在文件首行输入提交说明即可；也可使用<code>git commit -m "提交信息"</code>将提交说明写在命令行中。注意每次<code>git commit</code>实现一个功能或者改好一个bug就好，注释一定要写清楚，一定，一定。</p><p>提交完成后，会输出当前所在分支、生成的提交 SHA-1以及此次修改涉及的文件数、行数等统计信息；</p><p>每次提交只记录暂存区的快照，未暂存的更改不会被包含，仍保留在工作目录中，需在下次提交前再次执行<code>git add</code>。</p><h2 id="进阶跳过使用add">进阶：跳过使用add</h2><p>为了方便，可以直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -a<br></code></pre></td></tr></table></figure><p>以此来跳过使用add和暂存区域，但是会给所有跟踪过的文件暂存一块提交，就不这么精细</p><h1 id="git回顾">Git回顾</h1><h2 id="查看提交历史">查看提交历史</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>这个是用来看提交历史流程，最新的在上，旧的在下面。会给作者名、提交者、概要之类的信息。</p><p>这个可以有很多参数进行细致的查看，这里由于笔者本人大型项目开发经验欠缺，暂时先略过，等我用到再说。</p><h1 id="git撤销">Git撤销</h1><p>这个可能会导致工作丢失，如果操作不好的话。</p><p>暂时先写到这里，等期末考完再说下一步。</p><p>Git GUI汉化包：<ahref="https://github.com/stayor/git-gui-zh">stayor/git-gui-zh</a></p><p>参考资料：</p><ul><li><ahref="https://github.com/stayor/git-gui-zh">stayor/git-gui-zh</a></li><li><a href="https://zhuanlan.zhihu.com/p/259270374">Git的汉化 -知乎</a></li><li><a href="https://git-scm.com/book/en/v2">Git</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾的小杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake与动态静态库</title>
    <link href="/2025/05/29/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-05-29-CMake%E4%B8%8E%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2025/05/29/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-05-29-CMake%E4%B8%8E%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake">CMake</h1><p>本篇来源于上信号与系统时候摸的鱼。</p><h2 id="基本概念">基本概念</h2><p>用 CMakeList.txt 自动生成各平台的构建文件，是生成构建系统的工具。</p><p>稍高于基准的手动配置(定义项目结构，依赖项，编译选项，不用手动配置工具。</p><h2 id="配置">配置</h2><ul><li>CMakeLists.txt</li><li>构建目录（mkdir build），是保证源代码的整洁。</li></ul><p>（感觉下一篇可以写一写 PATH。注册表什么的？）</p><h2 id="cmakelist.txt-语法">CMakeList.txt 语法</h2><ul><li><a href="https://www.runoob.com/cmake/cmake-tutorial.html">CMake教程 | 菜鸟教程</a></li></ul><p>（静态库与动态库又是什么？）</p><h2 id="使用流程">使用流程</h2><ul><li>创 build 目录 → 生成构建文件（.../build # Cmake...）。</li><li>编译与构建（make ...）。</li><li>清理构建文件（make clean / 删除 Cmakecache.txt）。</li></ul><p>作为编译流程的一部分，下级有make、ninja、vs之类的构建工具，可以进一步了解。</p><h1 id="静态库与动态库">静态库与动态库</h1><p>基础是菜鸟教程的一篇blog。</p><ul><li><ahref="https://www.runoob.com/w3cnote/cpp-static-library-and-dynamic-library.html">C++静态库与动态库| 菜鸟教程</a></li></ul><p>同理不讲这俩的底层格式之内存布局。</p><h2 id="什么是库">什么是库</h2><p>底层轮子工具包，让后人不必重复造轮子。本底是可视行代码的三进制形式，可载入内存使用。</p><ul><li>静态库（.a、.lib）</li><li>动态库（.so、.dll）。</li></ul><p>源文件 → 编译 → 链接 → 执行</p><p>动/静态库于链接时接入，区别来自如何处理链接。</p><h3 id="静态库">静态库</h3><p>编译到程序中的库</p><h4 id="优点">优点</h4><ul><li>移植到别的计算机的时候方便，不用配环境</li><li>方便更新</li></ul><h4 id="缺点">缺点</h4><ul><li>占用大</li><li>更新不方便</li></ul><h4 id="构建">构建</h4><ul><li>Linux下用ar工具构建</li><li>Windows用lib.exe构建</li></ul><h3 id="动态库">动态库</h3><h4 id="优点-1">优点</h4><ul><li>运行程序时调用</li><li>方便更新</li></ul><h4 id="缺点-1">缺点</h4><ul><li>DLL HELL，就需要总是配环境</li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾的小杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>星际穿越</title>
    <link href="/2025/05/29/%E7%95%AA%E5%89%A7%E9%89%B4%E8%B5%8F/%E7%94%B5%E5%BD%B1/2025-05-29-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/"/>
    <url>/2025/05/29/%E7%95%AA%E5%89%A7%E9%89%B4%E8%B5%8F/%E7%94%B5%E5%BD%B1/2025-05-29-%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/</url>
    
    <content type="html"><![CDATA[<p>在此再次感谢我的搭档与我共同完成本次作品。下面展示我写的这部分</p><hr /><h2 id="介绍与背景阐述">介绍与背景阐述</h2><p>星际穿越是由著名导演克里斯托弗·诺兰指导的一部原创科幻冒险电影，上映于2014年11月5日，豆瓣评分9.4。</p><p>诺兰这样解释创作初衷，“小时候，成为一名宇航员是最崇高的梦想和最终极的野心。我怀念对不断探索和向着银河最深处前进的坚持。希望我们这次能够开启‘向外延伸’的新时代。”《星际穿越》既是他对经典太空电影的致敬，也是他童年梦想的延续。在制作中，他也一如既往的倾向于使用实景拍摄和IMAX 胶片，而非完全依赖 CG，以求真实感与沉浸感。</p><p>为了确保电影中科学理论的真实性，诺兰邀请了诺贝尔奖得主、理论物理学家基普·索恩担任科学顾问，确保虫洞与黑洞等天体物理现象的严谨性。索恩团队使用数千台计算机模拟爱因斯坦方程，绘制出的黑洞影像对天体物理学研究也产生了积极影响。同时索恩著有《星际穿越的科学》这本书对影片中的科学原理进行逐一刨析。</p><h2 id="观后感">观后感</h2><p>《星际穿越》的故事结构精巧，总体来看具有明暗两层线，明线是库珀在超立方体里面用传递信息的方式救了女儿和全人类，引力是传递信息的媒介，而爱是库珀行动的动机。暗线则是高维人类使用造虫洞、超立方体的方式来拯救现在的人类。</p><p>《星际穿越》的伏笔与铺垫则又如公式般严谨而精密：开篇书房里无端震颤的书架、墨菲口中“幽灵”的呓语、沙子间暗藏的NASA基地坐标，这些看似好似超自然现象都伏笔，都在结尾库珀在超立方体表面拨动世界管，墨菲破解手表指针震颤的瞬间被回收，形成闭环。诺兰让我们明白，五维空间的书架既是父爱的载体，也是人类为自救埋下的时光胶囊，正如墨菲定律所言：所有被引力牵引的偶然，终将成为必然的星光。</p><p>《星际穿越》在细节处理和次要人物塑造上也值得我们进行探讨。以男主人公库珀的两个孩子而言，墨菲是仰望星空的开拓者，是被万人敬仰的存在；但儿子则是脚踩泥土的守望者，至关重要但却容易被人遗忘，甚至连名字都是最普通的汤姆。当父亲将“守护家园”的承诺托付给儿子时，这个剧中唯一的普通人用自己的脊梁撑起了整个人类。他对父亲有着无条件的信任，父亲只不过是一句照顾好家人的交代，自己便在老屋和农田中坚守了几十年，直到墨菲回家仍能找到几十年前父亲送给自己的手表，进而破译出父亲的暗语。父亲的宇航服与儿子的犁头同样闪耀：前者传递出黑洞的相关数据，后者则为信息的传递保留了桥梁。拯救人类的不能只有几个能力超群的英雄，更有千千万万汤姆这样坚守的普通人。</p><p>影片结束后，我又在思考这个问题：人们为什么会迷恋这种科幻作品？我想，人们迷恋科幻，或许恰是因为这些作品如同棱镜，折射出人类灵魂深处最深邃的悖论：我们既是浩瀚星尘的产物，是理性的孩子，又是星尘中唯一会为星光流泪的感性存在。正如《三体》中，歌者以二向箔将太阳系化作梵高笔下的流动星河，冰冷的理性与炽热的悲悯在一瞬间交织成璀璨绝唱；而在《银河帝国》里，心理史学框架下的人们更是在用自己的一生谱写着信仰与背叛、权利与情感的史诗。科幻从不只是对未来的单纯狂想，更是在剖析着我们内心的理性与感性。正是在科幻作品的映射下，在公式的演算与人性的光辉中，我们才能真正看清自己。</p><p>而《星际穿越》之所以震撼人心，我想正是因为它关注到了这种矛盾，将其谱写为星空下的史诗。当库珀漂浮在超立方体表面，用手指拨动书籍的世界管，冷冰冰的公式与黑洞奇点数据便有了体温；黑洞吸积盘辐射的每道射线，都成了跨越维度的思念回响。诺兰与索恩用这样一个故事让我们明白：原来科学与技术作为我们人类挑战自然时最有力的武器，面对我们自己时也能雕刻出爱的形状。正如卡尔·萨根在《宇宙》中写道：“我们DNA里的氮元素，牙齿里的钙元素，血液里的铁元素，都是曾经大爆炸时散落的星辰。”科技与人情从来不是对立面，而是如同光的波粒二象性一般，是同一种物质在不同维度的投影。</p><p>当片尾字幕随管风琴的轰鸣升向黑暗，银幕外的我们仍被困在名为“人类”的困局里：我们既是星尘中的尘埃，又是星尘中唯一试图理解尘埃的神明。诺兰用也在本部影片中告诉我们，当引力波的涟漪在时空中扩散之时，唯有爱能让杂波变为传递信息的使者；当分子在虚空中漫无目的的运动之时，唯有篝火旁相扣的十指能定义存在的温度。或许宇宙从不关心人类如何用虫洞开辟出自己种族生的道路，不关心人类是如何在黑板上写下一行行公式与符号，但正是这种宇宙眼里徒劳的浪漫，让我们在无尽熵增的荒漠中，种出了名为文明的绿洲。让我们仰头去凝望夜空吧，那每一道来自远古的光斑都在低语：去计算光年，去笑，去流泪，去成为宇宙最温柔的星尘。</p><p>不要温和地走进那良夜，</p><p>老年应当在日暮时燃烧咆哮；</p><p>怒斥，怒斥光明的消逝。</p>]]></content>
    
    
    <categories>
      
      <category>番剧鉴赏</category>
      
      <category>电影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧鉴赏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05-28-廿</title>
    <link href="/2025/05/28/%E5%8F%8D%E6%80%9D/2025-05-28-%E5%BB%BF/"/>
    <url>/2025/05/28/%E5%8F%8D%E6%80%9D/2025-05-28-%E5%BB%BF/</url>
    
    <content type="html"><![CDATA[<p>今天是端午节的前三天，农历五月初二，我的二十岁生日。</p><p>大抵只消这一句，我那假想中的读者们就能知道为什么会取这样一个题目了吧。是的，人生的第二十个年头，就要来了；人生的第二十个夏天，就要来了。</p><p>在这样一个特殊的日子里，我又敲击起键盘，大概是要假装写下一些什么东西吧，像每个愿意给生活带来点仪式感的人一样。</p><p>从哪里开始记下流水账呢，是早上起来狂赶到综教上信号与系统还是昨晚补完作业呢？或许还是感觉从昨晚在床上刷手机到4点然后才睡着吧。近来确实较为忙碌，从上周的集创赛初赛结束，紧接着就是电工杯数学建模和去视听会帮忙干活，忙活到这周本来以为能稍微喘息一下，结果又是老师开始催集创赛的进度，又是要去剪光影组最后一期节目做后期，然后还有市创和校创的的中期赶进度。这些是我喜欢的工作吗？好像是的。但是我为什么做完这些会很累呢，这真的是我想要的生活吗？我真的愿意凭借这些东西来养活我自己吗？我真的能凭借这些来养活我自己吗？再或者，进一步想，我为什么要活下去呢？活下去又是为了什么呢？我不知道。我找不到活下去的理由，只不过是有我不能销掉地球online的号的缘由罢了。于是，即使是在复习完Z变换后的夜半时分，即使已是缺月挂疏桐，电子设备上的劣质小视频仍伴我直至鸡鸣破晓、红日初升。</p><p>凤箫声动，蛾眉不见阑珊处；玉壶光转，鱼龙又为何人舞</p><p>怎么高中的臭毛病又犯了，还在这编酸词儿呢。</p><p>用人话说就是，或许真的是我无法从别的地方找到慰藉，抑或是单纯的抖音至少给了我一个保障：只要我有电有网，就会一直给我推荐可能有兴趣的视频，然后，我又在二十岁的第一天，因为玩乐清醒直到天明。</p><p>然后就是睡了三个小时，去上信号与系统。讲的是Z变换，还有两周就结课准备考试了。说实在我觉得这门课还真算有意思的，至少来说让我学到信号是啥，系统是啥，明白怎么用各种变换，各种时域频域分析来处理信号，就好像我真的学完这门课能够轻轻松松的拿捏了信号一般，给人以一种虚假而又真实的掌握了某些事物命运的感觉。</p><p>在这里要感谢一个哥们-sc，在上信号与系统的课上提醒我今天是我生日。真太感动了宝贝儿，我自己都快忘掉这个东西了。或许可以进一步讲讲纪念日对于人的意义？曾经我对生日、毕业这种特殊的日子嗤之以鼻，也就放假的日子会特别关注。今天在这里或许可以说这样一句莫名其妙的话：所有的纪念日实际上你不去关注，不认为有意义那就确实没有意义，但是如果你关注了，觉得他有意义，那么这些纪念日对你来说就是十分到有意义。他就相当于跑马拉松时候的里程标记，你不在意他继续跑下去一点问题没有，但是如果你注意了他，就会意识到自己已经经历了这么多，回头想一想自己在这段路上的得与失，然后调整心境，不论好坏，继续向前。</p><p>下午是十分神经的社会实践的课堂部分，老师也在吹水，听完安排签完到就跑了，大可略过不提。</p><p>晚上吃完饭去工训楼摆弄无人机，比较抽象，臣等刚克一城，陛下何故催军？岂敢定居？一月三捷。整完学长走了去吃烤串，馆子还行，然后哥们两个一拍脑门走咱俩单独飞去，一到机场自己飞，赶紧收工。实际上丁神还是挺靠谱的，不过这把倒是显得我不靠谱就是了。</p><p>做完跟丁神骑车从南校区中间道旁树旁走，夏日的晚风总是带不来一丝凉意，耳畔却是操场上踢着足球的哥们的呐喊（怎么回忆起来操场好像还亮着灯？）。莫名感觉很青春，在二十岁的第一天，在已经疲惫不堪、宛如社畜或老人的二十岁的第一天，在10点多的单车上感受到了一点青春的自由与朝气。也许这就是这个世界送给我的，二十岁的最好的礼物吧。</p><p>莫道桑榆晚，为霞尚满天。抓住青春的尾巴，尽量在脑海中形成一些值得回味的突触连接吧。</p><p>与君，共勉。</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05-07-深夜随便写写</title>
    <link href="/2025/05/07/%E5%8F%8D%E6%80%9D/2025-05-07-%E6%B7%B1%E5%A4%9C%E7%9D%A1%E4%B8%8D%E7%9D%80%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF/"/>
    <url>/2025/05/07/%E5%8F%8D%E6%80%9D/2025-05-07-%E6%B7%B1%E5%A4%9C%E7%9D%A1%E4%B8%8D%E7%9D%80%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<p>刚刚抄完信号与系统的第六章作业，然后给课件翻了翻，毕竟明天又要小测，看着还行，至少能自己看懂啥意思，然后就又不想看了，莫名其妙又开了个文件想写些东西。</p><p>但是又写些什么呢，想想点酸词，诸如什么长夜漫漫，京郊黑黑之类的，倒也没什么意思，毕竟谁又会特地来这看这篇文章呢？各种推荐算法怎么也不会把流量分给我这里，真算起身边人来也不会有谁没事来看我一眼。</p><p>莫名的又想到了今天看到的一个新闻，讲一个湖南的男子准备跳湘江自杀，行动之前又点了一杯奶茶，还整个备注说自己要死了，后续就是奶茶店店主、小哥、警察一块给他救回来了。众人去的时候，那哥们看着是就剩个头还在水面上，不知道的还以为江上飘着个皮球，嗐呀，这事闹的。</p><p>实际上要我说，这人应该是不想死的，真要是一心寻死，哪会还把自己的死讯广而告之。哥们只不过是太寂寞了，从陌生人那里得到一些温暖，就又愿意继续活下去了。比如店员的那句“我多给你打一勺冻冻你不要死好不好”，说实在的看到这句话我莫名其妙的有点想笑，真就跟哄小孩一样，摸摸头给个笑脸就不哭了，但是不可否认的是这哥们应该是真就缺这一点。同时又有一种感慨吧，在我这个社会渣泽的角度看来，又是麻烦不知名的店员、警察，用自己的生命作为威胁换来一点点的陌生人的关心，等他回过味来的时候，真的不会为自己的这种以命博同情的做法而感到更进一步的寂寞或者羞耻吗。</p><p>我假想的读者啊，可能你会觉得我这样说过于残忍，指责我是一个冷血的社会败类，大概确实是这样的吧，我接受你的批评，因为我自己也不知道我这样想是对错，我甚至不知道为什么我要三更半夜不睡觉在这敲键盘。我只知道的是像这哥们一样，生而为人，很难遇到知心的伴侣，无论同性或是异性，人人都是孤岛，并不是什么广袤大地的一部分。</p><p>但是如何去纾解命运中寂寞的底色呢，我不知道，否则我也不会在这里继续漫无目的的敲击键盘了。</p><p>睡觉。</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05-04-巴普洛夫的二八狗</title>
    <link href="/2025/05/04/%E5%8F%8D%E6%80%9D/2025-05-04-%E5%B7%B4%E6%99%AE%E6%B4%9B%E5%A4%AB%E7%9A%84%E4%BA%8C%E5%85%AB%E7%8B%97/"/>
    <url>/2025/05/04/%E5%8F%8D%E6%80%9D/2025-05-04-%E5%B7%B4%E6%99%AE%E6%B4%9B%E5%A4%AB%E7%9A%84%E4%BA%8C%E5%85%AB%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<p>原谅我在五四青年节用这样一个奇妙的名字来写这篇文章。主要是刚才在浴室里面思考我近来的状态，发现自己对正儿八经的学习和工作总是提不起兴趣，或者说干活所用到的时间比其他人正常情况下所用的时间要多不少，就比如之前做那个广播台的节目，再比如建模的时候我用三天舍友就用一天，问题很大反正是。</p><p>要是解决我总是拖延不干活的问题（包括现在这篇文章也是我顶着几个火烧眉毛的ddl搁这写的），首先我觉得要先去把自己想象成巴普洛夫的狗。抛开原始的乱七八糟的生物学结论不谈，我这关注的是巴老先生的狗之所以能够学习到相关的行为，其背后的逻辑是啥样的：（大概就是学习的正反馈的构成）</p><pre><code class=" mermaid">flowchart TD A[初始的动力打开学习开关]--&gt;B[进行相关知识的学习] B--&gt;C[学习得到好结果] C--&gt;D[转化为进行下去的动力] D--&gt;B</code></pre><p>高中的时候之所以能够卷生卷死，实际上确实在我这是有一个这样的逻辑的，主要矛盾给放到上个好大学上面，然后十分频繁的考试又能够有效的将我的学习成果量化出来转变为动力，这个正循环确实是从初中开始一直支撑我走到大学。</p><p>但是大学以来这个学习的正循环很显然被打破了，总是感觉学习没啥意思，学起来也没啥（同时也能发现我这快两年了大多数情况下还是这个德行）</p><p>一个是要找到开始学习的动力，这个确实很虚而且我自己也很需要，对于我自己而言实际上我也没有想明白；一个是要找到能将学习进度转换为下一步的策略，这个我觉得我也比较缺少；再一个可能还有个技巧，连带着后文一起讲吧。</p><p>然后是为什么干活时间总是比别人久，我觉得两方面原因，一个是感觉有的东西他真没必要追求最好，比如舍友他们的目标就是做完而已，毕竟做完就能有资格，所以他们做的快；跟我在一起的搭档也是配完音就不返音不怎么修改，因为实际上第一遍也能展示自己的百分之八十，为什么还要投入更多的时间在上面只为那百分之二十呢？霓虹那边我记得看泡沫年代的微观经济学分析的时候有这样一个例子，企业为了去节约成本，把目光放在了让员工节约最后的那一点边角料上，为了节约边角料去浪费巨量的人力成本。我这样做又和日本企业节约边角料有什么区别呢？这和以前上课插入浪费时间的例行公事部分的时候老师安慰“多学一点没有什么害处”又有多大的区别呢？歌颂完美是好，但是很多情况下我也没有必要去追求完美，因为有的东西的完美的性价比真的不如我再拿时间去干别的事。</p><p>于是就又引到了二八定理上，百分之八十的收益是在百分之二十的时间里面，二要不要花费这百分之八十的时间去完成这个百分之二十还要掂量掂量，看他值不值得，能不能提供给我应有的成绩，足量的进行下一步学习的动力。</p><p>当然话是这么讲，我写这篇文章耽误我其他事又与上述说法相违背了呢）</p><p>话继续拐过来，第二个原因就是无法进行心流状态。中学的时候我接触手机之类的东西远没有现在多，现在干什么活干着干着总会倾向于开摆，比如我写代码写一半开始写这篇稿子就是其中之一。这一点我觉得，一个是要降低娱乐的吸引力，第二个又回到上述的那个巴普洛夫里面，要利用这种正反馈机制，来让这个学习研究更吸引自己。</p><p>ok大概就这么多，吸取上述的经验，一共两个事：</p><ul><li>要明白自己学习的奖励机制是啥，把自己当成巴普洛夫的狗</li><li>要进行取舍，用二八法来决定做到什么程度，杜绝完美主义</li></ul><p>差不多就写这么多，然后我要践行上面的东西了，再</p>]]></content>
    
    
    <categories>
      
      <category>反思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岭回归与Lasso回归-ridge&amp;lasso</title>
    <link href="/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E5%B2%AD%E5%9B%9E%E5%BD%92%E4%B8%8ELasso%E5%9B%9E%E5%BD%92/"/>
    <url>/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E5%B2%AD%E5%9B%9E%E5%BD%92%E4%B8%8ELasso%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="岭回归与lasso回归完全解析">岭回归与Lasso回归完全解析</h1><h2 id="一为什么需要正则化回归">一、为什么需要正则化回归？</h2><h3 id="ols的困境">1. OLS的困境</h3><p>多元线性回归（OLS）是建模的基础方法，但当数据存在<strong>多重共线性</strong>或<strong>变量过多</strong>时，OLS会面临两大问题：- <strong>系数估计不稳定</strong>：微小数据变动导致系数剧烈波动 -<strong>过拟合风险</strong>：模型在训练集表现好，但泛化能力差</p><h3 id="正则化的引入">2. 正则化的引入</h3><p>通过在损失函数中加入<strong>惩罚项</strong>，限制模型复杂度： -<strong>岭回归（Ridge）</strong>：L2正则化 -<strong>Lasso回归</strong>：L1正则化</p><hr /><h2 id="二数学原理从ols到正则化">二、数学原理：从OLS到正则化</h2><h3 id="ols回归">1. OLS回归</h3><p>损失函数：<br /><span class="math display">\[\min_{\beta} \sum_{i=1}^n (y_i - \beta_0 - \sum_{j=1}^p \beta_jx_{ij})^2\]</span></p><h3 id="岭回归ridge">2. 岭回归（Ridge）</h3><p>加入L2范数（欧氏范数）惩罚项（λ控制惩罚力度）：<br /><span class="math display">\[\min_{\beta} \left[ \sum_{i=1}^n (y_i - \beta_0 - \sum_{j=1}^p \beta_jx_{ij})^2 + \lambda \sum_{j=1}^p \beta_j^2 \right]\]</span></p><p><strong>特点</strong>： - 所有系数被等比例压缩，但不会归零 -解决多重共线性问题，提升模型稳定性 -是以放弃无偏性、降低精度为代价解决病态矩阵问题的回归方法</p><h3 id="lasso回归">3. Lasso回归</h3><p>加入L1（曼哈顿范数）惩罚项：<br /><span class="math display">\[\min_{\beta} \left[ \sum_{i=1}^n (y_i - \beta_0 - \sum_{j=1}^p \beta_jx_{ij})^2 + \lambda \sum_{j=1}^p |\beta_j| \right]\]</span></p><p><strong>特点</strong>： -可将不重要变量的系数压缩至零，实现<strong>变量选择</strong> -适用于高维数据（变量数&gt;样本数）</p><hr /><h2id="三核心操作正则化参数λ的选择">三、核心操作：正则化参数λ的选择</h2><h3 id="交叉验证k-fold-cv">1. 交叉验证（K-Fold CV）</h3><ul><li><strong>步骤</strong>：将数据分为K份，轮流用K-1份训练，1份验证，计算平均误差</li><li><strong>目标</strong>：选择使验证误差最小的λ值</li></ul><h3 id="正则化路径">2. 正则化路径</h3><ul><li><strong>岭回归</strong>：系数随λ增大逐渐趋近于零</li><li><strong>Lasso</strong>：系数随λ增大会突然变为零</li></ul><p><strong>Python示例（可视化路径）</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LassoCV, RidgeCV<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># Lasso路径</span><br>alphas = np.logspace(-<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>coefs = []<br><span class="hljs-keyword">for</span> alpha <span class="hljs-keyword">in</span> alphas:<br>    lasso = Lasso(alpha=alpha)<br>    lasso.fit(X, y)<br>    coefs.append(lasso.coef_)<br><br>plt.plot(alphas, coefs)<br>plt.xscale(<span class="hljs-string">&#x27;log&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;λ&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Coefficients&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Lasso Regularization Path&#x27;</span>)<br></code></pre></td></tr></table></figure></p><hr /><h2 id="四实战案例棉花产量预测">四、实战案例：棉花产量预测</h2><h3 id="数据说明">1. 数据说明</h3><ul><li><strong>自变量</strong>：种子费、化肥费、农药费、机械费、灌溉费</li><li><strong>因变量</strong>：棉花单产（1990-2007年数据）</li></ul><h3 id="操作流程python实现">2. 操作流程（Python实现）</h3><h4 id="数据标准化">(1) 数据标准化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br>X_scaled = scaler.fit_transform(X)<br></code></pre></td></tr></table></figure><h4 id="lasso回归建模">(2) Lasso回归建模</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LassoCV<br><br><span class="hljs-comment"># 10折交叉验证选择λ</span><br>lasso = LassoCV(cv=<span class="hljs-number">10</span>, random_state=<span class="hljs-number">42</span>)<br>lasso.fit(X_scaled, y)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最优λ：&quot;</span>, lasso.alpha_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;非零系数：&quot;</span>, lasso.coef_)<br></code></pre></td></tr></table></figure><h4 id="结果解读">(3) 结果解读</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">最优λ：<span class="hljs-number">0.05</span><br>非零系数：种子费<span class="hljs-selector-attr">[0.32]</span>、农药费<span class="hljs-selector-attr">[-0.34]</span>、灌溉费<span class="hljs-selector-attr">[0.74]</span><br></code></pre></td></tr></table></figure><ul><li><strong>结论</strong>：机械费、化肥费被剔除，模型保留3个关键变量</li></ul><hr /><h2 id="五注意">五、注意</h2><h3 id="必须标准化数据">1. 必须标准化数据</h3><ul><li><strong>原因</strong>：正则化对尺度敏感，大范围变量会主导惩罚项</li><li><strong>方法</strong>：使用<code>StandardScaler</code>将变量标准化为均值为0，方差为1</li></ul><h3 id="如何解释系数">2. 如何解释系数？</h3><ul><li><strong>岭回归</strong>：系数代表变量对目标的影响方向，但大小受λ影响</li><li><strong>Lasso</strong>：非零系数表示重要变量，但绝对值无直接可比性</li></ul><h3 id="λ的选择陷阱">3. λ的选择陷阱</h3><ul><li><strong>过小</strong>：接近OLS，失去正则化效果</li><li><strong>过大</strong>：所有系数被过度压缩，模型欠拟合</li></ul><hr /><h2 id="六模型对比与选择">六、模型对比与选择</h2><table><thead><tr><th>指标</th><th>岭回归</th><th>Lasso回归</th></tr></thead><tbody><tr><td>正则化类型</td><td>L2</td><td>L1</td></tr><tr><td>系数特性</td><td>连续压缩，不归零</td><td>稀疏性（部分归零）</td></tr><tr><td>适用场景</td><td>多重共线性严重</td><td>高维数据/变量选择</td></tr><tr><td>计算复杂度</td><td>解析解（快速）</td><td>需迭代优化（较慢）</td></tr><tr><td>软件实现</td><td><code>RidgeCV</code>（Python）</td><td><code>LassoCV</code>（Python）</td></tr></tbody></table><hr /><h2 id="七常见问题解答">七、常见问题解答</h2><h3 id="q1何时用岭回归何时用lasso">Q1：何时用岭回归？何时用Lasso？</h3><ul><li><strong>岭回归</strong>：变量均重要，但存在共线性（如经济指标分析）</li><li><strong>Lasso</strong>：变量数多，需筛选关键因素（如基因数据建模）</li></ul><h3 id="q2elastic-net是什么">Q2：Elastic Net是什么？</h3><ul><li><strong>混合正则化</strong>：L1+L2，平衡变量选择与稳定性</li><li><strong>公式</strong>：<br /><span class="math display">\[\text{损失函数} + \lambda (\alpha \sum|\beta_j| + (1-\alpha) \sum \beta_j^2)\]</span></li></ul><h3 id="q3如何解释λ0的情况">Q3：如何解释λ=0的情况？</h3><ul><li>λ=0时，模型退化为普通OLS回归</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>预测类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元线性回归分析</title>
    <link href="/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
    <url>/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="多元线性回归分析">多元线性回归分析</h1><p>回归分析是数据分析的核心工具，旨在通过研究自变量 X 与因变量 Y的相关性，揭示 Y的形成机制，并实现预测。多元线性回归通过线性组合解释变量，量化各因素对结果的影响权重，广泛应用于经济、管理、工程等领域。</p><hr /><h2 id="一用途">一、用途</h2><ol type="1"><li><strong>识别重要变量</strong>：筛选出与 Y 显著相关的X（如逐步回归法）；<br /></li><li><strong>判断方向性</strong>：确定 X 对 Y 的正/负向影响；<br /></li><li><strong>估计权重</strong>：通过回归系数反映变量的相对重要性。</li></ol><hr /><h2 id="二构建">二、构建</h2><p><span class="math display">\[Y_i = \beta_0 + \beta_1 X_{1i} + \beta_2 X_{2i} + \cdots + \beta_kX_{ki} + \mu_i\]</span> 其中 <span class="math inline">\(\beta_0\)</span>为截距项，<span class="math inline">\(\beta_j\)</span>为偏回归系数，<span class="math inline">\(\mu_i\)</span> 为扰动项。</p><ul><li><span class="math inline">\(\beta_j\)</span>：控制其他变量时，<spanclass="math inline">\(X_j\)</span> 每增加1单位，<spanclass="math inline">\(Y\)</span> 平均变化 <spanclass="math inline">\(\beta_j\)</span> 单位；<br /></li><li>可以先 <span class="math inline">\(Z-Score\)</span>标准化数据再看回归系数，绝对值越大贡献越显著。</li></ul><hr /><h2 id="三模型检验与优化">三、模型检验与优化</h2><h3 id="拟合优度">1. 拟合优度</h3><ul><li><strong>判定系数 <spanclass="math inline">\(R^2\)</span></strong>：反映模型解释的变异比例，<spanclass="math inline">\(R^2 \in [0,1]\)</span>，越高越好；<br /></li><li><strong>调整 <spanclass="math inline">\(R^2\)</span></strong>：避免自变量过多导致的虚假高拟合。</li></ul><h3 id="异方差处理">2. 异方差处理</h3><ul><li><strong>症状</strong>：残差随预测值增大而扩散；<br /></li><li><strong>诊断</strong>：BP检验、怀特检验；<br /></li><li><strong>解决</strong>：使用 <code>OLS + 稳健标准误</code>或广义最小二乘法（GLS）。</li></ul><h3 id="多重共线性">3. 多重共线性</h3><ul><li><strong>症状</strong>：系数符号反常、<spanclass="math inline">\(t\)</span> 检验不显著但 <spanclass="math inline">\(R^2\)</span> 较高；<br /></li><li><strong>诊断</strong>：方差膨胀因子（VIF &gt; 10 为严重）；<br /></li><li><strong>解决</strong>：剔除高相关变量、增大样本量、主成分降维。</li><li>具体这个又可以开另外一个blogs来说明。</li></ul><hr /><h2 id="四stata示例">四、Stata示例</h2><h3 id="基础回归">1. 基础回归</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">* 导入数据并描述统计</span><br>import excel <span class="hljs-string">&quot;data.xlsx&quot;</span>, firstrow <span class="hljs-keyword">clear</span><br><span class="hljs-keyword">summarize</span> Y X1 X2<br><br><span class="hljs-comment">* 多元回归（含虚拟变量）</span><br><span class="hljs-keyword">regress</span> Y X1 X2 i.region, robust<br></code></pre></td></tr></table></figure><h3 id="逐步回归">2. 逐步回归</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">* 向前逐步回归（显著性阈值5%）</span><br><span class="hljs-keyword">stepwise</span> <span class="hljs-keyword">regress</span> Y X1 X2 X3, pe(0.05) robust<br><br><span class="hljs-comment">* 向后逐步回归</span><br><span class="hljs-keyword">stepwise</span> <span class="hljs-keyword">regress</span> Y X1 X2 X3, <span class="hljs-keyword">pr</span>(0.05) robust<br></code></pre></td></tr></table></figure><hr /><h2 id="五应用与创新">五、应用与创新</h2><h3 id="局限性">1. 局限性</h3><ul><li><strong>内生性</strong>：遗漏变量或测量误差导致系数有偏，详细说明就是如果满足误差项<span class="math inline">\(μ\)</span>和所有的自变量均不相关，则称该回归模型具有外生性；如果相关，则存在内生性，内生性会导致回归系数估计的不准确：不满足无偏和一致性，需引入工具变量；<br /></li><li><strong>模型过拟合</strong>：变量过多时，需通过交叉验证或正则化（LASSO/Ridge）优化；<br /></li><li><strong>非线性关系误判</strong>：可通过变量变换（如取对数）或引入交互项。</li></ul><h3 id="创新拓展">2. 创新拓展</h3><ul><li><p><strong>结合主成分分析</strong>：对高维数据降维后回归，解决多重共线性；</p></li><li><p><strong>混合效应模型</strong>：处理面板数据中的个体/时间效应；</p></li><li><p><strong>机器学习融合</strong>：用随机森林筛选重要变量，再构建回归模型。</p></li><li><p><strong>取对数</strong>：取对数意味着原被解释变量对解释变量的弹性，即百分比的变化而不是数值的变化，好处有：（1）减弱数据的异方差性（2）如果变量本身不符合正态分布，取了对数后可能渐近服从正态分布（3）模型形式的需要，让模型具有经济学意义。</p></li><li><p><strong>事先标准化易于解释</strong>：可以先 <spanclass="math inline">\(Z-Score\)</span>标准化数据再看回归系数，绝对值越大贡献越显著。</p></li><li><p><strong>虚拟变量引入</strong>：</p><p>定性变量（如性别、地域）需转换为0-1虚拟变量。例如：<br /><span class="math display">\[\text{工资} = \beta_0 + \delta_0 \text{Female}_i + \beta_1\text{教育年限}_i + \mu_i\]</span> <span class="math inline">\(\delta_0\)</span>表示在同等教育水平下，女性与男性的工资差异。$ _i$ 的0-1标识男女</p></li></ul><hr /><h2 id="六案例分析">六、案例分析</h2><p>这俩都是清风数学建模的东西：</p><h3 id="案例1电商产品评价量影响因素">案例1：电商产品评价量影响因素</h3><ul><li><strong>目标</strong>：探究价格、品牌、产地等因素对销量的影响；<br /></li><li><strong>方法</strong>：标准化回归系数 + 虚拟变量；<br /></li><li><strong>结论</strong>：价格负向显著，进口品牌溢价明显。</li></ul><h3 id="案例2人口预测">案例2：人口预测</h3><ul><li><strong>数据</strong>：历史人口与经济指标；<br /></li><li><strong>模型</strong>：引入Logistic曲线拟合增长趋势；<br /></li><li><strong>创新</strong>：结合时间序列ARIMA预测经济变量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>预测类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灰色预测模型-GM(n,m)</title>
    <link href="/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B-GM(n,m)/"/>
    <url>/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B-GM(n,m)/</url>
    
    <content type="html"><![CDATA[<h1 id="灰色预测模型-gmnm">灰色预测模型-GM(n,m)</h1><p>具体推导部分由于本人这次数模用不上这个模型，ai生成之后还没有审核过。</p><h2 id="一背景">一、背景</h2><h3 id="数据困境">1. 数据困境</h3><p>在数学建模中，我们常遇到<strong>数据量少</strong>（4~10期）、<strong>信息不完整</strong>的情况。例如：- 某城市过去5年的GDP数据 - 某新型材料3年的实验测试记录 -某传染病爆发初期的7天感染人数</p><p><strong>传统预测方法（如回归分析、时间序列）需要大量数据支撑</strong>，而灰色预测能在小样本，少信息的条件下挖掘规律。</p><h3 id="灰色系统理论">2. 灰色系统理论</h3><ul><li><strong>白色系统</strong>：信息完全明确（如电路系统）</li><li><strong>灰色系统</strong>：部分信息已知，部分未知（如经济系统）</li><li><strong>黑色系统</strong>：信息完全未知（如宇宙暗物质）</li></ul><p>灰色预测正是针对<strong>灰色系统</strong>的建模方法，核心思想：<strong>通过数据加工处理，将杂乱无章的原始数据整理成规律性较强的序列，然后建立微分方程来预测未来发展趋势</strong>。</p><h3 id="使用场景">3.使用场景</h3><p>下面是清风数学建模的看法：</p><p>使用哪种模型进行预测是仁者见 仁智者见智的事情：</p><p>（1）数据是以年份度量的非负数据（如果是月份或者季度数据一定要用我们上一讲学过的时间序列模型）；</p><p>（2）数据能经过准指数规律的检验（除了前两期外，后面至少90%的期数的光滑比要低于0.5）；</p><p>（3）数据的期数较短且和其他数据之间的关联性不强（小于等于10，也不能太短了，比如只有3期数据），要是数据期数较长，一般用传统的时间序列模型比较合适。</p><hr /><h2 id="二详解--以gm11为例">二、详解--以GM(1,1)为例</h2><h3 id="数据预处理">1. 数据预处理</h3><h4 id="数据正向化">(1) 数据正向化</h4><p>详见评价类模型里面的相关正向化策略。</p><h4 id="数据检验">(2) 数据检验</h4><ul><li><strong>级比检验</strong>：验证数据是否适合GM建模 <spanclass="math display">\[\sigma(k) = \frac{x^{(0)}(k)}{x^{(0)}(k-1)} \quad (k=2,3,...,n)\]</span> 要求所有级比落在区间 <spanclass="math inline">\((e^{-\frac{2}{n+1}}, e^{\frac{2}{n+1}})\)</span>内</li></ul><hr /><h3 id="模型构建四步核心操作">2. 模型构建：四步核心操作</h3><h4 id="步骤1一次累加生成1-ago">步骤1：一次累加生成（1-AGO）</h4><p><strong>目的</strong>：将波动数据转化为单调增长序列<br /><span class="math display">\[x^{(1)}(k) = \sum_{i=1}^k x^{(0)}(i) \quad (k=1,2,...,n)\]</span></p><p><strong>示例</strong>：</p><table><thead><tr><th>原始数据</th><th>2.87</th><th>3.28</th><th>3.34</th><th>3.39</th><th>3.68</th></tr></thead><tbody><tr><td>累加序列</td><td>2.87</td><td>6.15</td><td>9.49</td><td>12.88</td><td>16.56</td></tr></tbody></table><h4 id="步骤2紧邻均值生成z序列">步骤2：紧邻均值生成（Z序列）</h4><p><strong>作用</strong>：构造微分方程的离散近似<br /><span class="math display">\[z^{(1)}(k) = 0.5x^{(1)}(k) + 0.5x^{(1)}(k-1) \quad (k=2,3,...,n)\]</span></p><p><strong>接上例</strong>： | Z序列 | - | (2.87+6.15)/2=4.51 |(6.15+9.49)/2=7.82 | ... |</p><h4 id="步骤3建立灰色微分方程">步骤3：建立灰色微分方程</h4><p><span class="math display">\[x^{(0)}(k) + a z^{(1)}(k) = b\]</span> 通过最小二乘法求解参数： <span class="math display">\[\begin{bmatrix}a \\b\end{bmatrix} = (B^T B)^{-1} B^T Y\]</span> 其中： <span class="math display">\[B = \begin{bmatrix}-z^{(1)}(2) &amp; 1 \\-z^{(1)}(3) &amp; 1 \\\vdots &amp; \vdots \\-z^{(1)}(n) &amp; 1\end{bmatrix}, \quadY = \begin{bmatrix}x^{(0)}(2) \\x^{(0)}(3) \\\vdots \\x^{(0)}(n)\end{bmatrix}\]</span></p><h4 id="步骤4求解白化方程">步骤4：求解白化方程</h4><p>得到连续型微分方程： <span class="math display">\[\frac{dx^{(1)}}{dt} + a x^{(1)} = b\]</span> 其解为： <span class="math display">\[\hat{x}^{(1)}(t) = \left(x^{(0)}(1) - \frac{b}{a}\right)e^{-a(t-1)} +\frac{b}{a}\]</span></p><p><strong>预测值还原</strong>： <span class="math display">\[\hat{x}^{(0)}(k) = \hat{x}^{(1)}(k) - \hat{x}^{(1)}(k-1)\]</span></p><hr /><h3 id="模型检验">3. 模型检验</h3><h4 id="准指数规律检验关键">(1) 准指数规律检验（关键！）</h4><ul><li><strong>光滑比</strong>：((k) = )</li><li><strong>通过标准</strong>：<ul><li>前两期可放宽</li><li>后80%期数的((k)&lt;0.5)</li></ul></li></ul><h4 id="发展系数检验">(2) 发展系数检验</h4><table><thead><tr><th>发展系数(-a)</th><th>适用性</th></tr></thead><tbody><tr><td>&lt;0.3</td><td>中长期预测（5-10期）</td></tr><tr><td>0.3~0.5</td><td>短期预测（1-3期）</td></tr><tr><td>&gt;0.5</td><td>需残差修正或更换模型</td></tr></tbody></table><h4 id="残差检验">(3) 残差检验</h4><p><span class="math display">\[\text{平均相对误差} = \frac{1}{n-1}\sum_{k=2}^n\left|\frac{x^{(0)}(k)-\hat{x}^{(0)}(k)}{x^{(0)}(k)}\right|\]</span> - &lt;10%：高精度 - 10%~20%：合格 - &gt;20%：模型不可信</p><hr /><h2id="三matlab实战长江水质污染预测">三、MATLAB实战：长江水质污染预测</h2><h3 id="数据准备">1. 数据准备</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 1995-2004年排污量（万吨）</span><br>data = [<span class="hljs-number">174</span>, <span class="hljs-number">179</span>, <span class="hljs-number">183</span>, <span class="hljs-number">189</span>, <span class="hljs-number">207</span>, <span class="hljs-number">234</span>, <span class="hljs-number">220.5</span>, <span class="hljs-number">256</span>, <span class="hljs-number">270</span>, <span class="hljs-number">285</span>];<br></code></pre></td></tr></table></figure><h3 id="完整代码实现">2. 完整代码实现</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[predict, a, b]</span> = <span class="hljs-title">GM11</span><span class="hljs-params">(data, forecast_num)</span></span><br>    <span class="hljs-comment">% 数据检验</span><br>    n = <span class="hljs-built_in">length</span>(data);<br>    lambda = data(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>)./data(<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>);<br>    range = [<span class="hljs-built_in">exp</span>(<span class="hljs-number">-2</span>/(n+<span class="hljs-number">1</span>)), <span class="hljs-built_in">exp</span>(<span class="hljs-number">2</span>/(n+<span class="hljs-number">1</span>))];<br>    <span class="hljs-keyword">if</span> any(lambda &lt; range(<span class="hljs-number">1</span>)) || any(lambda &gt; range(<span class="hljs-number">2</span>))<br>        error(<span class="hljs-string">&#x27;级比检验未通过！&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 累加生成</span><br>    X1 = cumsum(data);<br>    <br>    <span class="hljs-comment">% 紧邻均值</span><br>    Z = (X1(<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) + X1(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>)) / <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">% 构建矩阵</span><br>    B = [-Z&#x27;, <span class="hljs-built_in">ones</span>(n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)];<br>    Y = data(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>)&#x27;;<br>    <br>    <span class="hljs-comment">% 参数估计</span><br>    u = (B&#x27;*B) \ B&#x27;*Y;<br>    a = u(<span class="hljs-number">1</span>);<br>    b = u(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">% 模型求解</span><br>    predict_X1 = (data(<span class="hljs-number">1</span>)-b/a)*<span class="hljs-built_in">exp</span>(-a*(<span class="hljs-number">0</span>:n+forecast_num<span class="hljs-number">-1</span>)) + b/a;<br>    predict = diff(predict_X1);<br>    <br>    <span class="hljs-comment">% 检验</span><br>    error = <span class="hljs-built_in">abs</span>(data - predict(<span class="hljs-number">1</span>:n))./data;<br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;平均相对误差：&#x27;</span>, num2str(<span class="hljs-built_in">mean</span>(error)*<span class="hljs-number">100</span>), <span class="hljs-string">&#x27;%&#x27;</span>]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="运行结果">3. 运行结果</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; [predict, a, b] = GM11(data, <span class="hljs-number">3</span>);<br>平均相对误差：<span class="hljs-number">4.23</span><span class="hljs-comment">%</span><br>&gt;&gt; <span class="hljs-built_in">disp</span>(predict(<span class="hljs-number">11</span>:<span class="hljs-number">13</span>))  <span class="hljs-comment">% 预测2005-2007年</span><br>  <span class="hljs-number">303.01</span>   <span class="hljs-number">324.33</span>   <span class="hljs-number">346.72</span><br></code></pre></td></tr></table></figure><hr /><h2 id="四避坑指南">四、避坑指南</h2><h3 id="数据量不足4期">1. 数据量不足4期</h3><ul><li><strong>处理方法</strong>：使用三种GM变体（传统/新信息/新陈代谢）求平均</li></ul><h3 id="出现负值预测">2. 出现负值预测</h3><ul><li><strong>原因</strong>：未进行正向化处理</li><li><strong>解决</strong>：检查数据预处理步骤，使用(x' = x - (x) +1)平移</li></ul><h3 id="长期预测失真">3. 长期预测失真</h3><ul><li><strong>对策</strong>：采用滚动预测，每预测一期就更新模型</li></ul><h3 id="如何提高精度">4. 如何提高精度</h3><ul><li>残差修正：对预测残差再次建立GM(1,1)模型</li><li>组合预测：与ARIMA、指数平滑等模型加权结合</li></ul><hr /><h2 id="五应用场景推荐">五、应用场景推荐</h2><table><thead><tr><th>场景</th><th>适用性</th><th>示例</th></tr></thead><tbody><tr><td>经济指标预测</td><td>★★★★★</td><td>GDP、人口增长率</td></tr><tr><td>工程技术预测</td><td>★★★★☆</td><td>材料疲劳寿命、设备故障率</td></tr><tr><td>生态环境预测</td><td>★★★★☆</td><td>污染物浓度、碳排放趋势</td></tr><tr><td>突发事件预测</td><td>★★☆☆☆</td><td>疫情传播、灾害损失</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>预测类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拟合算法</title>
    <link href="/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E6%8B%9F%E5%90%88%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/02/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-05-02-%E6%8B%9F%E5%90%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="拟合算法">拟合算法</h1><p>与插值算法不同，拟合算法不要求曲线严格经过所有数据点，而是寻求一个函数（曲线），使得该曲线在某种准则下与所有数据点的总体误差最小。拟合的核心目标是<strong>通过对已有数据特征拟合构建最佳数学模型</strong>，广泛应用于趋势预测、参数估计等领域。</p><hr /><h2 id="一与插值的区别">一、与插值的区别</h2><table><thead><tr><th>方法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>插值</td><td>曲线必须经过所有样本点，易受龙格现象影响</td><td>数据精确、样本量少</td></tr><tr><td>拟合</td><td>曲线无需经过所有点，通过最小化误差平方和寻找全局最优解</td><td>数据含噪声、趋势分析</td></tr></tbody></table><p>当样本点过多时，高阶插值多项式会出现震荡现象，而拟合算法通过低阶函数（如线性、指数函数）能更稳定地反映数据趋势。</p><hr /><h2 id="二原理">二、原理</h2><h3 id="数学模型">1. 数学模型</h3><p>设样本点为 <span class="math inline">\((x_i, y_i), i = 1, 2, \ldots,n\)</span>，拟合曲线为 <span class="math inline">\(y = kx +b\)</span>，目标是最小化<strong>误差平方和</strong>： <spanclass="math display">\[\min_{k,b} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2 \quad \text{其中} \quad\hat{y}_i = kx_i + b\]</span></p><h3 id="参数求解">2. 参数求解</h3><p>通过求偏导并令导数为零，可得闭合解： <span class="math display">\[k = \frac{n \sum x_i y_i - \sum x_i \sum y_i}{n \sum x_i^2 - (\sumx_i)^2}, \quadb = \frac{\sum x_i^2 \sum y_i - \sum x_i \sum x_i y_i}{n \sum x_i^2 -(\sum x_i)^2}\]</span></p><h3 id="拓展">3. 拓展</h3><p>多项式线性，如二次函数等： <span class="math display">\[\quad \hat{y}_i = kx_i + kx_i^2 + b\]</span></p><hr /><h2 id="三拟合优度评价">三、拟合优度评价</h2><h3 id="判定系数-r2">1. 判定系数 <spanclass="math inline">\(R^2\)</span></h3><ul><li><strong>总体平方和（SST）</strong>：反映数据总波动<br /><span class="math display">\[ SST = \sum_{i=1}^n (y_i - \overline{y})^2\]</span></li><li><strong>误差平方和（SSE）</strong>：反映拟合误差<br /><span class="math display">\[ SSE = \sum_{i=1}^n (y_i - \hat{y}_i)^2\]</span></li><li><strong>回归平方和（SSR）</strong>：反映模型解释的波动<br /><span class="math display">\[ SSR = \sum_{i=1}^n (\hat{y}_i -\overline{y})^2 \]</span></li></ul><p><strong>拟合优度</strong>：<br /><span class="math display">\[ R^2 = \frac{SSR}{SST} = 1 -\frac{SSE}{SST} \]</span><br />- $ R^2 <span class="math inline">\(，越接近1说明拟合效果越好。- **注意**：\)</span> R^2 $ 仅适用于线性参数模型（如 $ y = a + bx^2 $视为线性，因其对参数 (a,b) 为线性）。</p><hr /><h2 id="四matlab实现">四、MATLAB实现</h2><h3 id="代码示例">1. 代码示例</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 导入数据</span><br>load data1<br><span class="hljs-built_in">plot</span>(x, y, <span class="hljs-string">&#x27;o&#x27;</span>)<br>xlabel(<span class="hljs-string">&#x27;x&#x27;</span>); ylabel(<span class="hljs-string">&#x27;y&#x27;</span>);<br><br><span class="hljs-comment">% 计算参数</span><br>n = <span class="hljs-built_in">length</span>(x);<br>k = (n*sum(x.*y) - sum(x)*sum(y)) / (n*sum(x.^<span class="hljs-number">2</span>) - sum(x)^<span class="hljs-number">2</span>);<br>b = (sum(x.^<span class="hljs-number">2</span>)*sum(y) - sum(x)*sum(x.*y)) / (n*sum(x.^<span class="hljs-number">2</span>) - sum(x)^<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% 绘制拟合曲线</span><br><span class="hljs-built_in">hold</span> on<br>fplot(@(x) k*x + b, [<span class="hljs-built_in">min</span>(x), <span class="hljs-built_in">max</span>(x)])<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;样本数据&#x27;</span>, <span class="hljs-string">&#x27;拟合曲线&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="拟合工具箱cftool">2. 拟合工具箱（cftool）</h3><p>输入 <code>cftool</code>调用MATLAB拟合工具箱，支持多种函数类型（多项式、指数、自定义方程），自动计算参数及拟合优度。</p><hr /><h2 id="五应用">五、应用</h2><h3 id="案例1美国人口预测">案例1：美国人口预测</h3><p>使用Logistic模型拟合历史数据： <span class="math display">\[x(t) = \frac{x_m}{1 + \left( \frac{x_m}{3.9} - 1 \right) e^{-r(t-1790)}}\]</span> 通过非线性最小二乘法估计参数 <spanclass="math inline">\(x_m\)</span> 和 <spanclass="math inline">\(r\)</span>，预测未来30年人口趋势。</p><h3 id="案例2鱼类生长模型">案例2：鱼类生长模型</h3><p>对鲨鱼体长-体重数据采用指数和正弦函数拟合，通过SSE选择最优模型：<span class="math display">\[\text{体长增长方程：} \quad y = 69.32e^{-0.004x} \quad (R^2 = 0.9704)\]</span></p><hr /><h2 id="六总结">六、总结</h2><ol type="1"><li><strong>适用场景</strong>：数据含噪声、需提取整体趋势、变量间关系复杂时优先选用拟合。</li><li><strong>模型选择</strong>：优先线性参数模型以利用 <spanclass="math inline">\(R^2\)</span> 评价，非线性模型直接比较SSE。</li><li><strong>工具推荐</strong>：MATLABcftool可快速实现多函数拟合与可视化。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>预测类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常值检验</title>
    <link href="/2025/05/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/2025-05-01-%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <url>/2025/05/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/2025-05-01-%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>还是碰到了异常值处理的问题，然后这里还是写篇blogs汇总一些相关的算法，我尽量全面一些吧，### <strong>1. 基于统计的方法</strong></p><h4 id="修正z-score法"><strong>（1）修正Z-Score法</strong></h4><ul><li><strong>适用场景</strong>：单变量数据，数据分布轻微偏离正态或存在少量异常值干扰时。</li><li><strong>使用方法</strong>：<ol type="1"><li>计算数据的中位数（Median）和MAD（Median Absolute Deviation）。<br /></li><li>使用修正Z-Score公式：$ = $ 。<br /></li><li>设定阈值（如 |修正Z| &gt; 3），超出视为异常值。</li></ol></li><li><strong>本质</strong>：用中位数和MAD替代均值和标准差，减少异常值对统计量的影响。<br /></li><li><strong>局限性</strong>：仅适用于单变量，对极端偏态分布可能不敏感。<br /></li><li><strong>优势</strong>：比传统Z-Score更稳健，适合处理有污染的数据。</li></ul><hr /><h4 id="grubbs检验"><strong>（2）Grubbs检验</strong></h4><ul><li><strong>适用场景</strong>：严格正态分布的单变量数据，需检测单个异常值。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>假设数据服从正态分布，计算最大值或最小值的Grubbs统计量。<br /></li><li>对比临界值表（依赖样本量和显著性水平α），判断是否拒绝原假设（无异常值）。<br /></li></ol></li><li><strong>本质</strong>：通过假设检验识别单个异常值。<br /></li><li><strong>局限性</strong>：需严格正态性假设，且只能逐个检测。<br /></li><li><strong>优势</strong>：统计学意义明确，适合科研场景。</li></ul><hr /><h3 id="基于分位数的方法"><strong>2. 基于分位数的方法</strong></h3><h4 id="iqr法箱线图法"><strong>（1）IQR法（箱线图法）</strong></h4><ul><li><strong>适用场景</strong>：任意分布的单变量数据，尤其是偏态分布。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>计算Q1（25%分位数）、Q3（75%分位数）及IQR = Q3 - Q1。<br /></li><li>设定异常值范围：$ = Q1 - 1.5 , = Q3 + 1.5 $。<br /></li></ol></li><li><strong>本质</strong>：通过分位数定义数据的“正常范围”，对尾部数据敏感度低。<br /></li><li><strong>局限性</strong>：可能遗漏多变量组合异常，阈值固定（1.5倍IQR）。<br /></li><li><strong>优势</strong>：简单高效，无需分布假设。</li></ul><hr /><h4 id="百分位数截断法"><strong>（2）百分位数截断法</strong></h4><ul><li><strong>适用场景</strong>：经验分布未知，需快速截断极端值（如金融风控）。<br /></li><li><strong>使用方法</strong>：直接去除前α%和后β%的数据（如α=1%,β=1%）。<br /></li><li><strong>本质</strong>：基于经验分位数硬截断，依赖领域知识设定阈值。<br /></li><li><strong>局限性</strong>：可能误删正常数据，阈值选择主观。<br /></li><li><strong>优势</strong>：快速直接，适用于高噪声场景。基本上就等于瞎用。</li></ul><hr /><h3 id="基于距离的方法"><strong>3. 基于距离的方法</strong></h3><h4 id="马氏距离mahalanobis-distance"><strong>（1）马氏距离（MahalanobisDistance）</strong></h4><ul><li><strong>适用场景</strong>：多变量数据，变量间存在相关性（如身高体重组合异常）。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>计算数据协方差矩阵Σ及其逆矩阵。<br /></li><li>计算每个样本的马氏距离：$ D = $ 。<br /></li><li>基于χ²分布设定阈值（如置信度95%）。<br /></li></ol></li><li><strong>本质</strong>：考虑变量相关性的广义距离，识别多维空间中的离群点。<br /></li><li><strong>局限性</strong>：依赖协方差矩阵估计，对高维数据不稳定（需样本量&gt;维度）。<br /></li><li><strong>优势</strong>：全面捕捉多变量异常。</li></ul><hr /><h4 id="k近邻k-nn距离法"><strong>（2）K近邻（K-NN）距离法</strong></h4><ul><li><strong>适用场景</strong>：非结构化数据或局部异常检测（如图像、文本）。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>计算每个点到其K个最近邻的平均距离。<br /></li><li>距离超过阈值的点视为异常。<br /></li></ol></li><li><strong>本质</strong>：通过局部密度差异识别异常，稀疏区域的点更可能异常。<br /></li><li><strong>局限性</strong>：计算复杂度高，需选择K值。<br /></li><li><strong>优势</strong>：无需分布假设，适合复杂数据结构。</li></ul><hr /><h3 id="基于密度的方法"><strong>4. 基于密度的方法</strong></h3><h4 id="局部离群因子lof"><strong>（1）局部离群因子（LOF）</strong></h4><ul><li><strong>适用场景</strong>：多变量数据，检测局部密度异常的样本（如密集区域中的稀疏点）。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>计算每个点的局部密度（K邻域内点的密度）。<br /></li><li>LOF值 = 该点密度与邻居密度的平均比值，LOF ≫1 则为异常。<br /></li></ol></li><li><strong>本质</strong>：通过相对密度判断异常，解决全局方法在局部区域的盲区。<br /></li><li><strong>局限性</strong>：计算复杂度高，对K值敏感。<br /></li><li><strong>优势</strong>：能识别“局部”异常，适合非均匀分布数据。</li></ul><hr /><h3 id="机器学习方法"><strong>5. 机器学习方法</strong></h3><h4 id="孤立森林isolation-forest"><strong>（1）孤立森林（IsolationForest）</strong></h4><ul><li><strong>适用场景</strong>：高维数据、非结构化数据（如日志、时间序列）。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>构建多棵随机树，通过随机分割特征空间隔离样本。<br /></li><li>异常值因路径较短被快速隔离，计算异常分数。<br /></li></ol></li><li><strong>本质</strong>：异常值在特征空间中更易被“孤立”。<br /></li><li><strong>局限性</strong>：对局部异常可能不敏感，需调参（树的数量、深度）。<br /></li><li><strong>优势</strong>：线性时间复杂度，适合大规模数据。</li></ul><hr /><h4 id="dbscan聚类"><strong>（2）DBSCAN聚类</strong></h4><ul><li><strong>适用场景</strong>：基于密度的聚类，自动识别噪声点作为异常值。<br /></li><li><strong>使用方法</strong>：<ol type="1"><li>设定邻域半径ε和最小样本数min_samples。<br /></li><li>无法形成核心簇的点标记为噪声（异常值）。<br /></li></ol></li><li><strong>本质</strong>：将低密度区域点视为异常。<br /></li><li><strong>局限性</strong>：对ε和min_samples敏感，高维数据效果差。<br /></li><li><strong>优势</strong>：无需预设异常值比例，适合未知分布数据。</li></ul><hr /><h3id="总结注意事项与方法选择"><strong>总结：注意事项与方法选择</strong></h3><h4 id="注意事项"><strong>注意事项</strong></h4><ol type="1"><li><strong>避免盲目删除</strong>：异常值可能是关键信号（如欺诈、设备故障），需结合业务判断。<br /></li><li><strong>多变量协同分析</strong>：单变量方法可能遗漏组合异常（如身高正常但体重极低）。<br /></li><li><strong>动态调整阈值</strong>：流数据或分布漂移时，需滚动更新统计量（如移动窗口IQR）。<br /></li><li><strong>可视化验证</strong>：箱线图、散点图矩阵、t-SNE降维图辅助决策。</li></ol><h4 id="方法选择指南"><strong>方法选择指南</strong></h4><table><thead><tr><th><strong>场景特征</strong></th><th><strong>推荐方法</strong></th></tr></thead><tbody><tr><td>单变量、近似正态分布</td><td>修正Z-Score、3σ原则</td></tr><tr><td>单变量、偏态分布</td><td>IQR法、百分位数截断</td></tr><tr><td>多变量、变量相关</td><td>马氏距离、LOF</td></tr><tr><td>高维数据、计算效率要求高</td><td>孤立森林</td></tr><tr><td>局部异常检测</td><td>LOF、K-NN距离</td></tr><tr><td>无分布假设、自动化需求</td><td>DBSCAN、百分位数截断</td></tr></tbody></table><h4 id="核心原则"><strong>核心原则</strong></h4><ul><li><strong>简单优先</strong>：单变量数据优先用IQR或Z-Score。<br /></li><li><strong>领域适配</strong>：金融风控用百分位数截断，工业检测用LOF或孤立森林。<br /></li><li><strong>交叉验证</strong>：结合统计检验（如正态性检验）和业务反馈优化阈值。</li><li><strong>简单场景</strong>：IQR（稳健）、Z-Score（正态分布）。</li><li><strong>复杂场景</strong>：LOF（局部异常）、孤立森林（高维数据）。</li><li><strong>领域结合</strong>：根据业务背景选择方法（如百分位数截断用于金融风控）。</li><li><strong>交叉验证</strong>：结合统计检验（如正态性检验）和领域知识优化策略。</li></ul><p>当然，具体应用的话还是要看你的这个题目是第几题，时间多少，能拿多少时间来做这个东西。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>数据处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网协建模分享会</title>
    <link href="/2025/04/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E7%BD%91%E5%8D%8F%E5%BB%BA%E6%A8%A1%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    <url>/2025/04/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BB%BC%E8%BF%B0%E6%A6%82%E8%A6%81/%E7%BD%91%E5%8D%8F%E5%BB%BA%E6%A8%A1%E5%88%86%E4%BA%AB%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="数学建模综述">数学建模综述</h1><p>数学建模是我个人觉得挺值得去打的一个比赛类型，主要是可以从比赛中学到论文的基本撰写流程与思路技巧、传统建模分析的基础方法（尤其是在这个机器学习横行的当下显得更为重要）、利用科学思维分析现实问题的能力（可以让自己变得更理性），功利点的话还有加综测保研考验复试的用途。我们学校的相关制度也比较成熟，三段校赛给基础模型学一遍，然后美赛国赛换着打，挺建议我们学校的大一的学弟学妹参加，正好大一上学学编程工数淑芬，大一下来打这个，挺好的。</p><p>本文就按照我的思路进行一些梳理吧。注意本人是工科生，可能会更偏重与用工科惯用套路来想，像是微分方程推导建模之类的就略过不谈了。</p><p>同时还有一点，机器学习的方法我也不讲了，一个是这个玩意很多模型都是黑箱没法解释，一个是本来这类比赛的初衷就不是机器学习，有的比赛就直接给机器学习给ban了。</p><p>本博客基于25年网协数学建模例会进行叙述（很多都是直接抄的），感谢分享人郭文涛。</p><h2 id="建模编程">建模编程</h2><p>按照这几个大类来思考模型选用。如果是入门者建议就从零开始边打边学，像毛主席讲的“从战争中学习战争”吗。</p><p>个人建议的入门路径是：参与校赛，利用CSDN/知乎/B站+SPSS验证+GPT/DeepSeek/现在流行的ai进行解释，逐步学会相关方法。</p><pre><code class=" mermaid">flowchart LR  B[AI及搜索了解可用模型]  B --&gt; C[SPSS验证方法可行性]  C --&gt; D[写代码]</code></pre><p>当然，前提是你要知道有什么方法可以选，明白几个方向的模型有什么选项、他的输入和输出是什么、主要思想是什么、适用场景和特点有哪些。</p><h3 id="优化">优化</h3><p>优化得出最大最小值。具体而言是变量+约束条件+目标函数，如果你学过神经网络的一些基本概念就会知道这个和训练时放个目标函数然后往那里学习的思路是有点像的。具体而言是我告诉你现在有哪些变量，然后我最后想要得到一个什么东西（最短路径是什么等等），然后你来给我建模得到这样一个模型。</p><p>注意事项有：</p><ul><li>线性寻路等存在最佳唯一解。</li><li>退火、遗传、粒子群为模拟结果，可能有局部最优解，最好多跑几轮。</li><li>微分差分方程一般是生物、种群的题，多轮模拟添加竞争等条件，美赛A题比较常见。</li><li>图论当时那个分享人不会，然后我也不咋会，这个东西有点太理论了。</li></ul><pre><code class=" mermaid">flowchart LR  A[优化模型] --&gt; B[数学规划]  B --&gt; B1[dp]  A --&gt; C[微分、差分方程]  C --&gt; C1[传染病模型SIR]  C --&gt; C2[Lotka-Volterra]  C --&gt; C3[Leslie种群模型]  A --&gt; D[图论与网络]  D --&gt; D1[最短路]  D --&gt; D2[网络最大流]  D --&gt; D3[旅行商问题TSP]  A --&gt; E[优化算法]  E --&gt; E1[退火算法]  E --&gt; E2[遗传算法]  E --&gt; E3[粒子群算法]</code></pre><h3 id="分类">分类</h3><p>给现有的物品分出等级，可能会伴随着大量的数据。一般不会单独出题，比如评价的时候会有这种东西的出现。</p><p>K-means和SVM、XGBoost比较重要</p><pre><code class=" mermaid">flowchart LR  A[分类模型] --&gt; B1[判别分析]  B1 --&gt; B11[距离判别法]  B1 --&gt; B12[Fisher判别法]  B1 --&gt; B13[Bayes判别法]  A --&gt; B2[聚类分析]  B2 --&gt; B21[K-means聚类]  A --&gt; B3[神经网络分类]  B3 --&gt; B22[CNN]  B3 --&gt; B23[yolo]  B3 --&gt; B31[随机森林]  B3 --&gt; B32[SVM]  B3 --&gt; B33[XGBoost]</code></pre><h3 id="评价">评价</h3><p>评价方案的好坏，给出相应的评判方法，25年校赛第一轮的B题就是这个，当时用的熵权法+TOPSIS做的就挺好，然后先用PCA筛几个变量下去，还能画点好看的热力图什么的。这类题实在不会用AHP这种纯主观的糊弄糊弄也不是不行，至少能给题做出来。</p><p>但是要注意一点，这种比较套路化的思路同质化就会比较严重，具体怎么抉择还是自己仔细想一想吧。</p><pre><code class=" mermaid">flowchart LR  A[评价模型] --&gt; B1[层次分析法（AHP）]  A --&gt; B2[灰色关联度分析]  A --&gt; B3[BP神经网络]  A --&gt; B4[数据包络法DEA]  A --&gt; B5[组合评价法]  A --&gt; B6[熵权法+TOPSIS]</code></pre><h3 id="预测">预测</h3><p>预测未来的变化</p><ul><li>输入：按照时间排布的变量</li><li>输出：按照时间排布的变量未来值</li><li>主要使用：线性回归、ARIMA</li><li>多变量：可以尝试使用LSTM，也可以非时序，给定要素做判断</li></ul><pre><code class=" mermaid">flowchart LR  A[预测模型] --&gt; B1[回归分析]  B1 --&gt; B11[线性回归]  B1 --&gt; B12[岭回归]  A --&gt; B2[时间序列分析]  B2 --&gt; B21[ARIMA]  A --&gt; B3[灰色预测]  B3 --&gt; B31[&quot;GM(1,1)&quot;]  A --&gt; B4[&quot;支持向量机 SVM&quot;]  A --&gt; B5[机器学习]  B5 --&gt; B51[BP神经网络]  B5 --&gt; B52[LSTM]  B5 --&gt; B53[GRU]  B5 --&gt; B54[随机森林]  B5 --&gt; B55[梯度提升机 GBDT]  B5 --&gt; B56[XGBoost 回归]  B5 --&gt; B57[LightGBM]  B5 --&gt; B58[SVR 回归]  A --&gt; B6[组合预测]</code></pre><h3 id="总体流程">总体流程</h3><pre><code class=" mermaid">flowchart LR  B[AI及搜索了解可用模型]  B --&gt; C[SPSS验证方法可行性]  C --&gt; D[写代码]  D --&gt; E[优化图表]  E --&gt; F[结果验证，评估]</code></pre><p>评估的话可做可不做，如果多个模型可以比较一下，或者指标好看，比如拟合的很好可以吹一下，差了就不说了。再说一遍，一定要注意要验证是否可行，避免无用功。</p><h2 id="论文部分">论文部分</h2><h3 id="文档结构">文档结构</h3><ol type="1"><li><strong>摘要</strong></li><li><strong>目录</strong></li><li><strong>问题介绍</strong><ul><li>背景</li><li>重述</li><li>分析</li></ul></li><li><strong>符号表</strong></li><li><strong>基本假设</strong></li><li><strong>模型建立与求解</strong><ul><li>一、二、三</li></ul></li><li><strong>模型评估优缺点、灵敏性分析</strong></li></ol><h3 id="主体部分">主体部分</h3><p>方法引入 + 公式 + 运用图片 + 结果</p><ul><li><strong>说清楚为啥用</strong>：哪类的模型 + 实现什么目的</li><li><strong>说清楚如何用</strong>：计算公式 + 可能的过程图</li><li><strong>说清楚用结果</strong>：使用结果图 + 误差分析</li></ul><h2 id="注意事项">注意事项</h2><ul><li>看题目位置是第几题，第一题可以稍微水一些，后面第三题就要猛猛干。</li><li>一定要注意要验证是否可行，避免无用功。</li><li>画出来的图一定要美化一些，因为实际上大家的模型都差不多，最重要的还是你的图片，要比较帅。</li><li>摘要也很重要，这个建议要建模手在最后做完的时候再改一下。</li><li>做完之后记得补充符号表</li><li>无论建模、细节完成度多少，是否完成每个任务和作图，都要按照模板填够内容，不缺漏部分</li><li>论文手第一天就要干活，写背景调研什么的</li><li>图片需要细细打磨，下面贴一张分享会的ppt</li></ul><p><imgsrc="https://raw.githubusercontent.com/vivofiftykfc/picturebd/main/img/202506222335264.png" /></p><ul><li>建模手和论文手要好好沟通</li><li>建模手要注意评估优缺点，要注意灵敏度的分析设计，这个听分享会的话要用shap？我没用过反正是</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>综述概要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相机基础知识解读</title>
    <link href="/2025/04/13/%E6%91%84%E5%BD%B1/2025-04-13-%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A7%A3%E8%AF%BB/"/>
    <url>/2025/04/13/%E6%91%84%E5%BD%B1/2025-04-13-%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1id="相机基础知识全解析从入门到精通">相机基础知识全解析：从入门到精通</h1><h2 id="前言">1.前言</h2><p>摄影不仅是一门记录生活的艺术，更是科技与创意碰撞的结晶。从最初的黑白胶片机到如今功能强大的数码相机，技术的不断革新为我们带来了无限可能。了解相机的基本构造和工作原理，是每一位摄影爱好者迈向专业的重要第一步。本文从多个层面全盘解读相机基础知识，帮助大家理解设备参数背后的原理和创作过程中如何灵活应用。（感谢ChatGPT和Deepseek的总结以及前人已有的总结）</p><h2 id="分类与认识">2.分类与认识</h2><h3 id="相机分类">2.1 相机分类</h3><ul><li><p><strong>单反相机（DSLR）：</strong></p><p>单镜头反光式照相机，这个单镜头是相对于双反来讲的，单反的这一个镜头既用来取景也用来成像。利用反光镜系统实现取景成像，具体来讲就是取景时，通过镜头入射的光线射到反光板上，然后被反光板反射到五棱镜上，再经过五棱镜的折射后，被拍摄者通过光学取景器观测到。按下快门曝光成像的时候，反光板抬起，光线直接射到感光元件上完成曝光成像。曝光结束反光板放下。具备快速响应和更强的手动操作能力，适合专业摄影师和严肃爱好者。现在逐渐被微单淘汰。</p></li><li><p><strong>无反相机（Mirrorless）：</strong></p><p>取消反光镜设计，直接用电子取景，好处就是没有反光板开闭带来的机震，体积更小、重量轻，同时保留了大部分单反相机的性能，单反有的他都有，近年来比较流行。</p></li><li><p><strong>便携式数码相机（DC）：</strong></p><p>就傻瓜相机，不能换镜头，操作简单、携带方便，适合普通人的日常记录和旅行摄影。这个时候就要提一嘴这个范畴里面的CCD了，这个玩意儿就是把普通相机的CMOS（一种图像传感器）换成CCD。不作评价，想买就买，但是出自于我个人的角度来看，CCD相机可以和泡泡玛特什么的莫名其妙的潮物坐一桌。具体可以看参考里面知乎大佬的介绍。</p></li><li><p><strong>手机相机：</strong></p><p>略。</p></li></ul><h3 id="感光元件种类">2.2 感光元件种类</h3><p>感光元件是相机的心脏，其性能直接影响图像质量。主要有两种类型：</p><ul><li><p><strong>CCD（电荷耦合器件）：</strong></p><p>电荷耦合器件（charge coupleddevice）的简称，它能够将光线变为电荷并将电荷存储及转移，也可将存储之电荷取出使电压发生变化。光电效应能使此种元件表面产生电荷，从而组成数位影像。成像效果细腻、色彩还原度高，但制造成本较高、能耗较大，实际上已经被CMOS所超越，逐渐淡出大众视野，但是最近有风潮又给他炒起来了。</p></li><li><p><strong>CMOS（互补金属氧化物半导体）：</strong></p><p>成本相对低、功耗较小，目前大部分主流相机采用此技术，同时技术进步也使得其画质不断提升。</p></li></ul><p>感光元件的尺寸（画幅）越大（如全画幅、APS-C），往往能够捕捉更多光线，从而在弱光环境下表现更优，同时动态范围和噪点控制也相对更好。</p><h3 id="画幅分类">2.3 画幅分类</h3><ul><li><p><strong>全画幅（Full Frame）：</strong></p><p>尺寸与传统35mm胶片一致（约36×24mm），成像素质顶尖，弱光噪点少、动态范围广、景深控制灵活，是专业摄影和高端视频拍摄的首选。缺点是机身和镜头体积较大，价格较高。</p></li><li><p><strong>半画幅（APS-C/残幅）：</strong></p><p>尺寸约为全画幅的一半（约23.6×15.7mm），因成本低、体积轻便，广泛用于入门级单反/无反相机。需注意镜头焦距需乘以转换系数（如1.5倍或1.6倍），适合日常拍摄、旅行及爱好者创作。画质弱于全画幅，但性价比突出。</p></li><li><p><strong>中画幅（Medium Format）：</strong></p><p>尺寸远超全画幅（如44×33mm或更大），拥有极致的分辨率、色彩深度与动态范围，专为商业广告、高端人像及艺术摄影设计。传统中画幅相机笨重昂贵，近年逐步向便携化发展（如富士GFX系列）。</p></li><li><p><strong>M4/3画幅（Micro Four Thirds）：</strong></p><p>尺寸约17.3×13mm，主打轻量化设计，机身和镜头体积小巧，适合视频拍摄、Vlog和户外机动需求（如无人机、运动相机）。画质弱于全画幅和APS-C，但视频性能优化较好。</p></li><li><p><strong>1英寸及以下（如1英寸、1/1.8"）：</strong></p><p>常见于卡片机、运动相机和智能手机，体积极致紧凑，但感光能力有限，依赖算法（多帧合成、AI降噪）提升画质。适合日常随手记录或社交媒体分享。</p></li></ul><h3 id="镜头与成像系统">2.4 镜头与成像系统</h3><p>主要关注以下几个参数：</p><ul><li><p><strong>焦距：</strong><br />焦距决定了视角和画面压缩效果。广角镜头适合风光、街拍；长焦镜头则常用于人像、野生动物摄影。</p></li><li><p><strong>光圈：</strong><br />光圈大小决定进光量和景深效果，常用的表述为f/值。较小的f值表示大光圈，能在弱光环境下获得更好的效果，同时创造柔美背景虚化。</p></li><li><p><strong>防抖技术：</strong><br />一些镜头或相机内置防抖功能，能够在低速快门情况下减小手抖影响，适用于室内或夜景拍摄。</p></li></ul><h3 id="认识按键">2.5 认识按键</h3><p>用相机还是要先明白都有什么按键的），下面的是从一篇小黑盒的帖子转来的，详细的图片就不搬运了，具体可以看原文：</p><ul><li><p><ahref="https://www.xiaoheihe.cn/app/bbs/link/148750337">【实用知识】关于相机的科普知识- 小黑盒</a></p></li><li><p><strong>基础控制区</strong></p><ul><li>电源开关：通常标记为 ON/OFF，部分相机集成在模式拨盘上。</li><li>快门按钮：半按对焦，全按拍摄（听到“滴”声表示对焦完成）。</li><li>模式拨盘：选择拍摄模式，如AUTO（全自动）、P（程序自动）、S/Tv（快门优先）、A/Av（光圈优先）、M（全手动）。</li><li>热靴接口：顶部金属槽，用于外接闪光灯或麦克风。</li></ul></li><li><p><strong>功能快捷键</strong></p><ul><li>ISO键：快速调整感光度（数值越高画面越亮，但噪点越多）。</li><li>曝光补偿键（±）：在自动模式下增减画面亮度（白加黑减原则）。</li><li>AF/MF切换键：切换自动对焦（AF）与手动对焦（MF）。</li><li>Q/Menu键：快速进入设置菜单或快捷操作界面。</li><li>方向键/拨轮：调整参数或切换对焦点。</li></ul></li><li><p><strong>其他重要按键</strong></p><ul><li>INFO/DISP：切换屏幕显示信息（直方图、水平仪等）。</li><li>删除键（垃圾桶图标）：删除照片或视频。</li><li>回放键（▶️图标）：查看已拍摄内容。</li></ul></li></ul><h3 id="认识界面与参数">2.6 认识界面与参数</h3><p>通过取景器或LCD屏幕，可以看到以下核心参数（不同机型显示略有差异）：</p><ul><li>⚡️ 闪光灯状态</li><li>📷+数字 剩余可拍摄张数</li><li>1/125 快门速度（分母越大，快门越快）</li><li>F5.6 光圈值（数值越小，光圈越大，背景虚化越强）</li><li>ISO 100 感光度</li><li>◼️▪️▪️▪️ 曝光标尺（指针居中时曝光正常）</li><li>AFS 单次自动对焦</li><li>⭕️●⭕️ 对焦点位置</li></ul><hr /><h2 id="曝光三要素">3.曝光三要素</h2><h3 id="光圈aperture">3.1 光圈（Aperture）</h3><p>光圈不仅影响进光量，还控制着景深：</p><ul><li><p><strong>大光圈（小f值）：</strong><br />允许更多光线进入，适合低光环境；同时能产生浅景深效果，使主体清晰而背景虚化。</p></li><li><p><strong>小光圈（大f值）：</strong><br />进光量减少，但景深增大，适用于风光或需要细节全景均衡的场景。</p></li></ul><h3 id="快门速度shutter-speed">3.2 快门速度（Shutter Speed）</h3><ul><li><p><strong>低速快门：</strong></p><p>曝光时间长，适合夜景、流水或者光轨拍摄，但需要三脚架支撑以防止模糊。</p></li><li><p><strong>高速快门：</strong></p><p>冻结运动效果，适合体育、野生动物等快速移动的物体，但可能导致曝光不足，拍出来一坨黑乎乎的东西。</p></li></ul><p>创意拍摄中，通过故意使用慢快门可以达到“运动模糊”效果，增加画面的动态韵律；在拍星轨的时候又是另外的路子，设置间隔多长时间拍一张，然后后期合成。</p><h3 id="iso感光度">3.3 ISO感光度</h3><ul><li><p><strong>低ISO值：</strong></p><p>噪点较少，画质好，适合光线充足场景。</p></li><li><p><strong>高ISO值：</strong></p><p>增加感光能力，适合低光环境，但噪点多。</p></li></ul><hr /><h2 id="相机测光与曝光补偿">4.相机测光与曝光补偿</h2><h3 id="测光模式">4.1 测光模式</h3><ul><li><p><strong>点测光：</strong></p><p>只测量画面中一个小区域，适用于希望突出表现主体的场景。</p></li><li><p><strong>中央重点测光：</strong></p><p>以画面中央为主，兼顾周边光线，适合大多数常规拍摄。</p></li><li><p><strong>矩阵/评价测光：</strong></p><p>分析整幅画面的光线，通过算法计算出最佳曝光值，适合一般场景使用。</p></li><li><p><strong>局部测光：</strong></p><p>对中央部分进行测光。当被摄主体位于局部位置，所占比不大且与背景反差大时用他。</p></li></ul><h3 id="曝光补偿">4.2 曝光补偿</h3><p>在自动模式下，摄像机有时无法准确捕捉复杂光线，此时可以利用曝光补偿功能：</p><ul><li><p><strong>正补偿：</strong><br />增加曝光量，用于暗部细节不足时。</p></li><li><p><strong>负补偿：</strong><br />减少曝光量，避免高光区域过曝，保留更多细节。</p></li></ul><p>理解这些设定，有助于在复杂光线环境中灵活应对，获得更准确的曝光效果。</p><hr /><h2 id="摄影模式">5.摄影模式</h2><ul><li><p><strong>M模式（全手动模式）：</strong></p><p>完全手动控制光圈、快门速度和ISO，需自行平衡曝光三角参数。适合经验丰富的摄影师应对复杂光线（如夜景、棚拍）或追求精准创作（如长曝光、星空摄影），但对操作要求高，需实时观察曝光标尺。反正不用他照样拍就行，没有必要硬要上，玩的开心就好。</p></li><li><p><strong>P模式（程序自动模式）：</strong></p><p>相机自动设定光圈和快门速度，比A档稍微多一点东西能手动。</p></li><li><p><strong>Av/A模式（光圈优先模式）：</strong></p><p>手动设定光圈值，相机自动匹配快门速度。通过控制光圈调整景深（如大光圈虚化背景、小光圈扩展景深），适合人像、风光、静物等需突出画面层次感的题材。</p></li><li><p><strong>Tv/S模式（快门优先模式）：</strong></p><p>手动设定快门速度，相机自动匹配光圈值。通过控制快门速度冻结动态（高速快门）或营造动感模糊（低速快门），适合运动、车流、流水等场景。</p></li><li><p><strong>Auto模式（全自动模式）：</strong></p><p>相机完全接管所有参数（包括闪光灯），用户仅需构图和按下快门。适合紧急抓拍或纯新手入门，但创作自由度极低，易受算法误判影响。</p></li><li><p><strong>B门模式（Bulb Mode）：</strong></p><p>手动控制快门开启时间（按下快门开始曝光，松开结束），适用于超长曝光（如星轨、光绘、烟花）。需搭配三脚架和快门线，避免机身抖动。</p></li><li><p><strong>场景模式（如人像、风景、夜景）：</strong></p><p>相机根据预设场景优化参数组合（如人像模式自动开大光圈、夜景模式提升ISO），适合特定题材快速拍摄，但灵活性弱于半自动模式（P/Av/Tv）。</p></li></ul><p>模式本质是“参数控制权”的分配，从Auto到M模式，用户逐步接管更多参数控制权，代价是操作复杂度提升，但创作空间同步扩大。</p><hr /><h2 id="白平衡与色彩管理">6.白平衡与色彩管理</h2><p>白平衡的基本概念是:“不管在任何光源下，都能将白色物体还原为白色”能在不同色温的光线下尽量的还原白色为白色。</p><p>一般情况下用自动白平衡即可。光线复杂时或对照片色调有特定效果需求时，可以通过设置不同的K值影响色调。比如偏暖或偏冷的色调选择。</p><ul><li>K值数字越小→越蓝（冷色调）→ 适合拍雪景、冰雕；</li><li>K值数字越大→越黄（暖色调）→ 适合咖啡馆、烛光晚餐。 ### 6.1白平衡基础</li></ul><p>白平衡主要用于校正不同光源下的色温差异：</p><ul><li><p><strong>自动白平衡（AWB）：</strong></p><p>相机会根据环境自动判断色温，但在复杂光源下可能出现偏色。</p></li><li><p><strong>手动设置：</strong></p><p>根据现场光源（如日光、钨丝灯、荧光灯等）进行手动调节，确保画面色彩准确。</p></li></ul><p>实际上这个玩意没必要，直接拍<strong>RAW</strong>甩给后期修就是了。</p><hr /><h2 id="对焦系统与焦点控制">7.对焦系统与焦点控制</h2><p><strong>1. 手动对焦（MF）</strong>：自己拧</p><ul><li><p><strong>啥时候用</strong>：</p><ul><li>拍微距（比如小虫子、花瓣细节）；</li><li>晚上拍星星或者光线特别暗；</li><li>自动对焦总对不上（比如拍笼子里的动物、隔着玻璃）。</li></ul></li><li><p><strong>缺点</strong>：慢，得自己拧镜头环，新手容易手抖糊片。</p></li></ul><p><strong>2.单次自动对焦（AF-S）</strong>：半按快门对焦一次，适合不动的东西。</p><ul><li><p><strong>啥时候用</strong>：</p><ul><li>拍风景、证件照、静物摆拍；</li><li>先对焦再平移构图（比如先对焦人脸，再把人物放画面左边）。</li><li>不是很适合拿来拍跑来跑去的小孩、宠物、体育比赛。</li></ul></li></ul><p><strong>3.连续自动对焦（AF-C）</strong>：选好模式按住连拍，抓拍会动的东西。</p><ul><li><p><strong>啥时候用</strong>：</p><ul><li>半按快门时焦点会跟着主体移动（比如拍跑步的人、飞鸟、汽车）；</li><li>连拍好用。</li></ul></li><li><p><strong>注意</strong>：背景太乱可能跟丢焦点，尽量选干净背景。</p></li></ul><p><strong>4.全自动对焦（AF-A）</strong>：会自己切换AF-S/AF-C（比如先对焦静止的人，突然他开始跑步，焦点自动跟上）。</p><hr /><h2 id="保存格式与色彩空间">8.保存格式与色彩空间</h2><ul><li><p><strong>RAW格式</strong>：未经压缩的原始数据文件（类似底片），完整记录感光元件捕捉的全部信息（包括未处理的色彩、动态范围和细节）。</p><ul><li><p><strong>优势</strong>：</p><ul><li>保留最大后期调整空间（可无损修正曝光、白平衡、色彩偏差等）；<br /></li><li>高动态范围减少高光过曝或暗部死黑风险；<br /></li><li>适合专业摄影、商业拍摄或需精细修图的场景。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>文件体积大，存储和传输成本高；<br /></li><li>需专用软件（如Lightroom、Capture One）处理，无法直接分享；<br /></li><li>直出效果较平淡，依赖后期技术。</li></ul></li></ul></li><li><p><strong>JPEG格式</strong>：经过相机机内压缩处理的图像文件，直接生成可分享的成品图。</p><ul><li><p><strong>优势</strong>：</p><ul><li>文件体积小，兼容性强（手机、电脑无需解码）；<br /></li><li>机内算法优化直出色彩（如人像肤色、风光饱和度）；<br /></li><li>适合快速出片、社交媒体分享或非专业需求。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>压缩损失细节，动态范围和色彩信息不可逆；<br /></li><li>后期调整空间极小（易出现色阶断裂或噪点）。</li></ul></li></ul></li></ul><p>反正拍照就是RAW就是了，JPEG是你后面修完输出的。色彩空间的话直接上sRGB。具体色彩空间和显示器那篇的色域有点像，可以去看看</p><hr /><p><em>【参考资料】</em><br /><a href="https://www.zhihu.com/question/601483588">销声匿迹十多年的 CCD相机为什么又火起来了，真的值得购买吗？ - 知乎</a>https://www.zhihu.com/tardis/zm/art/98369864?source_id=1005https://zhuanlan.zhihu.com/p/93835471https://www.zhihu.com/tardis/bd/art/397181356https://www.xiaoheihe.cn/app/bbs/link/148750337</p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摄影基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四月是你的谎言</title>
    <link href="/2025/04/11/%E7%95%AA%E5%89%A7%E9%89%B4%E8%B5%8F/%E7%95%AA%E5%89%A7/2025-04-11-%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84%E8%B0%8E%E8%A8%80/"/>
    <url>/2025/04/11/%E7%95%AA%E5%89%A7%E9%89%B4%E8%B5%8F/%E7%95%AA%E5%89%A7/2025-04-11-%E5%9B%9B%E6%9C%88%E6%98%AF%E4%BD%A0%E7%9A%84%E8%B0%8E%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="四月是你的谎言-光影组节目">四月是你的谎言 光影组节目</h1><p>——能与你相遇的四月，就要来了。没有你的四月，就要来了。</p><p>在此再次感谢本次节目的搭档，是她向我推荐了这部番，同时也是她与我合作完成了这篇文稿和这次的播报（实际上更多的是她作为前辈带我这个新人呢呜呜），她为这次节目所作出的贡献远远大于我。</p><h2 id="剧段一">剧段一：</h2><p>来源：<ahref="https://www.bilibili.com/video/BV1ns411y72A/?spm_id_from=333.1391.0.0">四月是你的谎言（中配）</a></p><p>公生：口风琴？吹得还不错。（语气略带疑问，两句之间留停顿）</p><p>小椿：（背景音，后期可以做音效）美和和我说，和他相遇的瞬间，我的人生就改变了（带笑意，最后一句渐弱）。所见所闻所感，目之所及全部开始变得五彩斑斓起来（目之所及处停顿，后半句加强）全世界，都开始发光发亮（后半句加强）</p><p>（口琴声延续…）</p><h2 id="常规节目">常规节目：</h2><p>大家好，欢迎收听今天的北理之声-光影年代，我是主播张恒玮，我是主播王奕茹（介绍词）在动漫市场轻小说漫改横行，快餐式剧集频发的当下，有一部上映了十一年的动画，至今仍占据日网票选催泪动漫第二的好成绩，同时也成为了无数人心中入坑必看的神作的代表。即使上映了十多年的时间，直到今年四月，仍有不少人以自己的方式来纪念这部影片。||如果你也对纯爱类型的题材感兴趣，为这样一部口碑经典的动漫好奇的话，也许《四月是你的谎言》正是符合你期待的那部作品。在今天的光影年代节目中，让我们走进那个樱花飘落的四月，聆听《四月是你的谎言》这部作品中，音乐与爱的交响曲。</p><p>这个围绕着音乐与爱的故事，还要从一个不期而然的偶遇讲起。动漫的主人公有马公生自小就在母亲严格的教导之下学习钢琴，在大大小小的钢琴比赛中，屡次斩获冠军头衔。作为当之无愧的天才钢琴少年，几乎在所有人眼中，公生都与钢琴界冉冉升起的新星这一名号紧密相关。但未曾想，一场突如其来的变故，却断送了人们的美好愿景，打破了公生一直以来的钢琴梦想。一直教导严苛，不苟言笑的母亲，在癌症的肆虐下猝然离世；面对母亲身上突发的噩耗，伴随着无尽的悲伤，公生因此再也无法听见琴声，生活也变得晦暗无光。不过，一场突如其来的偶遇，却彻底改变了公生晦暗的生活，在一次偶然的机会下，等待好友的公生与樱花树下吹响手风琴的宫园薰不期而遇，公生被自由奔放的小提琴手薰所吸引，在误打误撞中，两人也成为了朋友。然而，薰阳光开朗的外表下却隐藏着不为人知的阴影，作为优秀的小提琴手。薰自小学习小提琴的动力，便是与作为天才的有马公生合奏。为此，薰以“喜欢共同的好友”的谎言编织相遇，隐藏下自己身患绝症的残酷命运，只为完成自小以来的合奏约定。然而，这场不期而至的相遇，不仅给公生仅剩下单调黑白键的世界重新填入乐章，也让薰的流星般璀璨的生命在倒计时中绽放出最炽热的光芒。在生命仅剩的时光里，薰用自己的音乐与爱，让公生得以明白，对于他而言音乐并不是束缚，而是与世界对话的语言，也教会了公生如何面对失去。最终，他在宫园薰离去的春天里，奏响了属于两人的永恒乐章。</p><h2 id="剧段二">剧段二：</h2><p>来源：<ahref="https://www.bilibili.com/video/BV1UG4y1w737/?spm_id_from=333.1391.0.0&amp;p=2&amp;vd_source=35efa20a3dc2d6382913a782f2bf8ad8">四谎_2_哔哩哔哩_bilibili</a></p><p>熏：你还在弹钢琴吗？</p><p>公生：已经不弹了</p><p>果然。你又在一个人消沉了。</p><p>公生：已经不行了，重要的人全都从我眼前离开，音乐把我真实的人都给带走了，最后只剩我孤身一人。</p><p>熏：不是还有我吗？有马，我要做手术了，在2月18号。我会拼尽全力的一直挣扎到最后一刻。都怪你，全部都是你的错。我像这样难堪的挣扎着，向着生的希望追逐着都是你的错，因为与你共度的时光让我产生了留恋，你不再拼一下吗？我们不是最擅长拼命了吗？我们不就是拼上性命去挣扎的演奏家吗？</p><p>公生：但是我已经一周没碰钢琴了。</p><p>熏：你给我伴奏的时候不也没碰钢琴吗。</p><p>公生：那时候因为打工偶尔也碰过，现在不可能弹得好的，这种状态还能弹才是奇迹了……</p><p>熏：又在低头看下面了。</p><p>（熏演奏小提琴）</p><p>熏：看奇迹什么的，这不就有了吗？</p><h2 id="常规节目-1">常规节目：</h2><p>作为日本动漫的经典之作，《四月是你的谎言》不仅是一部青春物语，更是一部音乐番，一部以音乐为血肉的经典之作。从第一集贝多芬的《月光》奏鸣曲到最后一集肖邦的《G小调第一叙事曲》，从主角二人初次合奏的圣-桑的《引子与回旋随想曲》到二人终究没有共同完成的克莱斯勒的《爱的忧伤》，剧中每一段古典乐都与剧情精准契合，成为了情感流淌的桥梁。是公生在《革命练习曲》的激流中挣脱母亲阴影，亦是在薰从《引子与回旋随想曲》的狂放中诠释生命的最后燃烧之时，音符与剧情早已融为一体，形成一种近乎宿命般的共振。</p><p>影片将音乐与剧情相伴相生，远远超越了单纯的“将音乐作为背景”，用音符为砖瓦构建出一座永远处于四月的城池。正如剧中薰所说：“音乐是自由的啊！”创作者正是将这种自由与古典乐的庄重交织，为易逝的青春编排出一部盛大的音乐会。而当在十年后仍能从很多人口中听到这场反复被演绎的音乐会的消息，便知这场四月的音乐会，早已铭刻在众人心中，达到永恒。</p><p>朱光潜有这样一句话：表面看来，悲剧的内容大多是可怖的东西，但它实际上绝不仅止于此。悲剧绝不仅仅是恐怖。恐怖只是使人感到痛苦，最后给人以阴郁和沮丧的感觉，而悲剧却令人感到鼓舞和振奋。而《四月是你的谎言》恰恰也是贯彻了这一理念的佳作，以在四月发生的悲剧为基底，却又迸发出惊人的生命力，催人成长，催人前进。</p><p>剧情上的所谓“谎言”，是指少女在生命进入倒计时后为拯救爱人而编织的最美丽的谎。宫园薰以”喜欢渡“的谎言来到曾经的天才少年公生的身边，叩响公生的心门，帮助公生战胜心魔。作者用这个看似轻巧俗套的套路，对日本物哀美学做出了精妙的诠释。正如《源氏物语》中所述夕颜花朝开而夕逝，薰所用的这个温柔的“谎言”背后却是无尽的哀伤。她选择在生命最后用谎言搭建相遇的桥梁，只为在消逝前用自己最后的生命活力拯救心上的天才演奏家，恰似樱花在盛放瞬间便预设了飘零的轨迹。这种倒计时叙事带来的张力，使每个温馨场景都笼罩着倒影般的哀愁，形成极具东方特质的悲剧审美空间。</p><p>正如所有在四月盛开的樱花都终归化为尘土，正如每一场演出都终归要结束，为公生带来希望与活力的薰最终还是倒在了那个樱花盛开的四月前，这一结局则揭示了生命"向死而生"的存在主义本质：所有看似永恒的美好，本质都是死神的缓刑令。这种对生命无意义的认识本应导向虚无，但在这部作品中，作者却借剧中人物对音乐的执念与热爱完成由虚无向存在的转折：薰在生命的最后仍然为了能与心爱的人同台演出而去进行最后的挣扎；有马最后在母亲爱人均离自己远去时仍怀揣着对生活的希望继续为世界弹奏巴赫与肖邦，这些认真生活的片段则构成了对荒诞世界的蔑视。正如加缪笔下的西西弗斯，明知巨石必将滚落仍坚持攀登，这是他对自己命运的蔑视；正如薰在那个最后的四月里笑着说“就算悲伤难抑，遍体鳞伤地处于谷底，也不能停下演奏。只有这样，我们才是真正活着的。”这是她对自己绝症的蔑视。至此我们才恍然：生命用存在的假象掩盖消逝的本质，而人类却在明知结局的清醒中，依然选择热烈地活着。正如罗曼·罗兰所说：“所谓英雄主义，不过是在看清生活真相后仍然热爱生活。”是啊，生命最壮烈的英雄主义，不在于规避消逝的必然，而在于将终局预设为盛放的华章。即使明日我将逝去，今日我仍会打好领带去迎接最后的晚霞与朝阳！</p><p>十年后的今日，日本的樱花前线依然以17公里每日的速度北移，樱花花瓣又以五厘米的秒速向下飘落，东京塔上又泛起粉色的光晕，而当现实中的赏樱者仰头凝视枝头这转瞬即逝的繁华，伸手接住以每秒五厘米的速度飘落的花瓣时，我想，他们也许不知道，樱花中还凝结有那首十年前的G小调第一叙事曲，也许不知道，樱花中曾蕴含着那位少女所演奏的小提琴的泛音。但也许，正如人们所知晓的那样，樱花最美之处，便是其坠落时的满天花雨——这也与熏留给世界的最后一个谎言不期而合：明明写着的是“永别”，但读出的却是“我在未来等你”。</p><p>能与你相遇的四月，就要来了。没有你的四月，就要来了。</p><h2 id="结束曲">结束曲：</h2><p>光るなら</p>]]></content>
    
    
    <categories>
      
      <category>番剧鉴赏</category>
      
      <category>番剧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>番剧鉴赏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批处理文件（.bat）入门</title>
    <link href="/2025/04/07/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-04-07-%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6-.bat/"/>
    <url>/2025/04/07/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-04-07-%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6-.bat/</url>
    
    <content type="html"><![CDATA[<h1 id="批处理文件.bat介绍">批处理文件（.bat）介绍</h1><p>批处理文件（Batch File，扩展名 <code>.bat</code>）是 Windows系统中的一种脚本文件，用于自动执行一系列命令。通过编写 <code>.bat</code>文件，可以轻松实现任务自动化、系统管理及文件操作等功能。</p><h2 id="如何编写和使用-.bat-文件">如何编写和使用 .bat 文件</h2><h3 id="编写">编写</h3><p>使用记事本或其他文本编辑器创建一个新文件，输入所需的命令和脚本逻辑，最后保存后修改后缀名即可</p><h3 id="使用">使用</h3><ul><li>双击 <code>.bat</code> 文件直接运行。</li><li>或在命令提示符下输入文件路径执行。</li><li>可结合 Windows 任务计划程序实现定时自动运行。</li></ul><h2 id="常用语法">常用语法</h2><ul><li><strong>注释：</strong> 用于说明脚本，不参与执行。</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-comment">REM 这是一个注释</span><br>:: 这也是注释<br></code></pre></td></tr></table></figure><ul><li><p><strong>关闭命令回显：</strong> 防止在命令执行时显示命令内容。<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br></code></pre></td></tr></table></figure></p></li><li><p><strong>输出信息：</strong> 用于在屏幕上显示文本。</p><p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">echo</span> Hello, World!<br></code></pre></td></tr></table></figure></p></li><li><p><strong>暂停脚本：</strong> 等待用户按任意键继续执行。</p><p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>条件判断：</strong> 根据条件执行不同命令。</p><p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-keyword">if</span> <span class="hljs-keyword">exist</span> &quot;file.txt&quot; (<br>    <span class="hljs-built_in">echo</span> 文件存在<br>) <span class="hljs-keyword">else</span> (<br>    <span class="hljs-built_in">echo</span> 文件不存在<br>)<br></code></pre></td></tr></table></figure></p></li><li><p><strong>循环处理：</strong> 遍历文件或变量列表。</p><p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-keyword">for</span> <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (*.txt) <span class="hljs-keyword">do</span> (<br>    <span class="hljs-built_in">echo</span> 找到文件：<span class="hljs-variable">%%i</span><br>)<br></code></pre></td></tr></table></figure></p></li><li><p><strong>变量使用：</strong> 设置并引用变量，也可通过<code>%1</code>, <code>%2</code> 接收命令行参数。</p><p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-built_in">set</span> name=World<br><span class="hljs-built_in">echo</span> Hello, <span class="hljs-variable">%name%</span>!<br></code></pre></td></tr></table></figure></p></li><li><p><strong>跳转标签：</strong> 使用 <code>goto</code>实现脚本流程控制（模拟函数）。</p><p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-keyword">goto</span> :myLabel<br>:myLabel<br><span class="hljs-built_in">echo</span> 这是跳转到标签的示例<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="代码示例">代码示例</h2><p>以下示例展示了如何检查文件是否存在，并输出相应信息：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span> 检查文件是否存在...<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">exist</span> &quot;test.txt&quot; (<br>    <span class="hljs-built_in">echo</span> 文件 test.txt 存在!<br>) <span class="hljs-keyword">else</span> (<br>    <span class="hljs-built_in">echo</span> 文件 test.txt 不存在!<br>)<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><h2 id="其他注意事项">其他注意事项</h2><ul><li><p><strong>调试：</strong> 在脚本中加入 <code>pause</code>方便查看执行结果和逐步调试。</p></li><li><p><strong>环境兼容：</strong> 批处理文件专用于 Windows环境，其他系统（如 Linux）通常使用 Shell脚本（<code>.sh</code>）。</p></li><li><p><strong>安全性：</strong>避免在脚本中存储敏感信息，谨慎使用删除、格式化等危险命令。</p></li><li><p><strong>扩展应用：</strong> 批处理文件可以与 PowerShell脚本、VBScript 等其他自动化工具结合，处理更复杂的任务。</p></li></ul><hr /><p>参考资料：<br /><a href="https://cn.windows-office.net/?p=22398">Windows Office批处理文件介绍</a><br /><a href="https://blog.csdn.net/csfchh/article/details/106795352">CSDN批处理文件教程</a><br /><a href="https://baike.baidu.com/item/bat/365230">百度百科 - bat</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾的小杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Fluid+Obsidian博客搭建及优化</title>
    <link href="/2025/04/07/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-04-07-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2025/04/07/%E6%8A%98%E8%85%BE%E6%9D%82%E9%A1%B9/2025-04-07-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">1.前言</h2><p>搭建这个博客的契机实际上是前段时间和一个学长吃饭的时候看到他自己建的个人博客，我之前也知道现存的相关开源项目十分成熟，然后就是脑瓜一拍开始干（bushi</p><p>这倒也算是解决了一直以来的没地方分享东西的问题。我是很想多去写点东西来记录折腾的有趣的各种小东西，记录自己欣赏过的艺术作品，记录自己的生活想法与感受的，很想在现在还有时间的时候多去写点长篇的文章来保护我自己的思考能力和语言表达能力，防止在短视频风暴中迷失自我。但是在哪里写这又是一个问题：发贴吧知乎小红书吧，一个是目前这些论坛的氛围个人不是很喜欢，也懒得天天去迎合氛围去叠甲；发空间或者朋友圈吧，这俩地方又不适合做长篇大论，一段小文字又满足不了我的表达欲，也讲不清楚我想说什么，而且我的微信好友也不一定愿意看；做视频发出来就更不用讲了，耗时间还要考虑社群氛围问题。</p><p>而个人博客的方案则很好的满足了我这个需求：我可以在自己的个人博客上随便说随便讲，述我之所想，录我之欲记，毕竟我这算是写给自己看的，也基本上没人来我这看这些文章；一方面这也算是一个有趣的小项目不是嘛？虽然用的是开源项目，但不妨碍我顺便就给前端的那一套东西给了解一下。</p><p>前言的最后一段还是献给可能来的读者吧，如果你也想搭建一个这样的个人博客，不妨阅读下去，我将会在这里写一些搭建的过程和个人推荐的写作工作流。</p><h2 id="搭建">2.搭建</h2><h3 id="所用到的工具">所用到的工具：</h3><ul><li><ahref="https://hexo.io/zh-cn/docs/">hexo</a>：博客框架，可以理解为blogs网站的骨架。</li><li><ahref="https://hexo.fluid-dev.com/docs/start/">Fluid</a>：blogs网站的主题，具体的配置按照这个官方文档讲的改就是了，文档十分详细，不再赘述。</li><li><ahref="https://docs.github.com/zh/pages/getting-started-with-github-pages">GithubPages</a>：静态网站托管服务，免费且方便，一个github账号只能有一个。</li><li><ahref="https://docs.github.com/zh/pages/getting-started-with-github-pages">Obsidian</a>：一个文本编辑器，配置好的话十分方便，插件丰富，可以完成模板导入，目录结构文件夹化等任务。</li><li><ahref="https://typoraio.cn/">Typora</a>：写markdown文件的轻量级编辑器，比自带的记事本多个渲染和快捷键的事儿。</li></ul><h3 id="安装">安装</h3><h4 id="前置依赖">前置依赖</h4><ul><li><ahref="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Node-js">Node.js</a>：是一个可以执行JavaScript 代码的软件程序。更准确地说，Node.js 是一个 JavaScript运行环境。</li><li><ahref="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Git">Git</a>：著名的开源分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Github的Git就是他，可以理解为你的管理文件版本的管家，支持各版本保存、回滚、上传。</li></ul><h4 id="hexo安装">Hexo安装</h4><p>这里的步骤都要在git-bash命令行中做，路径为你要放博客的文件夹下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局安装 Hexo 命令行工具（CLI）</span><br><span class="hljs-comment"># -g 表示全局安装，安装后可在任何目录使用 hexo 命令</span><br><span class="hljs-comment"># 需要提前安装 Node.js 和 npm（Node.js 包管理器）</span><br>npm install -g hexo-cli<br><br><span class="hljs-comment"># 验证 Hexo 是否安装成功，显示 Hexo 及其相关依赖的版本号</span><br><span class="hljs-comment"># 如果正常显示版本信息，说明环境配置正确</span><br>hexo -v<br><br><span class="hljs-comment"># 初始化一个新的 Hexo 项目到当前目录下的 my-blog 文件夹</span><br><span class="hljs-comment"># 该命令会创建项目目录结构并自动下载默认主题 landscape</span><br>hexo init my-blog<br><br><span class="hljs-comment"># 进入项目目录（后续操作都需要在此目录下执行）</span><br><span class="hljs-built_in">cd</span> my-blog<br><br><span class="hljs-comment"># 安装项目所需的本地依赖包</span><br><span class="hljs-comment"># 会读取 package.json 中的依赖项，安装到 node_modules 目录</span><br><span class="hljs-comment"># 这些依赖包括 hexo-server, hexo-deployer-git 等核心模块</span><br>npm install<br><br><span class="hljs-comment"># 生成静态网站文件（编译 Markdown 为 HTML）</span><br><span class="hljs-comment"># 生成的静态文件会保存在 public 目录中</span><br><span class="hljs-comment"># 每次内容更新后都需要重新生成</span><br>hexo g <span class="hljs-comment"># 完整命令是 hexo generate</span><br><br><span class="hljs-comment"># 启动本地开发服务器（默认端口 4000）</span><br><span class="hljs-comment"># 访问 http://localhost:4000 可以预览网站</span><br><span class="hljs-comment"># 支持热更新，修改内容后会自动刷新（但修改配置文件后需要重启服务）</span><br>hexo s <span class="hljs-comment"># 完整命令是 hexo server</span><br></code></pre></td></tr></table></figure><p>之后就能在本机的 http://localhost:4000 预览网站了。</p><h3 id="更换主题">更换主题</h3><p>本站所用的是Fluid：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#具体配置可以参考官方文档(https://hexo.fluid-dev.com/docs/)，写的很详细。</span><br>npm install --save hexo-theme-fluid<br><br><span class="hljs-comment">#安装好后可以在本机4000端口查看效果</span><br>hexo clean <span class="hljs-comment"># 清除已生成的静态网页文件  </span><br>hexo g <span class="hljs-comment"># 重新生成  </span><br>hexo s <span class="hljs-comment"># 本地启动</span><br><br><span class="hljs-comment">#如果git已经配置好可以直接上传</span><br>hexo d <span class="hljs-comment">#上传到你配置好的github托管服务器上，然后可以通过网页来查看，具体公网域名就不用管了，这玩意就已经可以在公网上浏览了。</span><br></code></pre></td></tr></table></figure><h2 id="写作">3.写作</h2><p>本人刚开始用的还是typora，但是每次插入图片，配置笔记属性啥的都要手动做，简直是敲代码届的耻辱好吧，于是就转向Obsidian来写blogs了，这篇文章也算是第一篇用Obsidian来写的。</p><p>首先是安装Obsidian，这个不说了直接看官方网站和相关文章：</p><ul><li><a href="https://help.obsidian.md/">Home - Obsidian Help</a></li><li><a href="https://forum-zh.obsidian.md/">Obsidian 中文论坛 - Obsidian知识管理 笔记</a></li></ul><p>你要是连markdown也不会写的话，那就先学markdown，挺好使的，你要是信息类行业少不了这个：</p><ul><li><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 |Markdown 教程</a></li></ul><p>具体的可以语法与快捷键结合。</p><h2 id="发布">4.发布</h2><p>先配置一下<code>hexo-deployer-git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>改一下<code>_config.yml</code>文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>  <br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <br><span class="hljs-attr">repo:</span> <span class="hljs-string">&lt;repository</span> <span class="hljs-string">url&gt;</span> <span class="hljs-comment"># https://github.com/&lt;GitHub用户名&gt;/&lt;GitHub用户名&gt;.github.io.git  </span><br><span class="hljs-attr">branch:</span> [<span class="hljs-string">branch</span>]  <br><span class="hljs-attr">token:</span> [<span class="hljs-string">token</span>]<br></code></pre></td></tr></table></figure><h2 id="工作流暂时">5.工作流（暂时）</h2><ul><li>使用new指令新建一篇博客</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new &lt;文章名&gt;<br></code></pre></td></tr></table></figure><ul><li>打开obsidian开始写作</li><li>写作完了之后，终端本地预览</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g  <br>hexo s<br></code></pre></td></tr></table></figure><ul><li>预览没问题之后，发布</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h2 id="优化">6.优化</h2><h3 id="分类树文件夹化自动分类">分类树文件夹化（自动分类）</h3><p>不可否认的是是项目就没有完美的，像是上述介绍的这套流程个人用上去还是有些很不顺的点，比如分类页的话，本来这个按照逻辑的话在本地写博客就应该是按照文件夹的包容关系来分，但是他原生的分类要在每篇博客前面的文件属性里面这样写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo简介</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2008-08-08</span><br><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">web开发</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">前端</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">博客框架</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>这玩意让我咋管理？你的意思是我要记住每个文件是在那个目录树下？一个字都不能错？这不是给自己找事吗？本来分类就是为了便于管理，这不是本末倒置了吗</p><p>于是就去找，发现了个开源项目：</p><ul><li><ahref="https://github.com/xu-song/hexo-auto-category?tab=readme-ov-file">xu-song/hexo-auto-category:Generate categories automatically for each post in Hexo</a></li></ul><p>按照他<ahref="https://blog.eson.org/pub/e2f6e239/">官方文档</a>进行安装配置就行。有一点要注意的是如果存在文件没有分类组的话会发生一些奇妙的事情（好像）。</p><h3 id="git自动推送">Git自动推送</h3><p>在写完前几篇博客后我每次都要手动到git的bash下<code>hexo clean``hexo g``hexo d</code>一遍，很麻烦，然后就是想到为什么不能直接上自动化插件：</p><p>具体做法的原文档来源于：</p><ul><li><ahref="https://zhuanlan.zhihu.com/p/554333805">Obsidian+Git完美维护Hexo博客- 知乎</a></li></ul><h3 id="导入模板">导入模板</h3><p>obsidian原生支持模板功能，直接在设置里面配置一下路径，写个模板文件就行了</p><h2 id="后记">7.后记</h2><p>本网站对写博客时图片的插入还需要进一步的优化，详情可见这位大佬的博客，本文很多都是从他那来的：</p><ul><li><ahref="https://sagi-rastar.github.io/2023/11/10/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BD%BF%E7%94%A8obsidian%E5%8A%A0hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/#3-1-1-4-%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%AE%BE%E7%BD%AE">关于我使用obsidian加hexo部署个人博客的过程- SagiRastar's Blog</a></li><li><ahref="https://coffeelize.top/posts/Obsidian-to-Hexo.html">Obsidian2Hexo| 智朋的个人博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>折腾的小杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>显示器参数及相关知识解读</title>
    <link href="/2025/04/06/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6/%E6%A6%82%E5%BF%B5%E9%98%90%E8%BF%B0/2025-04-05-%E6%98%BE%E7%A4%BA%E5%99%A8%E5%8F%82%E6%95%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A7%A3%E8%AF%BB/"/>
    <url>/2025/04/06/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6/%E6%A6%82%E5%BF%B5%E9%98%90%E8%BF%B0/2025-04-05-%E6%98%BE%E7%A4%BA%E5%99%A8%E5%8F%82%E6%95%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="显示器相关参数与相关原理解读">显示器相关参数与相关原理解读</h1><p>最近买了个副屏，顺便写个文章整一下相关知识方便选购。</p><h2 id="彩色显示器原理">彩色显示器原理</h2><h3 id="前置知识">前置知识</h3><ul><li>液晶材料：一种合成的有机化合物，处于固态与液态之间，不通电时内部分子排列混乱不透光，通电时分子排列有秩序透光，当然也有相反的情况，通电不透光不通电透光。</li><li>光的偏振：光的偏振是横波振动方向的空间选择，通过偏振片的调控与检测光强变化，我们可以验证其横波特性及振动方向选择性。具体详见高中物理书。</li></ul><h3 id="主要思想">主要思想</h3><p>控制RGB值来混合出彩色出来。</p><h3 id="技术路线">技术路线</h3><h4 id="lcd">LCD</h4><h5 id="普通lcd">普通LCD</h5><p>这种还是比较主流也比较老的，最下面是一层背光层，发白光，底光层上面蒙上一层具体就是在那种相互垂直的两个偏振片中间加上一个液晶层，利用液晶对光的偏转能力来控制其光的偏转量，进而控制亮度。而彩色的话就在液晶层外加上彩色滤光片就行。普通的背光板就是反光板匀光板中间夹一层led灯带。当然在显示器打开的情况下显示黑屏的话，因为底光已经开了，同时液晶层在不通电的时候实际上也会对光有一部分偏转，故与不通电的纯黑色有区别，同时也会造成对比度的损失。</p><p>具体可以根据液晶层的默认状态分为下面三种：</p><ul><li>VA默认垂直，加电呈垂直螺旋状偏转透光，对比度高，可视角度一般，响应较慢，有些劣质的板子可能会有拖影，适合电影和3A用户。</li><li>IPS默认水平，加压水平平行偏转透光，对比度一般，可视角度广，响应适中，算是水桶板子，适合大多数场景。</li><li>TN默认水平螺旋偏转，加压垂直偏转不透光，对比度低，可视角度差，但是响应快，适合go学长瓦学弟。</li></ul><h5 id="qled">QLED</h5><p>这个是把LCD的基础上改进背光为蓝色，然后使用量子点涂料（量子点是一种极为微小的化合物，收蓝光之后会发射波长不同的光线，有点电子激发再回落基态的味道了）刷在基板上，解决的是普通LCD饱和度不行的问题，实际上还是归属于LCD。</p><h5 id="mini-led">mini-LED</h5><p>将背光板换成分块，在黑色区域直接关背光，其他和LCD一样，有利于高阶HDR的实现，但是有会出现调教不好有拖影或者光晕的问题。</p><h4 id="led">LED</h4><h5 id="oled">OLED</h5><p>有机发光二极管（Organic Light EmittingDiode），传统二极管好是好，但是每个像素上三个二极管，再集成为一块大屏幕就难以做到，于是就有了这个东西。用的是直接给荧光材料通电来实现发有颜色的光，三个集成就是一个像素。也可以看作像素级别的分区背光，无光晕且饱和度高，厚度薄，响应快，色域广，没背光功耗小，有柔性。缺点就是因为三种荧光材料寿命不同，容易烧屏（色彩残留，有色差），亮度峰值低，PWM调光、等效分辨率下降的问题。</p><h5 id="w-oled">W-OLED</h5><p>将三种荧光材料换成白色荧光材料，上面盖上RGBW偏振片（红绿蓝加上一个白），其中W是为了弥补亮度，但是W又对红绿蓝像素产生了白色光干扰，又回到了LCD的问题上了。</p><h5 id="qd-oled">QD-OLED</h5><p>将QLED里面的背光换成了蓝色荧光物质，还是属于LED里面，解决的是W-OLED的问题，但是量子点材料可能被外界光激发污染信号。</p><h5 id="micro-oled">micro-OLED</h5><p>微型的发光二极管，就是解决了传统每个像素上三个二极管，再集成为一块大屏幕就难以做到的问题，但是因为巨量转移技术不成熟所导致的价格贵，一块几十万。</p><h2 id="参数">参数</h2><h3 id="屏幕尺寸">屏幕尺寸</h3><p>指屏幕对角线的长度，单位通常是英寸（下面都直接写寸）。主流的那种十分正常的屏幕有24、27、32寸等，便携屏目前我见的（也不多）都14寸不等，一般来说24或者27比较主流，一般网吧差不多就这样，大一点的话可以选更大屏幕或者带鱼屏（富哥随意）。</p><h3 id="分辨率">分辨率</h3><p>平常见的最多的应该就是1080p（1920*1080）、2k（2560*1440，即16:9）、4k（3840*2160），有的时候还能看到像2.5k（16:10的主配，当然也有的人叫2560*1440为2.5k）。当然这只是常见的，很多情况下什么2k2.5k的叫法十分随意，其他的见下表（图源小黑盒）</p><figure><imgsrc="D:\blogs\source\img\inblogs\76a78db4df63fe2a9e93637edd70ab7.jpg"alt="76a78db4df63fe2a9e93637edd70ab7" /><figcaptionaria-hidden="true">76a78db4df63fe2a9e93637edd70ab7</figcaption></figure><p>还有就是这个玩意儿相当于乱叫，不能太深究，游戏群体，显示器厂家，电影行业，电视行业叫法全都不一个标准。下面举几个例子：</p><ul><li><p>常见的视频平台：标清是480p，高清是720p，超高清是1080p，蓝光是1080p60帧，4k是2160p，码率未知。</p></li><li><p>上海某电视台剪辑师说法：1080P10M叫高清，2560*1440M叫2K，3840*2160或4096*2160叫4K，而蓝光是特指蓝光盘，和磁带一样都是实体存储介质。</p></li><li><p>山东某电视台工作人员说法：480p为标准，720p为高清，1080p是超清。4k的就叫做4k。码率按mxf算。</p></li></ul><p>对于视频而言，不能光看分辨率，码率也很关键。视频分辨率是4k的，但码率如果是5m，那还不如10m的1080p清晰。再一个对于显示器而言，也不能光看分辨率，还要看ppi。国内视频不如自己下的资源清晰是因为码率太低了。具体的诸如找BT种子的相关资源网站或许之后有时间的话也会整理一下？</p><p>有些重度影视发烧友，甚至还要用PotPlayer软件调试视频色彩平衡还有什么解码方式，这个算是逛论坛的时候看到的。</p><p>显示上还有一点就是如果你用一张1080P照片，放到2K分辨率下，可能会出现更模糊的情况，1080P没有那么多精准像素点，靠2K屏模拟，所以有点胡，当然了，感知度不强。</p><p>有的网友指出OLED屏幕的分辨率要打八折，是像素的工作原理不同而导致的。</p><h4 id="基本单位">基本单位</h4><ul><li><p>px（像素）：像素是显示器上最小的显示单位，用来表示图像的基本构成。px就是指一个像素点。</p></li><li><p>pt（点）：描述字体大小。在数字设备上，pt 与 px的转换通常依赖于设备的分辨率或 ppi（如 72ppi 或 96ppi）。</p></li><li><p>ppi（每英寸像素数）：用来衡量显示屏的像素密度，即每英寸包含的像素数。公式为：</p></li></ul><p><span class="math display">\[PPI = \frac{\sqrt{(宽度像素数)^2 +(高度像素数)^2}}{屏幕对角线长度（英寸）}\]</span></p><ul><li>dpi（每英寸点数）描述打印机输出的精细程度，表示每英寸能够打印的点数。有时dpi 和 ppi 会混淆，但严格来说，dpi 更多用于打印领域，而 ppi则用于显示设备。</li></ul><h3 id="面板选择">面板选择</h3><p>具体详见发光原理，一般来说直接IPS或者OLED，玩3A和电影的可以考虑VA，高端FPS上TN.</p><h3 id="刷新率">刷新率</h3><p>就是帧数，越高越流畅，没啥好讲的，像我这种就敲敲键盘打打gal的上个60Hz够了，打电动的尤其是fps玩家越高越好。</p><h3 id="亮度">亮度</h3><h4 id="单位">单位</h4><p>首先明确一点就是在显示器的亮度上一般用的是尼特（nit）来刻画单位光强密度，在其他地方可能还会见到诸如：</p><ul><li>坎德拉（光强的国际制七个主单位之一，光源在某一方向上的发光强度）：衡量光源在某一方向上的发光强度，大概可以拿以点光源的光强除上以点光源为圆心的包络球的球面度来理解。1坎德拉是光源在给定方向（频率540×10¹²Hz，对应绿光）发出1/683瓦特每球面度的辐射强度时产生的发光强度。</li><li>烛光：旧单位，比坎德拉稍小，约的话可以直接等于坎德拉，现在基本上被废。</li><li>流明（光照强度之和，整体发出的可见光总量）：1流明 =1坎德拉×1球面度（lm = cd·sr）</li><li>尼特（光源或反射表面单位面积的发光强度）：1尼特 = 1坎德拉/平方米（nt= cd/m²）</li><li>勒克斯（照度的单位，表示的单位面积接收到的光通量）：1勒克斯 =1流明/平方米（lx = lm/m²）</li></ul><p>总的来说光通量（流明）是指光源所有方向上发射出光的能力，发光强度（坎德拉）是特定方向上的发光能力，亮度（尼特）是单位面积的发出或反射的发光强度，照度（勒克斯）是单位面积所入射的光量。</p><h4 id="例子">例子</h4><p>电影院中屏幕大概是50nit，户外手机一般为300nit往上，所以电影院不能看手机。当然，要是算流明的话电影院屏幕远远大于手机</p><p>索尼HDR电视的亮度能干到10000nit，大多数HDR设备最高2000nit，再高就是瞎眼神器。</p><p>智能手机/平板电脑：200 至 1000+尼特，400-500可以在白天看，200nit太阳下看不清。</p><p>笔记本电脑/显示器：200 至 600+尼特，不建议太高，上限200低端，上限400足够，看不清建议拉窗帘而不是调亮度。笔者刚买的副屏就是400nit的。</p><h3 id="对比度">对比度</h3><p>对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间的比值，差异范围越大代表对比越大，差异范围越小代表对比越小。对比度高，可以展示更多的亮部和暗部细节，让画面更有层次。</p><p>对比度的相关判断可以直接点击<ahref="https://www.pingmudiy.com/screentest/#welcome">这个链接</a>，用烧屏网的相关工具进行测试。这里就不放图了，避免莫名其妙的压缩导致不准。</p><h3 id="接口">接口</h3><ul><li><p><strong>VGA</strong>：上古模拟信号接口，上次见还是家里面的古董老机器，仅限视频传输，容易受到干扰，信号容易失真，字容易糊仅支持低分辨率（如1080p@60Hz），逐渐被淘汰，但是在几十年前十分风光。</p></li><li><p><strong>DVI</strong>：为了弥补 VGA接口的不足，推出了能同时支持模拟信号和数字信号传输的 DVI接口，能干到1080p@144Hz，但是缺点就是不支持音频信号。现在也基本上见不到了，就不再详细说明。</p></li><li><p><strong>HDMI</strong>：主流数字接口，支持音画同步传输。HDMI2.0带宽18Gbps，可承载1440p@144Hz、1080p@240Hz以及4K<spanclass="citation" data-cites="60Hz">@60Hz</span>；HDMI2.1带宽48Gbps，支持4K@120Hz或8K<span class="citation"data-cites="60Hz">@60Hz</span>，增加了对动态HDR的支持，适用于游戏主机与高端显卡。</p></li><li><p><strong>DisplayPort（DP）</strong>：PC领域专业接口，DP1.4支持4K@120HzHDR或8K@60Hz HDR，支持3:1的DSC压缩技术；DP2.0带宽提升至80Gbps，可原生支持8K@60Hz。</p></li><li><p><strong>USB-C</strong>：多功能接口，支持视频传输（需DP AltMode）、数据传输与充电（PD协议）。部分显示器通过USB-C直连笔记本实现「一线通」，但需注意带宽限制（如USB3.2 Gen2仅支持4K@60Hz）。</p></li></ul><p>电竞用户优先选DP 1.4或HDMI2.1及以上；轻薄本用户也可考虑USB-C一线通；多设备切换需求可关注显示器是否配备KVM功能。</p><p>具体而言可以用接口带宽来算一下所支持的分辨率，公式如下： <spanclass="math display">\[总像素*子像素*色深*刷新率 = 总带宽\]</span> 其中： <span class="math display">\[总像素=横向分辨率*纵向分辨率\]</span></p><p><span class="math display">\[子像素=RGB色素数=3\]</span></p><p>假设要输出4K、10bit、144Hz的画面： <span class="math display">\[3840*2160*3*10bit*144 = 35.8Gbps。\]</span></p><h3 id="色域">色域</h3><h4 id="概述">概述</h4><p>就是能够显示的色彩范围，越高表现度越好，标准的话主流的有NTSC（有点老）、sRGB、P3和AdobeRGB，一般来说看sRGB就行，日常95%以上，设计相关或者有其他偏好的话就上99%或者100%sRGB的就好。想要进一步了解更多就继续看</p><h4 id="拓展">拓展</h4><ul><li><strong>sRGB</strong>：由微软公司和惠普公司主导，是windows系统的UI和各类软件中默认应用的色域，也是互联网中图形图像信息的标准色域。但是sRGB色域在CIE-1931中覆盖面积不高，色彩还原度有限，绿色部分的覆盖率较低，目前市面上大部分显示器都能轻松达到96%以上的sRGB色域覆盖。</li><li><strong>Adobe RGB</strong>：Adobe公司在sRGB不够用的时候出的，玩摄影剪辑的都比较熟悉，他家的PS、AI、PR之类的十分流行。其色域覆盖区域更广，显示色彩更丰富，大多应用于高端的艺术设计专业显示器中，价格昂贵。</li><li><strong>DCI-P3色域</strong>：其主要由美国电影行业提出，是数字影像领域中比较新的色域标准，着重人类视觉的真实体验，匹配电影的色彩表现要求。相比sRGB色域，其覆盖了更多的红色和绿色空间。但是我见的倒是相对少一些。</li><li><strong>Rec.2020</strong>：国际电信组织将其作为一个涵盖各影像广播的参数规划、视其为高画质投影机/电视和相关无线电视广播设备的参考标准。这些包含：解析度(resolution)、帧速率(framerate)、位元深度(bit depth)、色域等。</li><li><strong>P3</strong>：广义上包含了 DCI-P3 和 DisplayP3，前者是影视行业标准，后者是 Apple 在 DCI-P3 基础上参考了 sRGB而修订出的自己的标准，在白点和伽马上与 DCI-P3不同，但是能覆盖的颜色相同，相对于 sRGB 除了蓝色都有较大提升。</li><li><strong>NTSC</strong>：由美国国家电视标准委员会在 1953年订制，目的是为了给当时刚出现不久的 CRT彩色电视定制一套标准，由于实在是太过于古老（Apple DOS 3.1 诞生于 1978年， MS-DOS 诞生于 1980 年）早已不适用于现代显示器，更最重要的是对于PC（广义的）和移动设备来说，几乎没有内容创作者是以 NTSC为工作空间的，它保留下来最多的用途还是用于比较其他的色彩空间。</li><li><strong>REC-709</strong>：是 sRGB的影视行业（高清电视）名称，属于早期彩色电视所用的色域标准，也是目前最为广泛的色域标准，我国影视行业至今仍在使用此标准。</li></ul><p>其中AdobeRGB和DCI-P3色域远大于sRGB，显示的色彩范围更丰富，也被称为广色域。一般来说达到92%DCI-P3就可以说是广色域屏幕了。</p><figure><imgsrc="https://pic2.zhimg.com/v2-3a55b4540248ffc6c308c23af36f4181_r.jpg"alt="【科普】电视显示器色域科普：sRGB，DCI-P3，Adobe RGB色域，Rec.2020,广色域都是些啥？一文读懂 - 知乎" /><figcaptionaria-hidden="true">【科普】电视显示器色域科普：sRGB，DCI-P3，AdobeRGB色域，Rec.2020,广色域都是些啥？一文读懂 - 知乎</figcaption></figure><h4 id="几个误区">几个误区</h4><ul><li><strong>多色域显示器</strong></li></ul><p>有的专业显示器会支持不同的色域，因为广色域显示器的作用范围往往都超越sRGB，但是如果是用广义显示器来显示sRGB的话，可能会产生一些偏色与失真，即便它的色彩极为饱和。于是就要进行一些色域的缩限，就是在平常情况下将其缩放在sRGB的范围内，来保证图片不会失真。具备色域限缩功能的显示器都会特别标注支持多种色域，让用户在日常使用中使用sRGB色域显示，而在摄影修图或者印刷校样的时候，可以切换AdobeRGB色域显示，确保色彩的可靠性。</p><ul><li><strong>色域覆盖超100%</strong></li></ul><p>比如说厂家发布的新眼球，然后将那个色域标注为比如130%，即超出sRGB范围，达到了标准面积的130%，但是这有可能有一个雷点就是，他可能会利用色欲域的偏移来达到一个指标的优化，实际上的图片是失真了的。</p><ul><li><strong>72%的NTSC</strong></li></ul><p>有很多无良厂家和媒体给出过这么一个等式：72% NTSC = 100sRGB.并且以此来宣传自己的屏幕很优秀，能够用于专业的工作，不比当年 MacBook Pro100% sRGB 差，理由就是用 NTSC 测试的话，当年的 MacBook Pro 屏幕也是 72%NTSC色域。这实际上是利用了消费者认知的一个信息差，想以此来标榜自己的显示器，需要擦亮眼睛。</p><h3 id="色深">色深</h3><p>色深色深即色彩深度，色彩深度是计算机图形学领域表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多，过渡会更加丝滑。</p><p>色深表示显示器对单色通道的灰阶划分精度，8 bit 对应每通道 256级灰阶（RGB 三通道共 1670 万色），10 bit 则为 1024 级（10.7亿色）。更高的色深能减少色彩断层现象，尤其在渐变场景（如天空、阴影过渡）中表现更自然。</p><p>目前主流显示器多采用 8 bit 原生色深，部分 IPS 面板通过FRC（帧率控制） 技术抖动模拟 10 bit 效果（标注为 8 bit+FRC）。原生 10bit 面板成本较高，多见于专业设计屏或高端 OLED 屏幕。大部分 8 bit够了。</p><p><strong>注意</strong>：某些厂商会模糊标注“10.7亿色”，实际可能为抖动实现。</p><h3 id="色准">色准</h3><p>色准是衡量颜色「准确度」的指标，简单来说，就是让显示器显示什么颜色，就是什么颜色。一般用ΔE（显示颜色与标准颜色之间的偏差）来表示（数值越小越好）。</p><p>衡量参数为Delta E（△E），数值越小，色彩还原越好。</p><ul><li>△E ≤ 1：人眼几乎无法察觉色差，适合专业摄影、印刷校色。</li><li>△E ≤ 2：满足设计、影视后期等创作需求。</li><li>△E &gt; 3：肉眼可见偏色，需通过校色仪校准。</li></ul><p>专业显示器出厂前会进行校色并附赠 <strong>ΔE报告</strong>，部分型号支持硬件级校准（如 LUT写入）。日常使用中，环境光变化与面板老化可能导致色准偏移，建议定期使用校色仪（如Datacolor SpyderX、X-Rite i1Display Pro）重新校准。校色时需注意：</p><ul><li><p>预热显示器 30 分钟以上。</p></li><li><p>关闭动态对比度与 HDR 功能。</p></li><li><p>选择与工作流匹配的色域。</p></li></ul><h3 id="hdr">HDR</h3><p>这个概念这几年应该算是比较火，全称High-DynamicRange，高动态范围成像，简单的来说就是开了看着会更爽，可以在认证处看一下是什么级别。</p><p>它可以通过提升显示器的<strong>亮度范围</strong>和<strong>对比度</strong>，还原更接近真实世界的明暗细节与色彩层次。与传统SDR（标准动态范围）相比，HDR能同时保留高光部分的纹理（如阳光下的云层）和暗部场景的细节（如阴影中的岩石），显著增强画面立体感与沉浸感。</p><h4 id="标准">标准</h4><p>业界暂无统一标准。</p><ul><li><strong>HDR10</strong>：基础标准，使用静态元数据（全片统一亮度参数），支持10 bit 色深，峰值亮度通常要求 ≥1000尼特，广泛适用于游戏、影视内容。</li><li><strong>HDR10+</strong>：升级版，引入动态元数据（逐帧优化亮度），兼容性较强。</li><li><strong>Dolby Vision</strong>：杜比实验室推出的高端标准，支持 12 bit色深与动态元数据，对硬件要求更高，画面表现更细腻，多用于高端电视与流媒体（如Netflix）。</li><li><strong>DisplayHDR</strong>：由 VESA 基于HDR10制定的显示器认证体系，分多个等级（如 DisplayHDR400/600/1000），标注峰值亮度、色域覆盖等参数（例：DisplayHDR 1000 需满足1000 尼特峰值亮度、99% DCI-P3 色域）。</li></ul><h4 id="注意">注意</h4><ul><li>部分显示器仅支持 HDR 信号输入，但亮度不足或缺乏分区背光，实际效果与SDR 差异不大。</li><li>DR 对暗室环境更友好，强光下高亮优势难以体现。</li><li>需片源、播放设备、显示器均支持 HDR 才能生效，缺一不可。</li><li>HDR对游戏不是很必要，游戏在信号源上就有先天优势。</li><li>当我们看到一个电视机或者显示器，宣传自己支持HDR的时候，会有以下两种可能性。第一，电视机或显示器从显示驱动芯片到显示面板都支持HDR标准。第二，电视机或显示器的显示驱动芯片支持HDR解码，但是显示面板并不一定能够通过HDR认证。例如SDR的标准是100nit，HDR认证的最低标准是400nit，介于100nit和400nit之间显示面板，通过显示驱动芯片对HDR的支持，可以提供比SDR高的多的动态范围，让用户体验到接近HDR的视觉体验。</li></ul><h3 id="重量">重量</h3><p>便携屏要考虑一下，防止抱着一块砖到处转，这个就比较看个人了。</p><h3 id="支架与挂壁支持">支架与挂壁支持</h3><p>详见自己的需求，这里略。</p><h2 id="工具汇总">工具汇总</h2><ul><li>对比度：<ahref="https://www.pingmudiy.com/screentest/#welcome">烧屏网</a>。</li><li>DisplayHDR小软件，自己找一找吧。</li></ul><h2 id="参考">参考</h2><p><ahref="https://cn.windows-office.net/?p=10479">什么是屏幕亮度尼特？您需要多少尼特？</a></p><p><ahref="https://zhuanlan.zhihu.com/p/606290120">【科普】电视显示器色域科普：sRGB，DCI-P3，AdobeRGB色域，Rec.2020,广色域都是些啥？一文读懂 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/562781181">科普百篇系列（155）液晶彩色显示屏的构造原理 - 知乎</a></p><p><ahref="https://baike.baidu.com/item/光的偏振/1277912">光的偏振_百度百科</a></p><p><ahref="https://www.bilibili.com/video/BV1Me4y1k72b?spm_id_from=333.788.videopod.sections&amp;vd_source=35efa20a3dc2d6382913a782f2bf8ad8">【硬核科普】一个视频带你了解LCDOLED QLED mini-LED等显示技术的区别_哔哩哔哩_bilibili</a></p><p><ahref="https://www.zhihu.com/question/407170937">流明，尼特，勒克斯，烛光，坎德拉有什么区别有什么关系啊？怎么使用？为啥屏幕只用尼特来计量？- 知乎</a></p><p><ahref="https://blog.csdn.net/didi_ya/article/details/122241863">【科普】显示器VGA、DVI、HDMI、DP等各种接口详细科普_显示器接口-CSDN博客</a></p><p><ahref="https://zhuanlan.zhihu.com/p/440706026">一文搞懂，显示器接口的VGA、HDMI、DVI 和 DisplayPort 、雷霹、Type-C接口有什么区别？ -知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/70673207">显示器接口都有哪些？- 知乎</a></p><p><ahref="https://zhuanlan.zhihu.com/p/394352018">【显示器科普知识6】液晶显示器技术参数：对比度- 知乎</a></p><p><ahref="https://zhuanlan.zhihu.com/p/398281787">硬核科普│什么是HDR？一文秒懂为何大家都向往HDR模式！- 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/70383462">基础px、pt、ppi的知识- 知乎</a></p><p><a href="https://zh.wikipedia.org/wiki/色彩深度">色彩深度 -维基百科，自由的百科全书</a></p><p><ahref="https://zhuanlan.zhihu.com/p/259139655#:~:text=色深代表着画面颜色的「细腻程度」，也以简单理解为颜色数量的多少。%20并且，数值越大就越细腻，同时色彩过渡就更加平滑自然。%20目前主流显示器的色深一般是6%20bit、8bit和10bit。%20具体而言，色深8bit指的是红（R）、绿（G）、蓝（B）这三原色，在显示颜色时各有2的%208次方种（即%20256%20种）。,种不同的绿、256种不同的蓝，这三种原色组合起来，总的颜色数量就是256×256×256%3D16.7%20百万。%20以此类推，10bit的色数就是%2010.7%20亿，而6bit的色数是%200.26%20百万。%20由此可见6bit的色数是相对偏少的，因此色彩显示效果就比较差。">色深、色域、色准、HDR、防撕裂你都懂吗？- 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>电脑硬件</category>
      
      <category>概念阐述</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于人体关键点识别的摔倒检测算法</title>
    <link href="/2025/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/2025-04-05-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%86%E5%88%AB%E7%9A%84%E6%91%94%E5%80%92%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/2025-04-05-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%86%E5%88%AB%E7%9A%84%E6%91%94%E5%80%92%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1id="基于人体关键点识别的摔倒检测算法">基于人体关键点识别的摔倒检测算法</h1><p>最开始我们做跌倒检测的时候用的是传统的单纯用yolo等目标检测算法，但是在交流中我们也发现一个问题，就是传统的目标检测难以区分摔倒与跑跳坐下蹲下等动作之间的区别，即难以实现类间分类，然后就是一拍脑门想起来了可以基于人体关键点识别来做跌倒检测，和其他的动作区分开来，而且这个方案已经比较成熟了，详细可见下面的参考文献。在这里先做一下算法的调研。之后等这个项目结题后再进行具体模型的分享。</p><h2 id="现存算法">现存算法</h2><h3 id="传统时空分析">传统时空分析</h3><p>通过实时跟踪人体骨骼关键点（如头、肩、膝盖、脚踝等），分析这些点的位置变化规律来判断是否跌倒。优点是直观和解释性强，适合实时的检测；缺点为数据缺失时可能出错，这个在鲁棒性上可以做一些工作。</p><pre><code class=" mermaid">flowchart LR    A[视频/图像输入] --&gt; B[关键点提取]    B --&gt; C[动态特征计算]    C --&gt; D[分类决策]    D --&gt; E&#123;&#123;跌倒判定结果&#125;&#125;    %% 关键点提取模块    subgraph keypoint_extract [关键点提取]        direction TB        B1[OpenPose] --&gt;|输出关键点| B2[BlazePose]    end    %% 动态特征计算模块    subgraph feature_cal [动态特征计算]        direction TB        C1[质心高度&lt;br&gt;（头部/躯干骤降）]:::feature        C2[关节角度&lt;br&gt;（躯干-地面夹角）]:::feature        C3[运动速度&lt;br&gt;（垂直加速度突增）]:::feature    end    %% 分类决策模块    subgraph decision [分类决策]        direction TB        D1[阈值法]:::decision --&gt;|&quot;高度 &lt; 阈值?&quot;| D1a[报警]        D2[机器学习模型]:::decision --&gt; D2a[SVM] &amp; D2b[随机森林]    end    %% 应用样式    class A input;    class B,B1,B2 process;    class C,C1,C2,C3 feature;    class D,D1,D2 decision;    class E result;</code></pre><ul><li><p>关键点提取：</p><p>人体关键点检测模型（如OpenPose、BlazePose）从视频中抓取人体关键点坐标。</p></li><li><p>动态特征计算：</p></li></ul><p>​ 质心高度：头部或躯干关键点的高度突然下降可能是跌倒信号。</p><p>​关节角度：如肩膀-膝盖连线与地面的夹角急剧变小（例如从站立时的90°到跌倒后的接近0°）。</p><p>​运动速度：头部或躯干在垂直方向的加速度骤增（例如跌倒时的“失重”瞬间）。</p><ul><li>分类决策：</li></ul><p>​ 手动调阈值：设定特征阈值（如质心高度低于膝盖时判定跌倒）。</p><p>​ 机器学习模型：用SVM或随机森林基于特征组合分类。直接上机器学习算了。</p><hr /><h3 id="深度学习时序建模">深度学习时序建模</h3><p>算力和数据要求比较高。</p><ul><li>LSTM：分析关键点序列的时序变化，捕捉“跌倒前-跌倒中-跌倒后”的动态过程。<ul><li>例如，专利CN112163564A将人体分为头、躯干、腿三区域，用LSTM记忆动作轨迹，预判跌倒风险。<br /></li></ul></li><li>3DCNN：直接输入视频片段，同时提取空间（姿态）和时间（动作）特征（勉强算吧，做出来了也是勾八）。<br /></li><li>图卷积网络（GCN）：将人体骨骼视为图结构，分析关节间的关联性，适合处理复杂动作。这个网络还不咋熟，到时候再学一下。</li></ul><hr /><h3id="基于clahe与形态学的目标骨架提取"><strong>基于CLAHE与形态学的目标骨架提取</strong></h3><p>这个主要是骨架提取的，不需要深度学习模型，计算资源需求不高，但是可能在复杂背景下的鲁棒性不足。</p><ul><li><strong>图像增强</strong>：使用限制对比度自适应直方图均衡化（CLAHE）提升图像对比度，突出人体轮廓。</li><li><strong>骨架提取</strong>：<ol type="1"><li>背景差分法分离运动目标，形态学闭运算填充空洞。</li><li>边缘检测（如Sobel算子）提取人体轮廓，中值滤波去噪。</li><li>细化算法生成人体骨架，提取近似关键点（如头部、四肢末端）。</li></ol></li></ul><hr /><h3 id="拓展">拓展</h3><p><strong>遮挡问题</strong>：</p><p>使用时空滤波（如滑动窗口滤波）填补遮挡导致的关键点缺失。</p><p><strong>实时性优化</strong>：</p><ul><li><p>采用模型蒸馏技术，将大模型的知识迁移到小模型。</p></li><li><p>通过OpenVINO™等工具将模型部署到边缘设备，减少云端依赖。</p></li></ul><p><strong>鲁棒性优化（这个robust的翻译见一次骂一次）</strong></p><ul><li>多传感器融合，比如加个手环上面整点加速计之类的，但是这个成本直接干上去了</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准分数-Z-Score</title>
    <link href="/2025/04/04/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B0%8F%E5%B7%A5%E5%85%B7/2025-04-04-%E6%A0%87%E5%87%86%E5%88%86%E6%95%B0-Z-Score/"/>
    <url>/2025/04/04/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B0%8F%E5%B7%A5%E5%85%B7/2025-04-04-%E6%A0%87%E5%87%86%E5%88%86%E6%95%B0-Z-Score/</url>
    
    <content type="html"><![CDATA[<h1 id="z-score">Z-Score</h1><h2 id="一简介">一、简介</h2><p>一种衡量数据点相对于总体均值的位置的分数，可将不同量纲或不同分布的数据转化到同一标准下（标准正态分布），方便比较。正值表示数据大小在均值之上，负值则在均值之下。</p><hr /><h2 id="二公式">二、公式</h2><p><span class="math display">\[\frac{X-\bar{X} }{s}\]</span></p><p>及均值差除以标准差。matlab中可以直接使用<code>zscore()</code>函数。</p><hr /><h2 id="三应用">三、应用</h2><ul><li><strong>异常值检测</strong> zscore 可用于判断异常值（Outlier）：通常设置阈值（如 2 或 3），如果一个数据的 |z|值大于该阈值，则该数据可能为异常值。 例如：若 |z| &gt;3，则通常认为该数据偏离均值过远，可以进一步检查是否为异常情况。这个可以从正态分布中类比出来，约68% 的数据落在 [-1, 1] 范围内，约 95% 的数据落在 [-2, 2] 范围内，约99.7% 的数据落在 [-3, 3] 范围内</li><li><strong>数据标准化</strong> 在机器学习或数据挖掘中，通过对数据进行zscore 标准化，可以消除量纲影响，利于建模。</li><li><strong>比较不同数据集</strong> 由于 zscore消除了原始数据的均值和标准差的影响，所以可以将来自不同数据集的数值进行直接比较。</li></ul><hr /><h2 id="四局限性">四、局限性</h2><p>zscore对于数据的分布有一定的要求，越靠近正态分布的情况下越好。</p><p>zscore消除了数据原有的实际意义，缺乏可解释性，结果只能用于比较。如果需要解释数据的真实意义，还需要还原原值。</p><hr /><h2 id="参考资料">参考资料</h2><p><ahref="https://blog.csdn.net/qy20115549/article/details/53117742">数据标准化方法z-score讲解(matlab)_matlabzscore函数-CSDN博客</a></p><p><ahref="https://baike.baidu.com/item/Z分数/8268473">Z分数_百度百科</a></p><p><a href="https://zhuanlan.zhihu.com/p/69074703">数据标准化（一） -Z-Score标准化 - 知乎</a></p><p><ahref="https://blog.csdn.net/qq_39482438/article/details/110873346">Z-Score：定义，公式和 数据标准化-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊综合评价法-FCE</title>
    <link href="/2025/04/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-04-01-%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%B3%95-FCE/"/>
    <url>/2025/04/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-04-01-%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%B3%95-FCE/</url>
    
    <content type="html"><![CDATA[<h1 id="模糊综合评价法">模糊综合评价法</h1><p>量分为 <strong>确定性</strong> 和 <strong>不确定性</strong>：</p><ul><li><strong>确定性</strong>：经典数学（几何、代数）</li><li><strong>不确定性</strong>：<ol type="1"><li>随机性（概率论、随机过程）如掷筛子，观看那一面向上，这种现象的规律性靠概率统计去刻画。</li><li>灰性（灰色系统）</li><li>模糊性（模糊数学）如“今天天气很热”、“小伙子很帅”等，靠模糊数学去刻画。</li></ol></li></ul><p>而模糊综合评价法是一种基于 <strong>模糊数学</strong> 的综合<strong>评价方法</strong>。该综合评价法根据模糊数学的<strong>隶属度理论</strong>把定性评价转化为定量评价，即用模糊数学对受到多种因素制约的事物或对象做出一个总体的评价。它具有结果清晰，系统性强的特点，能较好地解决模糊的、难以量化的问题，适合各种<strong>非确定性问题的解决</strong>。</p><h2 id="经典集合和模糊集合的基本概念">经典集合和模糊集合的基本概念</h2><h3 id="经典集合classical-set和特征函数">经典集合（classicalset）和特征函数</h3><ul><li><strong>经典集合</strong>：具有相同属性的事物的集体，例如：颜色、性别、手机品牌等、自然数集。</li><li>集合的基本属性：互斥、确定，就是从高中以来我们一直所认为的集合。</li></ul><h3 id="模糊集合fuzzy-set和隶属函数">模糊集合（fuzzyset）和隶属函数</h3><ul><li><p><strong>模糊集合</strong>：用来描述模糊性概念的集合。（帅、高、白、年轻…）</p></li><li><p>与经典集合相比，模糊集合承认亦此亦彼，即不具有确定性和互斥性，而我们很多情况下都是这样的集合，比如25年第一次校赛B题。</p></li><li><p>数学中对于模糊集合的刻画：<strong>隶属函数</strong></p><p><span class="math display">\[\mathbf{u_A: U \rightarrow [0,1]}\]</span> 其中注意与 <span class="math inline">\(\{0, 1\}\)</span>的区别，<span class="math inline">\(\{0, 1\}\)</span>只有两种可能，<span class="math inline">\([0, 1]\)</span>有无数种可能。</p></li></ul><h2 id="隶属函数的确定方法">隶属函数的确定方法</h2><h3 id="模糊统计法">模糊统计法</h3><p>自己捏数或者放问卷。</p><h3 id="借助已有的客观尺度">借助已有的客观尺度</h3><p>比如用恩格尔系数描述家庭贫富状况。</p><h3 id="指派法">指派法</h3><p><strong>根据问题的性质直接套用某些分布作为隶属函数，主观性较强。</strong></p><figure><imgsrc="D:\blogs\source\img\inblogs\533fb99c13fa8f6ca63aeb208c4bf273.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>其中，梯形分布用得较多。</p><h2 id="应用模糊综合评价">应用：模糊综合评价</h2><h3 id="评价问题概述">评价问题概述</h3><p>模糊评价问题是要解决的问题是：</p><blockquote><p>① 把论域中的对象对应评语集中的一个指定的评语。 ②将方案作为评语集并选择一个最优的方案。</p></blockquote><p>在模糊综合评价中，引入三个集合：（下面的符号和概念中的符号表示的<strong>含义不同</strong>）</p><ul><li><strong>因素集（评价指标集）</strong> <span class="math inline">\(U= \{u_1,u_2,...,u_n\}\)</span></li><li><strong>评语集（评价的结果集）</strong> <spanclass="math inline">\(V = \{v_1,v_2,..,v_m\}\)</span></li><li><strong>权重集（指标的权重）</strong> <span class="math inline">\(A= \{a_1,a_2,...,a_n\}\)</span></li></ul><h3 id="一级模糊综合评价">一级模糊综合评价</h3><ol type="1"><li><p><strong>确定因素集</strong></p><p>一级模糊评价中，n 往往较小（一般 ≤ 5）且 指标间相关性不强。</p></li><li><p><strong>确定评语集</strong></p></li><li><p><strong>第三步：确定各因素的权重</strong></p><p>确定权重的方法有很多，如：Delphi法（专家调查法，即瞎几把捏数法）、加权平均法、众人评估法。但是建议：当没有数据的时候可采取层次分析法，有数据的时候可采取熵权法。</p></li><li><p><strong>第四步：确定模糊综合评判矩阵，对每个元素做出评价</strong></p></li><li><p><strong>第五步：模糊综合评判</strong></p></li></ol><h3 id="多级模糊综合评价">多级模糊综合评价</h3><p>一级模糊综合评价是多级模糊综合评价的基础。它是将一级模糊评价因素集指标的相关性指标进行统一综合，因为上文讲过一级模糊评价的指标之间是相关性不强的，那么这样相关性指标在只考虑这一种因素的情况下是不相关的，即相对不相关。然后对每个相关性指标进行综合，求得只看这一组指标对于评语集的隶属度，此方法进行类推，最后再综合。</p><h2 id="总结">总结</h2><ol type="1"><li>隶属函数有三种确定方法，要根据实际情况来选择使用。</li><li>极大型（极小型）指标，和模糊集合的三类（偏小型、中间型、偏大型）是两种概念，注意区分。</li><li>模糊综合评价的因素指标是相关性不强的，如果有相关项较强的需要进行多级模糊综合评价，级数一般不超过3层。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>评价类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优劣解距离法-TOPSIS</title>
    <link href="/2025/04/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-04-01-%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95-TOPSIS/"/>
    <url>/2025/04/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-04-01-%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E6%B3%95-TOPSIS/</url>
    
    <content type="html"><![CDATA[<h1 id="优劣解距离法-topsis">优劣解距离法-TOPSIS</h1><h2 id="一建模">一、建模</h2><p>TOPSIS进行建模，大致分为以下四个步骤：</p><ol type="1"><li>将原始矩阵正向化</li><li>将正向化矩阵标准化</li><li>计算得分并归一化</li></ol><p>个人感觉跟熵权法是有很多的相通之处的，二者应该可以相互混着用。</p><h3 id="矩阵正向化">矩阵正向化</h3><p>在生活中，常见的指标有四种：</p><table><thead><tr><th>指标名称</th><th>指标特点</th><th>例子</th></tr></thead><tbody><tr><td>极大型（效益型）指标</td><td>越大（多）越好</td><td>成绩、GDP增速、企业利润</td></tr><tr><td>极小型（成本型）指标</td><td>越小（少）越好</td><td>费用、坏品率、污染程度</td></tr><tr><td>中间型指标</td><td>越接近某个值越好</td><td>水质量评估时的PH值</td></tr><tr><td>区间型指标</td><td>落在某个区间最好</td><td>体温、水中植物性营养物量</td></tr></tbody></table><p>那么，在TOPSIS方法中，就是要将所有指标进行统一正向化，即统一转化为极大型指标。那么就需要极小型、中间型以及区间型的指标进行转化为极大型指标。</p><p><strong>极小型转极大型</strong>： <span class="math display">\[x_{new}= \frac{\max - x_i}{\max - \min}\]</span> 如果所有的元素均为正数，那么也可以使用：</p><p><span class="math display">\[x_{new}=\frac{1}{x_i}\]</span></p><p><strong>中间型转极大型：</strong>指标值既不要太大也不要太小，取某特定值最好（如水质量评估PH值）。设<spanclass="math inline">\(\{x_i\}\)</span>是一组中间型指标序列，且最佳的数据为<span class="math inline">\(x_{best}\)</span>，那么正向化的公式如下：<span class="math display">\[M = \max\{|x_i - x_{best}|\}\]</span> <span class="math display">\[\bar{x}_i = 1 - \frac{|x_i - x_{best}|}{M}\]</span> <strong>区间型指标：</strong>指标值落在某个区间内最好，例如人的体温在36°～37°这个区间比较好。设<spanclass="math inline">\(\{x_i\}\)</span>是一组区间型指标序列，且最佳的区间为<spanclass="math inline">\([a,b]\)</span>，那么正向化的公式如下： <spanclass="math display">\[M = \max\{a - \min\{x_i\}, \max\{x_i\} - b\},\ \tilde{x}_i =\begin{cases}1 - \frac{a - x_i}{M}, &amp; x_i &lt; a \\1, &amp; a \leq x_i \leq b \\1 - \frac{x_i - b}{M}, &amp; x_i &gt; b\end{cases}\]</span> 实际上这里跟熵权法里面讲过的那个正向化基本上一模一样，具体见<ahref="熵权法(EWM).md">熵权法</a></p><h3 id="矩阵标准化">矩阵标准化</h3><p>标准化的目的就是消除不同量纲的影响。</p><p>假设有n个要评价的对象，m个评价指标（已经正向化了）构成的正向化矩阵如下：</p><p><span class="math display">\[X =\begin{bmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{nm}\end{bmatrix}\]</span> 那么对其标准化后的矩阵记为Z，Z的每一个元素：</p><p><span class="math display">\[z_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^{n}x_{ij}^2}}\]</span> 标准化矩阵Z：</p><p><span class="math display">\[Z =\begin{bmatrix}z_{11} &amp; z_{12} &amp; \cdots &amp; z_{1m} \\z_{21} &amp; z_{22} &amp; \cdots &amp; z_{2m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\z_{n1} &amp; z_{n2} &amp; \cdots &amp; z_{nm}\end{bmatrix}\]</span>注意：标准化的方法不唯一，但目的都是为了去量纲。比如熵权法那一章就还介绍过存在负数时直接上</p><p><span class="math display">\[z_{ij} = \frac{x_{ij} - \min\{x_{1j}, x_{2j}, \ldots,x_{nj}\}}{\max\{x_{1j}, x_{2j}, \ldots, x_{nj}\} - \min\{x_{1j}, x_{2j},\ldots, x_{nj}\}}\]</span></p><h3 id="计分归一化">计分归一化</h3><p>最大值：</p><p><span class="math display">\[Z^+ = (\max\{z_{11},z_{21},\cdots,z_{n1}\},\max\{z_{12},z_{22},\cdots,z_{n2}\}, \cdots,\max\{z_{1m},z_{2m},\cdots,z_{nm}\})\]</span> 最小值： <span class="math display">\[Z^- = (\min\{z_{11},z_{21},\cdots,z_{n1}\},\min\{z_{12},z_{22},\cdots,z_{n2}\}, \cdots,\min\{z_{1m},z_{2m},\cdots,z_{nm}\})\]</span> 定义第 <span class="math inline">\(i(i =1,2,…,n)\)</span>个评价对象与最大值的距离： <spanclass="math display">\[D_i^+ = \sqrt{\sum_{j=1}^{m}(Z_j^+ - z_{ij})^2}\]</span> 定义第 <span class="math inline">\(i(i = 1,2,…,n)\)</span>个评价对象与最小值的距离：</p><p><span class="math display">\[D_i^- = \sqrt{\sum_{j=1}^{m}(Z_j^- - z_{ij})^2}\]</span> 那么，我们可以计算得出第 <span class="math inline">\(i(i =1,2,…,n)\)</span> 个评价对象未归一化的得分：</p><p><span class="math display">\[S_i = \frac{D_i^-}{D_i^+ + D_i^-}\]</span> 很明显 <span class="math inline">\(0 \leq S_i \leq1\)</span>，且 <span class="math inline">\(S_i\)</span> 越大 <spanclass="math inline">\(D_i^+\)</span> 越小，即越接近最大值。</p><h2 id="二扩展">二、扩展</h2><h4 id="权重结合">权重结合</h4><p>上述过程默认了各项指标的权重相同，但在实际的评价中指标都是有各自的权重，因此应该用权重对公式进行修正，修正后的公式如下，ω代表权重。<span class="math display">\[D_i^+ = \sqrt{\sum_{j=1}^{m}\omega_j(Z_j^+ - z_{ij})^2},\ D_i^- =\sqrt{\sum_{j=1}^{m}\omega_j(Z_j^- - z_{ij})^2}\]</span> 这里就可以直接上熵权法，当然，专家瞎打分也不是不行。</p><h4 id="本质推导">本质推导</h4><p>公式：</p><p><span class="math display">\[S_i = \frac{D_i^-}{D_i^+ + D_i^-}\]</span> 实际上是：</p><p><span class="math display">\[\frac{x - \min}{\max - \min} \rightarrow \frac{x - \min}{(\max - x) + (x- \min)} \rightarrow \frac{x与最小值的距离}{x与最大值的距离 +x与最小值的距离}\]</span> <span class="math inline">\(D_i^+\)</span>与<spanclass="math inline">\(D_i^-\)</span>实际上是<strong>欧氏距离</strong>，这个的本质思想和熵权法的实际上是有很多的相同之处的。</p><h2 id="参考">参考</h2><p><ahref="https://blog.csdn.net/weixin_43819566/article/details/112342602">清风数学建模学习笔记——TOPSIS法（优劣解距离法）-CSDN博客</a></p><p><ahref="https://zhuanlan.zhihu.com/p/564302492">数学建模——常考评价类模型介绍- 知乎</a></p><p><ahref="https://zhuanlan.zhihu.com/p/266689519">TOPSIS(逼近理想解)算法原理详解与代码实现- 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>评价类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主成分分析-PCA</title>
    <link href="/2025/04/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-04-01-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-PCA/"/>
    <url>/2025/04/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-04-01-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-PCA/</url>
    
    <content type="html"><![CDATA[<h1 id="主成分分析-pca">主成分分析-PCA</h1><p>主成分分析（PCA）是一种降维算法，通过将原始变量进行线性组合，生成互不相关的主成分，从而保留数据的主要信息，以此来去噪，提升数据处理速度。PCA常用于数据简化、聚类分析及解决回归中多重共线性问题，但在解释主成分时往往较为模糊，故不常用于评价模型。</p><hr /><h2 id="一简介">一、简介</h2><ul><li><strong>目标：</strong>用较少的新变量替代原来较多的变量，尽可能保留原有信息。<br /></li><li><strong>应用：</strong> 数据降维、去除噪声、提升数据处理速度。<br /></li><li><strong>适用场景</strong>：指标高度相关易于解释、可解释需求低。</li><li><strong>局限性</strong>：非线性关系处理的不好，贡献度若是不足可能会丢失细节。</li></ul><hr /><h2 id="二思想">二、思想</h2><p>假设有 <span class="math inline">\(n\)</span> 个样本和 <spanclass="math inline">\(p\)</span> 个指标，构成一个 $ n p$的样本矩阵：</p><p><span class="math display">\[X = \begin{bmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{np} \\\end{bmatrix}= (x_1, x_2, \cdots, x_p)\]</span> 目标是寻找新的变量 $ z_1, z_2, , z_m $（其中 $ m p$），使其满足：</p><p><span class="math display">\[\begin{cases}z_1 = l_{11}x_1 + l_{12}x_2 + \cdots + l_{1p}x_p \\z_2 = l_{21}x_1 + l_{22}x_2 + \cdots + l_{2p}x_p \\\vdots \\z_m = l_{m1}x_1 + l_{m2}x_2 + \cdots + l_{mp}x_p \\\end{cases}\]</span> <strong>系数 $ l_{ij} $ 的确定原则：</strong></p><ol type="1"><li>不同主成分之间彼此不相关。</li><li>第一主成分是所有线性组合中方差最大的。</li><li>第二主成分在与第一主成分不相关的条件下方差最大。</li><li>依此类推，直到选出 $ m $ 个主成分。</li></ol><hr /><h2 id="三计算步骤">三、计算步骤</h2><h3 id="数据标准化">1. 数据标准化</h3><ul><li><p><strong>计算均值和标准差：</strong> <span class="math display">\[\bar{x}_j = \frac{1}{n} \sum_{i=1}^{n} x_{ij},\quad S_j =\sqrt{\frac{\sum_{i=1}^{n}(x_{ij}-\bar{x}_j)^2}{n-1}}\]</span></p></li><li><p><strong>标准化数据：</strong> <span class="math display">\[X_{ij} = \frac{x_{ij}-\bar{x}_j}{S_j}\]</span></p></li><li><p><strong>标准化后的矩阵：</strong> <span class="math display">\[X = \begin{bmatrix}X_{11} &amp; X_{12} &amp; \cdots &amp; X_{1p} \\X_{21} &amp; X_{22} &amp; \cdots &amp; X_{2p} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\X_{n1} &amp; X_{n2} &amp; \cdots &amp; X_{np} \\\end{bmatrix}\]</span></p></li></ul><h3 id="计算协方差矩阵">2. 计算协方差矩阵</h3><ul><li><strong>定义：</strong> <span class="math display">\[R = \begin{bmatrix}r_{11} &amp; r_{12} &amp; \cdots &amp; r_{1p} \\r_{21} &amp; r_{22} &amp; \cdots &amp; r_{2p} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\r_{p1} &amp; r_{p2} &amp; \cdots &amp; r_{pp} \\\end{bmatrix},\quad r_{ij} = \frac{1}{n-1}\sum_{k=1}^{n} X_{ki} X_{kj}\]</span></li></ul><h3 id="求解特征值和特征向量">3. 求解特征值和特征向量</h3><ul><li><p><strong>特征值：</strong> <span class="math display">\[\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_p \geq 0\]</span> （且 $ R $ 为半正定矩阵）</p></li><li><p><strong>对应的特征向量：</strong> <span class="math display">\[a_1 = \begin{bmatrix} a_{11} \\ a_{21} \\ \vdots \\ a_{p1}\end{bmatrix},\quada_2 = \begin{bmatrix} a_{12} \\ a_{22} \\ \vdots \\ a_{p2}\end{bmatrix},\quad \dots,\quada_p = \begin{bmatrix} a_{1p} \\ a_{2p} \\ \vdots \\ a_{pp} \end{bmatrix}\]</span></p></li><li></li></ul><h3 id="计算贡献率和累计贡献率">4. 计算贡献率和累计贡献率</h3><ul><li><p><strong>贡献率：</strong> <span class="math display">\[\text{贡献率} = \frac{\lambda_i}{\sum_{k=1}^{p}\lambda_k}\]</span></p></li><li><p><strong>累计贡献率：</strong> <span class="math display">\[\text{累计贡献率} =\frac{\sum_{k=1}^{i}\lambda_k}{\sum_{k=1}^{p}\lambda_k}\quad(i=1,2,\dots,p)\]</span></p></li><li></li></ul><h3 id="写出主成分">5. 写出主成分</h3><p>一般选择累计贡献率超过 80% 的前 ( m ) 个主成分：</p><p><span class="math display">\[F_i = a_{1i}X_1 + a_{2i}X_2 + \cdots + a_{pi}X_p,\quad (i=1,2,\dots,m)\]</span></p><h3 id="主成分的解释">6. 主成分的解释</h3><p>根据各指标在主成分中的载荷大小判断该主成分代表的含义，载荷越大的指标对该主成分的影响越大。</p><hr /><h2 id="四扩展">四、扩展</h2><ol type="1"><li><strong>聚类分析：</strong>可通过降维简化自变量，便于图形展示。</li><li><strong>回归分析：</strong> 可用于缓解多重共线性问题。</li><li><strong>因子分析：</strong> PCA实际上是因子分析的一种特例，但因子分析在解释方面更具优势，建议多用因子分析。</li></ol><hr /><h2 id="参考资料">参考资料</h2><p><ahref="https://blog.csdn.net/weixin_43819566/article/details/113800120">清风数学建模学习笔记——主成分分析(PCA)原理详解及案例分析_x10为生均教育经费对以上指标数据做主成分分析，并提取主成分-CSDN博客</a></p><p><ahref="https://developer.baidu.com/article/details/3015610">数学建模中的主成分分析(PCA)详解与应用-百度开发者中心</a></p><p><ahref="https://zhuanlan.zhihu.com/p/677797684">【数模百科】一文讲清楚主成分分析PCA（附python代码）- 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>评价类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>皮尔逊相关系数-PEARSON</title>
    <link href="/2025/03/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B0%8F%E5%B7%A5%E5%85%B7/2025-03-31-%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
    <url>/2025/03/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B0%8F%E5%B7%A5%E5%85%B7/2025-03-31-%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="皮尔逊相关系数">皮尔逊相关系数</h1><p>方差描述的是单个变量的离散程度，协方差给方差的一个 <spanclass="math inline">\((X - E[X])^2\)</span> 变成 <spanclass="math inline">\((X - E[X])(Y - E[Y])\)</span>，就能衡量的是两个变量偏离各自均值后乘积的平均值，反映了两变量共同变化的趋势。但由于协方差受变量的单位影响，难以直接比较，所以我们就要将其无量纲化，除上各自的标准差就好。</p><h2 id="定义">定义</h2><p>皮尔逊相关系数（通常称为<strong>线性相关系数</strong>）用于刻画变量 X与 Y 之间的线性关系。其定义为： <span class="math display">\[\rho_{X, Y} = \frac{\operatorname{cov}(X, Y)}{\sigma_X \sigma_Y} =\frac{E\left[(X - E[X])(Y - E[Y])\right]}{\sigma_X \sigma_Y} =\frac{E(XY) - E(X)E(Y)}{\sqrt{E\left(X^2\right) - [E(X)]^2}\sqrt{E\left(Y^2\right) - [E(Y)]^2}}\]</span></p><blockquote><p><strong>注：</strong> 当 X 与 Y存在其他非线性关系时，皮尔逊相关系数无法正确反映两者之间的关系。</p></blockquote><hr /><h2 id="相关系数的性质">相关系数的性质</h2><ol type="1"><li><p><strong>独立性与不相关性：</strong></p><p>如果 X 和 Y 独立，则 <span class="math inline">\(\rho_{X,Y} =0\)</span>；但反过来，<span class="math inline">\(\rho_{X,Y} =0\)</span> 不一定说明 X 与 Y 独立，除非二者服从二维正态分布。</p></li><li><p><strong>取值范围：</strong></p></li></ol><p><span class="math display">\[-1 \leq \rho_{X,Y} \leq 1\]</span></p><hr /><h2 id="两组指标相关系数的计算">两组指标相关系数的计算</h2><h3 id="均值">均值：</h3><p><span class="math display">\[\bar{X} = \frac{1}{n}\sum_{i=1}^{n} X_i,\quad \bar{Y} =\frac{1}{n}\sum_{i=1}^{n} Y_i\]</span></p><h3 id="方差无偏估计">方差（无偏估计）：</h3><p><span class="math display">\[\sigma_X^2 = \frac{1}{n-1}\sum_{i=1}^{n}(X_i - \bar{X})^2,\quad\sigma_Y^2 = \frac{1}{n-1}\sum_{i=1}^{n}(Y_i - \bar{Y})^2\]</span></p><h3 id="样本协方差">样本协方差：</h3><p><span class="math display">\[\operatorname{cov}(X,Y) = \frac{1}{n-1}\sum_{i=1}^{n}(X_i - \bar{X})(Y_i- \bar{Y})\]</span></p><h3 id="相关系数">相关系数：</h3><p><span class="math display">\[r = \frac{\sum_{i=1}^{n}(X_i - \bar{X})(Y_i -\bar{Y})}{\sqrt{\sum_{i=1}^{n}(X_i - \bar{X})^2}\sqrt{\sum_{i=1}^{n}(Y_i - \bar{Y})^2}}\]</span></p><blockquote><p><strong>说明：</strong>分母中用的是各自的标准差，目的是将协方差无量纲化，从而消除不同变量之间单位和量级的影响，使得计算结果统一在([-1, 1]) 之间。</p></blockquote><hr /><h2 id="判断标准">判断标准</h2><p>根据计算得出的相关系数 (r)的绝对值，可以判断两个变量之间的相关性强弱：</p><table><thead><tr><th>|r|</th><th>相关强度</th></tr></thead><tbody><tr><td>0.8-1.0</td><td>极强相关</td></tr><tr><td>0.6-0.8</td><td>强相关</td></tr><tr><td>0.4-0.6</td><td>中等程度相关</td></tr><tr><td>0.2-0.4</td><td>弱相关</td></tr><tr><td>0.0-0.2</td><td>极弱相关或无相关</td></tr></tbody></table><hr /><h2 id="其它参考资源">其它参考资源</h2><ul><li><a href="#">带你深入理解期望、方差、协方差的含义</a></li><li><a href="https://www.zhihu.com/question/19734616">知乎：如何理解Pearson 相关系数</a></li><li><ahref="https://blog.csdn.net/MoreAction_/article/details/106195689">相关系数——皮尔逊相关系数的公式及其理解_皮尔逊相关系数公式-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>熵权法-EWM</title>
    <link href="/2025/03/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-03-31-%E7%86%B5%E6%9D%83%E6%B3%95(EWM)/"/>
    <url>/2025/03/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/2025-03-31-%E7%86%B5%E6%9D%83%E6%B3%95(EWM)/</url>
    
    <content type="html"><![CDATA[<h1 id="熵权法-ewm">熵权法-EWM</h1><h2 id="背景">背景</h2><p>一种常见于数学建模的更为客观的分配权重的方法，因为层次分析法主观性太强，专家打分实际上就是自己瞎几把打，故引入熵权法。</p><h2 id="思路">思路</h2><p>对于一组数据指标，如果它的方差越大，就说明这个数据的相似度越小，就是它所贡献度就越大。极端来看，就如果对于某项指标来讲，他的所有的值是一样的，那么它的相似度是最大的，基于这个指标来进行判别的权重可以直接设为0。熵是不确定度的一种度量，不确定性越大，熵就越大，信息量就越大，它的对最终决策的影响权重应该就设置得更高一些。</p><p>举个清风数学建模的例子，小张和小王是两个高中生，小张学习好回回期末考满分，小王学习不好考试常常不及格。在一次考试中，小张还是考了满分，而小王也考了满分。那就很不一样了，小王这里包含的信息就非常大，所对应的权重也就高一些。</p><h2 id="定义">定义</h2><ul><li><p><strong>信息量</strong></p><p>定义信息量为：<br /><span class="math display">\[I(x) = -\ln(p(x))\]</span></p></li><li><p><strong>信息熵</strong> 定义信息熵为各信息量的期望值： <spanclass="math display">\[H(X) = -\sum_{i=1}^{n} p(x_i)\ln(p(x_i))\]</span> 当所有事件均等时，熵达到最大值：<br /><span class="math display">\[H(X) = \ln(n)\]</span></p></li></ul><hr /><h2 id="计算步骤">计算步骤</h2><p>熵权法主要包括以下三个步骤：</p><h3 id="数据标准化">数据标准化</h3><p>假设有个对象和个指标，原始数据构成矩阵（要先正向化）：</p><p><span class="math display">\[X = \begin{bmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1m} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2m} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{n1} &amp; x_{n2} &amp; \cdots &amp; x_{nm}\end{bmatrix}\]</span></p><h4 id="正向化处理">正向化处理</h4><ul><li><strong>要求</strong>：后续计算概率时，每个元素必须为非负值。<br /></li><li><strong>处理</strong>：如果其中存在负数，则需采用特定方法将其标准化到[0,1] 区间。</li></ul><table><thead><tr><th>指标名称</th><th>指标特点</th><th>例子</th></tr></thead><tbody><tr><td>极大型指标（正向指标）</td><td>越大越好</td><td>成绩、利润、GDP增速</td></tr><tr><td>极小型指标（负向指标）</td><td>越小越好</td><td>花费、污染程度、失业率</td></tr><tr><td>中间型指标</td><td>越接近某个值越好</td><td>水质量评估时的PH值</td></tr><tr><td>区间型指标</td><td>落在某个区间最好</td><td>体温、水中某物质含量</td></tr></tbody></table><ul><li>极小型转极大型：</li></ul><p><span class="math display">\[x_i = \max\{x_1, x_2, ..., x_i\} - x_i\]</span></p><p>注：若所有元素均为正数，可以直接取倒数。</p><ul><li>中间行转极大型：</li></ul><p>中间型指标序列，且最佳数值为 <spanclass="math inline">\(x_{best}\)</span>，<spanclass="math inline">\(x_{new}\)</span>为正向化之后的极大型指标，正向化公式：</p><p><span class="math display">\[  M = \max\{|x_i - x_{best}|\}\]</span></p><p><span class="math display">\[x_{new} = 1 - \frac{|x_i - x_{best}|}{M}\]</span></p><ul><li>区间型转极大型:</li></ul><p>区间型指标序列，且最佳数值为 <spanclass="math inline">\(x_{best}\)</span>，<spanclass="math inline">\(x_{new}\)</span>为正向化之后的极大型指标，正向化公式： <span class="math display">\[M = \max\{a - \min\{x_i\}, \max\{x_i\} - b\}\]</span></p><p><span class="math display">\[x_{new} =\begin{cases}1 - \frac{a - x}{M}, &amp; x &lt; a \\1, &amp; a \leq x \leq b \\1 - \frac{x - b}{M}, &amp; x &gt; b\end{cases}\]</span></p><h4 id="标准化方法">标准化方法</h4><ul><li><p><strong>方法一</strong>（适用于无负数情况）： <spanclass="math display">\[z_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^{n} x_{ij}^2}}\]</span></p></li><li><p><strong>方法二</strong>（存在负数时）： <spanclass="math display">\[z_{ij} = \frac{x_{ij} - \min\{x_{1j}, x_{2j}, \ldots,x_{nj}\}}{\max\{x_{1j}, x_{2j}, \ldots, x_{nj}\} - \min\{x_{1j}, x_{2j},\ldots, x_{nj}\}}\]</span></p></li></ul><hr /><h3 id="计算概率矩阵">计算概率矩阵</h3><p>从标准化矩阵出发，计算各样本在每个指标下所占的比重，构成概率矩阵：</p><p><span class="math display">\[p_{ij} = \frac{z_{ij}}{\sum_{i=1}^{n} z_{ij}}\]</span> 这样确保每一列（每个指标）的概率和为1。</p><hr /><h3 id="计算信息熵与熵权">计算信息熵与熵权</h3><h4 id="计算信息熵">计算信息熵</h4><p>计算信息熵：</p><p><span class="math display">\[e_j = -\frac{1}{\ln n} \sum_{i=1}^{n} p_{ij}\ln(p_{ij}) \quad(j=1,2,\ldots,m)\]</span> <em>注意：当 <span class="math inline">\(p_{ij}=0\)</span>时，约定 <span class="math inline">\(\ln(0)=0\)</span> 。</em></p><p>这里除以 <span class="math inline">\(\ln n\)</span> 使得 <spanclass="math inline">\(e_j\)</span> 被归一化到 <spanclass="math inline">\([0,1]\)</span> 区间。</p><h4 id="计算信息效用值">计算信息效用值</h4><p>定义信息效用值 <span class="math inline">\(d_j\)</span> 为： <spanclass="math display">\[d_j = 1 - e_j\]</span> 信息效用值越大，表示该指标包含的信息越多。</p><h4 id="归一化得熵权">归一化得熵权</h4><p>最终，将各指标的信息效用值归一化，得到熵权 <spanclass="math inline">\(\omega_j\)</span>： <span class="math display">\[\omega_j = \frac{d_j}{\sum_{j=1}^{m} d_j} \quad (j=1,2,\ldots,m)\]</span></p><h4 id="得分">得分</h4><p><span class="math display">\[score_i =  \sum_{j=1}^{m} w_{j}z_{ij} \quad (i=1,2,\ldots,n)\]</span></p><h2 id="示例代码">示例代码</h2><p>（转自<ahref="https://blog.csdn.net/m0_46246301/article/details/106735607">这篇帖子</a>）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 代码实战一下吧，如下是清风老师的课程里的例子，自己再敲了一下代码并简化了一丢丢？</span><br>clc,clear;<br><br><span class="hljs-comment">% 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[lnP]</span> = <span class="hljs-title">My_log</span><span class="hljs-params">(P)</span></span><br>    <span class="hljs-comment">% 当矩阵P中的元素为0时，返回0</span><br>    n = <span class="hljs-built_in">size</span>(P,<span class="hljs-number">1</span>);<br>    m = <span class="hljs-built_in">size</span>(P,<span class="hljs-number">2</span>);<br>    lnP = <span class="hljs-built_in">zeros</span>(n,m);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:n*m<br>        <span class="hljs-keyword">if</span> P(<span class="hljs-built_in">i</span>) == <span class="hljs-number">0</span><br>            lnP(<span class="hljs-built_in">i</span>) = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            lnP(<span class="hljs-built_in">i</span>) = <span class="hljs-built_in">log</span>(P(<span class="hljs-built_in">i</span>));<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 传入三个参数：</span><br><span class="hljs-comment">% i为第几列,type为指标类型(1：极小型， 2：中间型， 3：区间型),A_col为对应列向量</span><br><span class="hljs-comment">% 返回正向化后的列向量A_col</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[A_col]</span> = <span class="hljs-title">Positivization</span><span class="hljs-params">(i,type,A_col)</span></span><br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span> == <span class="hljs-number">1</span>        <span class="hljs-comment">% 极小型</span><br>        <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;第&#x27;</span>,num2str(<span class="hljs-built_in">i</span>),<span class="hljs-string">&#x27;列是极小型&#x27;</span>] )<br>        A_col = min_to_max(A_col);<br>    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span> == <span class="hljs-number">2</span>    <span class="hljs-comment">% 中间型</span><br>        <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;第&#x27;</span>,num2str(<span class="hljs-built_in">i</span>),<span class="hljs-string">&#x27;列是中间型&#x27;</span>] )<br>        value = input(<span class="hljs-string">&#x27;请输入最佳值： &#x27;</span>);<br>        A_col = mid_to_max(A_col, value);<br>    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span> == <span class="hljs-number">3</span>    <span class="hljs-comment">% 区间型</span><br>        <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;第&#x27;</span>,num2str(<span class="hljs-built_in">i</span>),<span class="hljs-string">&#x27;列是区间型&#x27;</span>] )<br>        l = input(<span class="hljs-string">&#x27;请输入区间的下界： &#x27;</span>);<br>        r = input(<span class="hljs-string">&#x27;请输入区间的上界： &#x27;</span>); <br>        A_col = inter_to_max(A_col, l, r);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;没有这种类型的指标,请检查type是否输入错误&#x27;</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 1、导入数据</span><br>load data_river.mat<br><span class="hljs-comment">% 2、正向化</span><br>[n,m] = <span class="hljs-built_in">size</span>(A);<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;该数据一共有&#x27;</span>,num2str(n),<span class="hljs-string">&#x27;个评价对象,有&#x27;</span>,num2str(m),<span class="hljs-string">&#x27;个评价指标&#x27;</span>])<br>jud = input([<span class="hljs-string">&#x27;这&#x27;</span> num2str(m) <span class="hljs-string">&#x27;个指标是否需要进行正向化处理，需要请输入1 ，不需要输入0：&#x27;</span>]);<br><span class="hljs-keyword">if</span> jud == <span class="hljs-number">1</span><br>    col_list = input(<span class="hljs-string">&#x27;请输入需要正向化的指标所在列组成的列表，如第2、3列，需输入[2,3]: &#x27;</span>);<br>    type_list = input(<span class="hljs-string">&#x27;请输入这些列的指标类型组成的列表（1：极小型， 2：中间型， 3：区间型): &#x27;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(col_list,<span class="hljs-number">2</span>)  <span class="hljs-comment">% 列</span><br>        A(:,col_list(<span class="hljs-built_in">i</span>)) = Positivization(col_list(<span class="hljs-built_in">i</span>),type_list(<span class="hljs-built_in">i</span>),A(:,col_list(<span class="hljs-built_in">i</span>)));<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% 3、标准化</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isempty</span>(<span class="hljs-built_in">find</span>(A &lt; <span class="hljs-number">0</span>))<br>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;不存在负数，标准化后的矩阵为:&#x27;</span>)<br>    <span class="hljs-comment">% A_stand = A./ repmat(sum(A.*A).^(1/2),n,1) % 按列求和</span><br>    A_stand = (A - <span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">min</span>(A),n,<span class="hljs-number">1</span>))./(<span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">max</span>(A)-<span class="hljs-built_in">min</span>(A),n,<span class="hljs-number">1</span>)) <br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;存在负数，标准化后的矩阵为:&#x27;</span>)<br>    A_stand = (A - <span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">min</span>(A),n,<span class="hljs-number">1</span>))./(<span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">max</span>(A)-<span class="hljs-built_in">min</span>(A),n,<span class="hljs-number">1</span>)) <br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% 4、计算概率矩阵:相当于每个标准化后的指标归一化</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;概率矩阵为:&#x27;</span>)<br>P = A_stand./<span class="hljs-built_in">repmat</span>(sum(A_stand),n,<span class="hljs-number">1</span>)<br><span class="hljs-comment">% 5、计算每个指标的信息熵</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;指标的信息熵:&#x27;</span>)<br>E = -sum(P.*My_log(P))/<span class="hljs-built_in">log</span>(n)<br><span class="hljs-comment">% 6、计算权重</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;指标对应的权重:&#x27;</span>)<br>W = (<span class="hljs-number">1</span>-E)./sum(E)<br><span class="hljs-comment">% 归一化</span><br>W = W./sum(W)<br><span class="hljs-comment">% 7、计算最终得分</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;最终综合得分为:&#x27;</span>)<br>score = sum(W.*A_stand,<span class="hljs-number">2</span>)<br>score_stand = score ./ sum(score);<br>[score_stand_sort, index] = <span class="hljs-built_in">sort</span>(score_stand, <span class="hljs-string">&#x27;descend&#x27;</span>);<br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;最终名次为:&#x27;</span>)<br><span class="hljs-built_in">disp</span>(index)<br></code></pre></td></tr></table></figure><hr /><h2 id="扩展">扩展</h2><ol type="1"><li><strong>修正TOPSIS法</strong>：可利用熵权法修正TOPSIS法，使决策更加客观。</li><li><strong>主客观权重综合</strong>：将客观赋权（熵权法）与主观赋权相结合，可获得更合理的权重分配。</li><li><strong>其他客观赋权方法</strong>：例如灰色关联分析法也可作为计算权重的方法。</li><li><strong>标准化方法选择</strong>：不同的标准化方法会得到不同的 (Z)矩阵，需根据实际情况选择合适方法。</li></ol><hr /><h2 id="模型总结">模型总结</h2><ul><li><strong>第一步</strong>：检查输入矩阵中是否存在负数，并进行必要的标准化处理，确保数据非负。</li><li><strong>第二步</strong>：计算每个指标下每个样本的比重，构成概率矩阵。</li><li><strong>第三步</strong>：利用概率矩阵计算各指标的信息熵，然后计算信息效用值，最后归一化得到各指标的权重。</li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
      <category>评价类模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XGBoost公式文档</title>
    <link href="/2025/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/2025-03-31-XGBoost&#39;s_latex/"/>
    <url>/2025/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/2025-03-31-XGBoost&#39;s_latex/</url>
    
    <content type="html"><![CDATA[<h1 id="xgboost技术文档">XGBoost技术文档</h1><h2 id="参数设置">参数设置</h2><p>见代码</p><h2 id="涉及到的相关数学公式">涉及到的相关数学公式：</h2><ul><li><strong>模型目标函数</strong>：</li></ul><p><span class="math display">\[\text{Obj}(\theta)^{(t)} = \sum_{i=1}^n L(y_i, \hat{y}_i) + \sum_{k=1}^K\Omega(f_k)\]</span></p><ul><li><strong>正则项</strong></li></ul><p><span class="math display">\[\Omega(f) = \gamma T + \frac{1}{2} \lambda \sum_{j=1}^T w_j^2\]</span></p><ul><li><strong>目标函数近似</strong></li></ul><p><span class="math display">\[\text{Obj}(\theta)^{(t)} \approx \sum_{i=1}^n \left[ g_i f_t(x_i) +\frac{1}{2} h_i f_t^2(x_i) \right] + \Omega(f_t)\]</span></p><ul><li><strong>增益</strong></li></ul><p><span class="math display">\[\text{Gain} = \frac{1}{2} \left[ \frac{(\sum_{i \in I_L} g_i)^2}{\sum_{i\in I_L} h_i + \lambda} + \frac{(\sum_{i \in I_R} g_i)^2}{\sum_{i \inI_R} h_i + \lambda} - \frac{(\sum_{i \in I} g_i)^2}{\sum_{i \in I} h_i +\lambda} \right] - \gamma\]</span></p><ul><li><strong>对数损失</strong></li></ul><p><span class="math display">\[\text{LogLoss} = -\frac{1}{N} \sum_{i=1}^N \left[ y_i \log p_i + (1-y_i)\log(1-p_i) \right]\]</span></p><ul><li><strong>分类错误率</strong></li></ul><p><span class="math display">\[\text{Error} = \frac{1}{N} \sum_{i=1}^N \mathbb{I}(\hat{y}_i \neq y_i)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>公式推导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
